// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Printf from "./printf.js";
import * as $$Location from "./location.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";

var $$Error = /* @__PURE__ */Caml_exceptions.create("Syntaxerr.Error");

var Escape_error = /* @__PURE__ */Caml_exceptions.create("Syntaxerr.Escape_error");

function prepare_error(x) {
  switch (x.TAG | 0) {
    case /* Unclosed */0 :
        var closing = x._3;
        var opening = x._1;
        return Curry._1($$Location.errorf(x._2, {
                        hd: Curry._1($$Location.errorf(x._0, undefined, undefined, "This '%s' might be unmatched"), opening),
                        tl: /* [] */0
                      }, Curry._2(Printf.sprintf("Syntax error: '%s' expected, the highlighted '%s' might be unmatched"), closing, opening), "Syntax error: '%s' expected"), closing);
    case /* Expecting */1 :
        return Curry._1($$Location.errorf(x._0, undefined, undefined, "Syntax error: %s expected."), x._1);
    case /* Not_expecting */2 :
        return Curry._1($$Location.errorf(x._0, undefined, undefined, "Syntax error: %s not expected."), x._1);
    case /* Applicative_path */3 :
        return $$Location.errorf(x._0, undefined, undefined, "Syntax error: applicative paths of the form F(X).t are not supported when the option -no-app-func is set.");
    case /* Variable_in_scope */4 :
        var $$var = x._1;
        return Curry._2($$Location.errorf(x._0, undefined, undefined, "In this scoped type, variable '%s is reserved for the local type %s."), $$var, $$var);
    case /* Other */5 :
        return $$Location.errorf(x._0, undefined, undefined, "Syntax error");
    case /* Ill_formed_ast */6 :
        return Curry._1($$Location.errorf(x._0, undefined, undefined, "broken invariant in parsetree: %s"), x._1);
    case /* Invalid_package_type */7 :
        return Curry._1($$Location.errorf(x._0, undefined, undefined, "invalid package type: %s"), x._1);
    
  }
}

$$Location.register_error_of_exn(function (x) {
      if (x.RE_EXN_ID === $$Error) {
        return prepare_error(x._1);
      }
      
    });

function report_error(ppf, err) {
  
}

function location_of_error(x) {
  return x._0;
}

function ill_formed_ast(loc, s) {
  throw {
        RE_EXN_ID: $$Error,
        _1: {
          TAG: /* Ill_formed_ast */6,
          _0: loc,
          _1: s
        },
        Error: new Error()
      };
}

export {
  $$Error ,
  Escape_error ,
  prepare_error ,
  report_error ,
  location_of_error ,
  ill_formed_ast ,
  
}
/*  Not a pure module */
