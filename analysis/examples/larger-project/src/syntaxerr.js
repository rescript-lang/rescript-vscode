// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Printf from "rescript/lib/es6/printf.js";
import * as $$Location from "./location.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";

var $$Error = /* @__PURE__ */Caml_exceptions.create("Syntaxerr.Error");

var Escape_error = /* @__PURE__ */Caml_exceptions.create("Syntaxerr.Escape_error");

function prepare_error(x) {
  switch (x.TAG | 0) {
    case /* Unclosed */0 :
        var closing = x._3;
        var opening = x._1;
        return Curry._1($$Location.errorf(x._2, {
                        hd: Curry._1($$Location.errorf(x._0, undefined, undefined, /* Format */{
                                  _0: {
                                    TAG: /* String_literal */11,
                                    _0: "This '",
                                    _1: {
                                      TAG: /* String */2,
                                      _0: /* No_padding */0,
                                      _1: {
                                        TAG: /* String_literal */11,
                                        _0: "' might be unmatched",
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  },
                                  _1: "This '%s' might be unmatched"
                                }), opening),
                        tl: /* [] */0
                      }, Curry._2(Printf.sprintf(/* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "Syntax error: '",
                                  _1: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: {
                                      TAG: /* String_literal */11,
                                      _0: "' expected, the highlighted '",
                                      _1: {
                                        TAG: /* String */2,
                                        _0: /* No_padding */0,
                                        _1: {
                                          TAG: /* String_literal */11,
                                          _0: "' might be unmatched",
                                          _1: /* End_of_format */0
                                        }
                                      }
                                    }
                                  }
                                },
                                _1: "Syntax error: '%s' expected, the highlighted '%s' might be unmatched"
                              }), closing, opening), /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "Syntax error: '",
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* String_literal */11,
                              _0: "' expected",
                              _1: /* End_of_format */0
                            }
                          }
                        },
                        _1: "Syntax error: '%s' expected"
                      }), closing);
    case /* Expecting */1 :
        return Curry._1($$Location.errorf(x._0, undefined, undefined, /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "Syntax error: ",
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* String_literal */11,
                              _0: " expected.",
                              _1: /* End_of_format */0
                            }
                          }
                        },
                        _1: "Syntax error: %s expected."
                      }), x._1);
    case /* Not_expecting */2 :
        return Curry._1($$Location.errorf(x._0, undefined, undefined, /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "Syntax error: ",
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* String_literal */11,
                              _0: " not expected.",
                              _1: /* End_of_format */0
                            }
                          }
                        },
                        _1: "Syntax error: %s not expected."
                      }), x._1);
    case /* Applicative_path */3 :
        return $$Location.errorf(x._0, undefined, undefined, /* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Syntax error: applicative paths of the form F(X).t are not supported when the option -no-app-func is set.",
                      _1: /* End_of_format */0
                    },
                    _1: "Syntax error: applicative paths of the form F(X).t are not supported when the option -no-app-func is set."
                  });
    case /* Variable_in_scope */4 :
        var $$var = x._1;
        return Curry._2($$Location.errorf(x._0, undefined, undefined, /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "In this scoped type, variable '",
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* String_literal */11,
                              _0: " is reserved for the local type ",
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* Char_literal */12,
                                  _0: /* '.' */46,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        },
                        _1: "In this scoped type, variable '%s is reserved for the local type %s."
                      }), $$var, $$var);
    case /* Other */5 :
        return $$Location.errorf(x._0, undefined, undefined, /* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Syntax error",
                      _1: /* End_of_format */0
                    },
                    _1: "Syntax error"
                  });
    case /* Ill_formed_ast */6 :
        return Curry._1($$Location.errorf(x._0, undefined, undefined, /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "broken invariant in parsetree: ",
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: /* End_of_format */0
                          }
                        },
                        _1: "broken invariant in parsetree: %s"
                      }), x._1);
    case /* Invalid_package_type */7 :
        return Curry._1($$Location.errorf(x._0, undefined, undefined, /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "invalid package type: ",
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: /* End_of_format */0
                          }
                        },
                        _1: "invalid package type: %s"
                      }), x._1);
    
  }
}

$$Location.register_error_of_exn(function (x) {
      if (x.RE_EXN_ID === $$Error) {
        return prepare_error(x._1);
      }
      
    });

function report_error(ppf, err) {
  
}

function location_of_error(x) {
  return x._0;
}

function ill_formed_ast(loc, s) {
  throw {
        RE_EXN_ID: $$Error,
        _1: {
          TAG: /* Ill_formed_ast */6,
          _0: loc,
          _1: s
        },
        Error: new Error()
      };
}

export {
  $$Error ,
  Escape_error ,
  prepare_error ,
  report_error ,
  location_of_error ,
  ill_formed_ast ,
  
}
/*  Not a pure module */
