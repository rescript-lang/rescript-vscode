Complete src/Completion.res 1:11
posCursor:[1:11] posNoWhite:[1:10] Found expr:[1:3->1:11]
Pexp_ident MyList.m:[1:3->1:11]
Completable: Cpath Value[MyList, m]
[{
    "label": "mapReverse",
    "kind": 12,
    "tags": [],
    "detail": "(t<'a>, 'a => 'b) => t<'b>",
    "documentation": {"kind": "markdown", "value": "\n  Equivalent to:\n\n  ```res\n  map(someList, f)->reverse\n  ```\n\n  ```res example\n  list{3, 4, 5}->Belt.List.mapReverse(x => x * x) /* list{25, 16, 9} */\n  ```\n"}
  }, {
    "label": "makeBy",
    "kind": 12,
    "tags": [],
    "detail": "(int, int => 'a) => t<'a>",
    "documentation": {"kind": "markdown", "value": "\nReturn a list of length `numItems` with element `i` initialized with `f(i)`.\nReturns an empty list if `numItems` is negative.\n\n```res example\nBelt.List.makeBy(5, i => i) // list{0, 1, 2, 3, 4}\n\nBelt.List.makeBy(5, i => i * i) // list{0, 1, 4, 9, 16}\n```\n"}
  }, {
    "label": "make",
    "kind": 12,
    "tags": [],
    "detail": "(int, 'a) => t<'a>",
    "documentation": {"kind": "markdown", "value": "\n  Returns a list of length `numItems` with each element filled with value `v`. Returns an empty list if `numItems` is negative.\n\n  ```res example\n  Belt.List.make(3, 1) // list{1, 1, 1}\n  ```\n"}
  }, {
    "label": "mapReverse2U",
    "kind": 12,
    "tags": [],
    "detail": "(t<'a>, t<'b>, (. 'a, 'b) => 'c) => t<'c>",
    "documentation": {"kind": "markdown", "value": " Uncurried version of [mapReverse2](#mapReverse2). "}
  }, {
    "label": "map",
    "kind": 12,
    "tags": [],
    "detail": "(t<'a>, 'a => 'b) => t<'b>",
    "documentation": {"kind": "markdown", "value": "\n  Returns a new list with `f` applied to each element of `someList`.\n\n  ```res example\n  list{1, 2}->Belt.List.map(x => x + 1) // list{3, 4}\n  ```\n"}
  }, {
    "label": "mapWithIndexU",
    "kind": 12,
    "tags": [],
    "detail": "(t<'a>, (. int, 'a) => 'b) => t<'b>",
    "documentation": {"kind": "markdown", "value": " Uncurried version of [mapWithIndex](#mapWithIndex). "}
  }, {
    "label": "mapU",
    "kind": 12,
    "tags": [],
    "detail": "(t<'a>, (. 'a) => 'b) => t<'b>",
    "documentation": {"kind": "markdown", "value": " Uncurried version of [map](#map). "}
  }, {
    "label": "makeByU",
    "kind": 12,
    "tags": [],
    "detail": "(int, (. int) => 'a) => t<'a>",
    "documentation": {"kind": "markdown", "value": " Uncurried version of [makeBy](#makeBy) "}
  }, {
    "label": "mapReverse2",
    "kind": 12,
    "tags": [],
    "detail": "(t<'a>, t<'b>, ('a, 'b) => 'c) => t<'c>",
    "documentation": {"kind": "markdown", "value": "\n  Equivalent to: `zipBy(xs, ys, f)->reverse`\n\n  ```res example\n\n  Belt.List.mapReverse2(list{1, 2, 3}, list{1, 2}, (a, b) => a + b) // list{4, 2}\n  ```\n"}
  }, {
    "label": "mapWithIndex",
    "kind": 12,
    "tags": [],
    "detail": "(t<'a>, (int, 'a) => 'b) => t<'b>",
    "documentation": {"kind": "markdown", "value": "\n  Applies `f` to each element of `someList`.\n  Function `f` takes two arguments: the index starting from 0 and the element from `someList`, in that order.\n\n  ```res example\n  list{1, 2, 3}->Belt.List.mapWithIndex((index, x) => index + x) // list{1, 3, 5}\n  ```\n"}
  }, {
    "label": "mapReverseU",
    "kind": 12,
    "tags": [],
    "detail": "(t<'a>, (. 'a) => 'b) => t<'b>",
    "documentation": {"kind": "markdown", "value": " Uncurried version of [mapReverse](#mapReverse). "}
  }]

Complete src/Completion.res 3:9
posCursor:[3:9] posNoWhite:[3:8] Found expr:[3:3->3:9]
Pexp_ident Array.:[3:3->3:9]
Completable: Cpath Value[Array, ""]
[{
    "label": "fold_left",
    "kind": 12,
    "tags": [],
    "detail": "(('a, 'b) => 'a, 'a, array<'b>) => 'a",
    "documentation": {"kind": "markdown", "value": " [Array.fold_left f x a] computes\n   [f (... (f (f x a.(0)) a.(1)) ...) a.(n-1)],\n   where [n] is the length of the array [a]. "}
  }, {
    "label": "concat",
    "kind": 12,
    "tags": [],
    "detail": "list<array<'a>> => array<'a>",
    "documentation": {"kind": "markdown", "value": " Same as {!Array.append}, but concatenates a list of arrays. "}
  }, {
    "label": "mapi",
    "kind": 12,
    "tags": [],
    "detail": "((int, 'a) => 'b, array<'a>) => array<'b>",
    "documentation": {"kind": "markdown", "value": " Same as {!Array.map}, but the\n   function is applied to the index of the element as first argument,\n   and the element itself as second argument. "}
  }, {
    "label": "exists",
    "kind": 12,
    "tags": [],
    "detail": "('a => bool, array<'a>) => bool",
    "documentation": {"kind": "markdown", "value": " [Array.exists p [|a1; ...; an|]] checks if at least one element of\n    the array satisfies the predicate [p]. That is, it returns\n    [(p a1) || (p a2) || ... || (p an)].\n    @since 4.03.0 "}
  }, {
    "label": "for_all",
    "kind": 12,
    "tags": [],
    "detail": "('a => bool, array<'a>) => bool",
    "documentation": {"kind": "markdown", "value": " [Array.for_all p [|a1; ...; an|]] checks if all elements of the array\n   satisfy the predicate [p]. That is, it returns\n   [(p a1) && (p a2) && ... && (p an)].\n   @since 4.03.0 "}
  }, {
    "label": "copy",
    "kind": 12,
    "tags": [],
    "detail": "array<'a> => array<'a>",
    "documentation": {"kind": "markdown", "value": " [Array.copy a] returns a copy of [a], that is, a fresh array\n   containing the same elements as [a]. "}
  }, {
    "label": "iter2",
    "kind": 12,
    "tags": [],
    "detail": "(('a, 'b) => unit, array<'a>, array<'b>) => unit",
    "documentation": {"kind": "markdown", "value": " [Array.iter2 f a b] applies function [f] to all the elements of [a]\n   and [b].\n   Raise [Invalid_argument] if the arrays are not the same size.\n   @since 4.03.0 "}
  }, {
    "label": "to_list",
    "kind": 12,
    "tags": [],
    "detail": "array<'a> => list<'a>",
    "documentation": {"kind": "markdown", "value": " [Array.to_list a] returns the list of all the elements of [a]. "}
  }, {
    "label": "stable_sort",
    "kind": 12,
    "tags": [],
    "detail": "(('a, 'a) => int, array<'a>) => unit",
    "documentation": {"kind": "markdown", "value": " Same as {!Array.sort}, but the sorting algorithm is stable (i.e.\n   elements that compare equal are kept in their original order) and\n   not guaranteed to run in constant heap space.\n\n   The current implementation uses Merge Sort. It uses [n/2]\n   words of heap space, where [n] is the length of the array.\n   It is usually faster than the current implementation of {!Array.sort}.\n"}
  }, {
    "label": "iteri",
    "kind": 12,
    "tags": [],
    "detail": "((int, 'a) => unit, array<'a>) => unit",
    "documentation": {"kind": "markdown", "value": " Same as {!Array.iter}, but the\n   function is applied with the index of the element as first argument,\n   and the element itself as second argument. "}
  }, {
    "label": "memq",
    "kind": 12,
    "tags": [],
    "detail": "('a, array<'a>) => bool",
    "documentation": {"kind": "markdown", "value": " Same as {!Array.mem}, but uses physical equality instead of structural\n   equality to compare array elements.\n   @since 4.03.0 "}
  }, {
    "label": "map2",
    "kind": 12,
    "tags": [],
    "detail": "(('a, 'b) => 'c, array<'a>, array<'b>) => array<'c>",
    "documentation": {"kind": "markdown", "value": " [Array.map2 f a b] applies function [f] to all the elements of [a]\n   and [b], and builds an array with the results returned by [f]:\n   [[| f a.(0) b.(0); ...; f a.(Array.length a - 1) b.(Array.length b - 1)|]].\n   Raise [Invalid_argument] if the arrays are not the same size.\n   @since 4.03.0 "}
  }, {
    "label": "set",
    "kind": 12,
    "tags": [],
    "detail": "(array<'a>, int, 'a) => unit",
    "documentation": {"kind": "markdown", "value": " [Array.set a n x] modifies array [a] in place, replacing\n   element number [n] with [x].\n   You can also write [a.(n) <- x] instead of [Array.set a n x].\n\n   Raise [Invalid_argument \"index out of bounds\"]\n   if [n] is outside the range 0 to [Array.length a - 1]. "}
  }, {
    "label": "make",
    "kind": 12,
    "tags": [],
    "detail": "(int, 'a) => array<'a>",
    "documentation": {"kind": "markdown", "value": " [Array.make n x] returns a fresh array of length [n],\n   initialized with [x].\n   All the elements of this new array are initially\n   physically equal to [x] (in the sense of the [==] predicate).\n   Consequently, if [x] is mutable, it is shared among all elements\n   of the array, and modifying [x] through one of the array entries\n   will modify all other entries at the same time.\n\n   Raise [Invalid_argument] if [n < 0] or [n > Sys.max_array_length].\n   If the value of [x] is a floating-point number, then the maximum\n   size is only [Sys.max_array_length / 2]."}
  }, {
    "label": "make_float",
    "kind": 12,
    "tags": [],
    "detail": "int => array<float>",
    "documentation": {"kind": "markdown", "value": " @deprecated [Array.make_float] is an alias for {!Array.create_float}. "}
  }, {
    "label": "fold_right",
    "kind": 12,
    "tags": [],
    "detail": "(('b, 'a) => 'a, array<'b>, 'a) => 'a",
    "documentation": {"kind": "markdown", "value": " [Array.fold_right f a x] computes\n   [f a.(0) (f a.(1) ( ... (f a.(n-1) x) ...))],\n   where [n] is the length of the array [a]. "}
  }, {
    "label": "sort",
    "kind": 12,
    "tags": [],
    "detail": "(('a, 'a) => int, array<'a>) => unit",
    "documentation": {"kind": "markdown", "value": " Sort an array in increasing order according to a comparison\n   function.  The comparison function must return 0 if its arguments\n   compare as equal, a positive integer if the first is greater,\n   and a negative integer if the first is smaller (see below for a\n   complete specification).  For example, {!Pervasives.compare} is\n   a suitable comparison function, provided there are no floating-point\n   NaN values in the data.  After calling [Array.sort], the\n   array is sorted in place in increasing order.\n   [Array.sort] is guaranteed to run in constant heap space\n   and (at most) logarithmic stack space.\n\n   The current implementation uses Heap Sort.  It runs in constant\n   stack space.\n\n   Specification of the comparison function:\n   Let [a] be the array and [cmp] the comparison function.  The following\n   must be true for all x, y, z in a :\n-   [cmp x y] > 0 if and only if [cmp y x] < 0\n-   if [cmp x y] >= 0 and [cmp y z] >= 0 then [cmp x z] >= 0\n\n   When [Array.sort] returns, [a] contains the same elements as before,\n   reordered in such a way that for all i and j valid indices of [a] :\n-   [cmp a.(i) a.(j)] >= 0 if and only if i >= j\n"}
  }, {
    "label": "length",
    "kind": 12,
    "tags": [],
    "detail": "array<'a> => int",
    "documentation": {"kind": "markdown", "value": " Return the length (number of elements) of the given array. "}
  }, {
    "label": "sub",
    "kind": 12,
    "tags": [],
    "detail": "(array<'a>, int, int) => array<'a>",
    "documentation": {"kind": "markdown", "value": " [Array.sub a start len] returns a fresh array of length [len],\n   containing the elements number [start] to [start + len - 1]\n   of array [a].\n\n   Raise [Invalid_argument \"Array.sub\"] if [start] and [len] do not\n   designate a valid subarray of [a]; that is, if\n   [start < 0], or [len < 0], or [start + len > Array.length a]. "}
  }, {
    "label": "of_list",
    "kind": 12,
    "tags": [],
    "detail": "list<'a> => array<'a>",
    "documentation": {"kind": "markdown", "value": " [Array.of_list l] returns a fresh array containing the elements\n   of [l]. "}
  }, {
    "label": "iter",
    "kind": 12,
    "tags": [],
    "detail": "('a => unit, array<'a>) => unit",
    "documentation": {"kind": "markdown", "value": " [Array.iter f a] applies function [f] in turn to all\n   the elements of [a].  It is equivalent to\n   [f a.(0); f a.(1); ...; f a.(Array.length a - 1); ()]. "}
  }, {
    "label": "map",
    "kind": 12,
    "tags": [],
    "detail": "('a => 'b, array<'a>) => array<'b>",
    "documentation": {"kind": "markdown", "value": " [Array.map f a] applies function [f] to all the elements of [a],\n   and builds an array with the results returned by [f]:\n   [[| f a.(0); f a.(1); ...; f a.(Array.length a - 1) |]]. "}
  }, {
    "label": "unsafe_get",
    "kind": 12,
    "tags": [],
    "detail": "(array<'a>, int) => 'a",
    "documentation": null
  }, {
    "label": "make_matrix",
    "kind": 12,
    "tags": [],
    "detail": "(int, int, 'a) => array<array<'a>>",
    "documentation": {"kind": "markdown", "value": " [Array.make_matrix dimx dimy e] returns a two-dimensional array\n   (an array of arrays) with first dimension [dimx] and\n   second dimension [dimy]. All the elements of this new matrix\n   are initially physically equal to [e].\n   The element ([x,y]) of a matrix [m] is accessed\n   with the notation [m.(x).(y)].\n\n   Raise [Invalid_argument] if [dimx] or [dimy] is negative or\n   greater than {!Sys.max_array_length}.\n   If the value of [e] is a floating-point number, then the maximum\n   size is only [Sys.max_array_length / 2]. "}
  }, {
    "label": "mem",
    "kind": 12,
    "tags": [],
    "detail": "('a, array<'a>) => bool",
    "documentation": {"kind": "markdown", "value": " [mem a l] is true if and only if [a] is equal\n   to an element of [l].\n   @since 4.03.0 "}
  }, {
    "label": "get",
    "kind": 12,
    "tags": [],
    "detail": "(array<'a>, int) => 'a",
    "documentation": {"kind": "markdown", "value": " [Array.get a n] returns the element number [n] of array [a].\n   The first element has number 0.\n   The last element has number [Array.length a - 1].\n   You can also write [a.(n)] instead of [Array.get a n].\n\n   Raise [Invalid_argument \"index out of bounds\"]\n   if [n] is outside the range 0 to [(Array.length a - 1)]. "}
  }, {
    "label": "append",
    "kind": 12,
    "tags": [],
    "detail": "(array<'a>, array<'a>) => array<'a>",
    "documentation": {"kind": "markdown", "value": " [Array.append v1 v2] returns a fresh array containing the\n   concatenation of the arrays [v1] and [v2]. "}
  }, {
    "label": "unsafe_set",
    "kind": 12,
    "tags": [],
    "detail": "(array<'a>, int, 'a) => unit",
    "documentation": null
  }, {
    "label": "create_matrix",
    "kind": 12,
    "tags": [],
    "detail": "(int, int, 'a) => array<array<'a>>",
    "documentation": {"kind": "markdown", "value": " @deprecated [Array.create_matrix] is an alias for {!Array.make_matrix}. "}
  }, {
    "label": "create_float",
    "kind": 12,
    "tags": [],
    "detail": "int => array<float>",
    "documentation": {"kind": "markdown", "value": " [Array.create_float n] returns a fresh float array of length [n],\n    with uninitialized data.\n    @since 4.03 "}
  }, {
    "label": "create",
    "kind": 12,
    "tags": [],
    "detail": "(int, 'a) => array<'a>",
    "documentation": {"kind": "markdown", "value": " @deprecated [Array.create] is an alias for {!Array.make}. "}
  }, {
    "label": "init",
    "kind": 12,
    "tags": [],
    "detail": "(int, int => 'a) => array<'a>",
    "documentation": {"kind": "markdown", "value": " [Array.init n f] returns a fresh array of length [n],\n   with element number [i] initialized to the result of [f i].\n   In other terms, [Array.init n f] tabulates the results of [f]\n   applied to the integers [0] to [n-1].\n\n   Raise [Invalid_argument] if [n < 0] or [n > Sys.max_array_length].\n   If the return type of [f] is [float], then the maximum\n   size is only [Sys.max_array_length / 2]."}
  }, {
    "label": "fast_sort",
    "kind": 12,
    "tags": [],
    "detail": "(('a, 'a) => int, array<'a>) => unit",
    "documentation": {"kind": "markdown", "value": " Same as {!Array.sort} or {!Array.stable_sort}, whichever is faster\n    on typical input.\n"}
  }, {
    "label": "fill",
    "kind": 12,
    "tags": [],
    "detail": "(array<'a>, int, int, 'a) => unit",
    "documentation": {"kind": "markdown", "value": " [Array.fill a ofs len x] modifies the array [a] in place,\n   storing [x] in elements number [ofs] to [ofs + len - 1].\n\n   Raise [Invalid_argument \"Array.fill\"] if [ofs] and [len] do not\n   designate a valid subarray of [a]. "}
  }, {
    "label": "blit",
    "kind": 12,
    "tags": [],
    "detail": "(array<'a>, int, array<'a>, int, int) => unit",
    "documentation": {"kind": "markdown", "value": " [Array.blit v1 o1 v2 o2 len] copies [len] elements\n   from array [v1], starting at element number [o1], to array [v2],\n   starting at element number [o2]. It works correctly even if\n   [v1] and [v2] are the same array, and the source and\n   destination chunks overlap.\n\n   Raise [Invalid_argument \"Array.blit\"] if [o1] and [len] do not\n   designate a valid subarray of [v1], or if [o2] and [len] do not\n   designate a valid subarray of [v2]. "}
  }, {
    "label": "Floatarray",
    "kind": 9,
    "tags": [],
    "detail": "module",
    "documentation": null
  }]

Complete src/Completion.res 5:10
posCursor:[5:10] posNoWhite:[5:9] Found expr:[5:3->5:10]
Pexp_ident Array.m:[5:3->5:10]
Completable: Cpath Value[Array, m]
[{
    "label": "mapi",
    "kind": 12,
    "tags": [],
    "detail": "((int, 'a) => 'b, array<'a>) => array<'b>",
    "documentation": {"kind": "markdown", "value": " Same as {!Array.map}, but the\n   function is applied to the index of the element as first argument,\n   and the element itself as second argument. "}
  }, {
    "label": "memq",
    "kind": 12,
    "tags": [],
    "detail": "('a, array<'a>) => bool",
    "documentation": {"kind": "markdown", "value": " Same as {!Array.mem}, but uses physical equality instead of structural\n   equality to compare array elements.\n   @since 4.03.0 "}
  }, {
    "label": "map2",
    "kind": 12,
    "tags": [],
    "detail": "(('a, 'b) => 'c, array<'a>, array<'b>) => array<'c>",
    "documentation": {"kind": "markdown", "value": " [Array.map2 f a b] applies function [f] to all the elements of [a]\n   and [b], and builds an array with the results returned by [f]:\n   [[| f a.(0) b.(0); ...; f a.(Array.length a - 1) b.(Array.length b - 1)|]].\n   Raise [Invalid_argument] if the arrays are not the same size.\n   @since 4.03.0 "}
  }, {
    "label": "make",
    "kind": 12,
    "tags": [],
    "detail": "(int, 'a) => array<'a>",
    "documentation": {"kind": "markdown", "value": " [Array.make n x] returns a fresh array of length [n],\n   initialized with [x].\n   All the elements of this new array are initially\n   physically equal to [x] (in the sense of the [==] predicate).\n   Consequently, if [x] is mutable, it is shared among all elements\n   of the array, and modifying [x] through one of the array entries\n   will modify all other entries at the same time.\n\n   Raise [Invalid_argument] if [n < 0] or [n > Sys.max_array_length].\n   If the value of [x] is a floating-point number, then the maximum\n   size is only [Sys.max_array_length / 2]."}
  }, {
    "label": "make_float",
    "kind": 12,
    "tags": [],
    "detail": "int => array<float>",
    "documentation": {"kind": "markdown", "value": " @deprecated [Array.make_float] is an alias for {!Array.create_float}. "}
  }, {
    "label": "map",
    "kind": 12,
    "tags": [],
    "detail": "('a => 'b, array<'a>) => array<'b>",
    "documentation": {"kind": "markdown", "value": " [Array.map f a] applies function [f] to all the elements of [a],\n   and builds an array with the results returned by [f]:\n   [[| f a.(0); f a.(1); ...; f a.(Array.length a - 1) |]]. "}
  }, {
    "label": "make_matrix",
    "kind": 12,
    "tags": [],
    "detail": "(int, int, 'a) => array<array<'a>>",
    "documentation": {"kind": "markdown", "value": " [Array.make_matrix dimx dimy e] returns a two-dimensional array\n   (an array of arrays) with first dimension [dimx] and\n   second dimension [dimy]. All the elements of this new matrix\n   are initially physically equal to [e].\n   The element ([x,y]) of a matrix [m] is accessed\n   with the notation [m.(x).(y)].\n\n   Raise [Invalid_argument] if [dimx] or [dimy] is negative or\n   greater than {!Sys.max_array_length}.\n   If the value of [e] is a floating-point number, then the maximum\n   size is only [Sys.max_array_length / 2]. "}
  }, {
    "label": "mem",
    "kind": 12,
    "tags": [],
    "detail": "('a, array<'a>) => bool",
    "documentation": {"kind": "markdown", "value": " [mem a l] is true if and only if [a] is equal\n   to an element of [l].\n   @since 4.03.0 "}
  }]

Complete src/Completion.res 15:17
posCursor:[15:17] posNoWhite:[15:16] Found expr:[15:12->15:17]
Pexp_ident Dep.c:[15:12->15:17]
Completable: Cpath Value[Dep, c]
[{
    "label": "customDouble",
    "kind": 12,
    "tags": [1],
    "detail": "int => int",
    "documentation": {"kind": "markdown", "value": "Deprecated: Use customDouble instead\n\nSome doc comment"}
  }]

Complete src/Completion.res 23:20
posCursor:[23:20] posNoWhite:[23:19] Found expr:[23:11->23:20]
Pexp_apply ...[23:11->23:18] ()
Completable: CnamedArg(Value[Lib, foo], "", [])
Found type for function (~age: int, ~name: string) => string
[{
    "label": "age",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }, {
    "label": "name",
    "kind": 4,
    "tags": [],
    "detail": "string",
    "documentation": null
  }]

Complete src/Completion.res 26:13
posCursor:[26:13] posNoWhite:[26:12] Found expr:[26:3->26:13]
Completable: Cpath array->m
[{
    "label": "Js.Array2.mapi",
    "kind": 12,
    "tags": [],
    "detail": "(t<'a>, ('a, int) => 'b) => t<'b>",
    "documentation": {"kind": "markdown", "value": "\nApplies the function (the second argument) to each item in the array, returning\na new array. The function acceps two arguments: an item from the array and its\nindex number. The result array does not have to have elements of the same type\nas the input array. See\n[`Array.map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\non MDN.\n\n```res example\n// multiply each item in array by its position\nlet product = (item, index) => item * index\nJs.Array2.mapi([10, 11, 12], product) == [0, 11, 24]\n```\n"}
  }, {
    "label": "Js.Array2.map",
    "kind": 12,
    "tags": [],
    "detail": "(t<'a>, 'a => 'b) => t<'b>",
    "documentation": {"kind": "markdown", "value": "\nApplies the function (the second argument) to each item in the array, returning\na new array. The result array does not have to have elements of the same type\nas the input array. See\n[`Array.map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\non MDN.\n\n```res example\nJs.Array2.map([12, 4, 8], x => x * x) == [144, 16, 64]\nJs.Array2.map([\"animal\", \"vegetable\", \"mineral\"], Js.String.length) == [6, 9, 7]\n```\n"}
  }]

Complete src/Completion.res 29:13
posCursor:[29:13] posNoWhite:[29:12] Found expr:[29:3->29:13]
Completable: Cpath string->toU
[{
    "label": "Js.String2.toUpperCase",
    "kind": 12,
    "tags": [],
    "detail": "t => t",
    "documentation": {"kind": "markdown", "value": "\n`toUpperCase(str)` converts `str` to upper case using the locale-insensitive\ncase mappings in the Unicode Character Database. Notice that the conversion can\nexpand the number of letters in the result; for example the German ß\ncapitalizes to two Ses in a row.\n\nSee [`String.toUpperCase`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase)\non MDN.\n\n```res example\nJs.String2.toUpperCase(\"abc\") == \"ABC\"\nJs.String2.toUpperCase(`Straße`) == `STRASSE`\nJs.String2.toUpperCase(`πς`) == `ΠΣ`\n```\n"}
  }]

Complete src/Completion.res 34:8
posCursor:[34:8] posNoWhite:[34:7] Found expr:[34:3->34:8]
Completable: Cpath Value[op]->e
[{
    "label": "Belt.Option.eqU",
    "kind": 12,
    "tags": [],
    "detail": "(option<'a>, option<'b>, (. 'a, 'b) => bool) => bool",
    "documentation": {"kind": "markdown", "value": "\n   Uncurried version of `eq`\n"}
  }, {
    "label": "Belt.Option.eq",
    "kind": 12,
    "tags": [],
    "detail": "(option<'a>, option<'b>, ('a, 'b) => bool) => bool",
    "documentation": {"kind": "markdown", "value": "\n   Evaluates two optional values for equality with respect to a predicate\n   function. If both `optValue1` and `optValue2` are `None`, returns `true`.\n   If one of the arguments is `Some(value)` and the other is `None`, returns\n   `false`.\n\n   If arguments are `Some(value1)` and `Some(value2)`, returns the result of\n   `predicate(value1, value2)`; the predicate function must return a bool.\n\n   ```res example\n   let clockEqual = (a, b) => mod(a, 12) == mod(b, 12)\n\n   open Belt.Option\n\n   eq(Some(3), Some(15), clockEqual) /* true */\n\n   eq(Some(3), None, clockEqual) /* false */\n\n   eq(None, Some(3), clockEqual) /* false */\n\n   eq(None, None, clockEqual) /* true */\n   ```\n"}
  }]

Complete src/Completion.res 44:7
posCursor:[44:7] posNoWhite:[44:6] Found expr:[44:3->54:3]
Pexp_apply ...[50:9->50:10] (...[44:3->50:8], ...[51:2->54:3])
posCursor:[44:7] posNoWhite:[44:6] Found expr:[44:3->50:8]
Completable: Cpath Value[fa]->
[{
    "label": "ForAuto.abc",
    "kind": 12,
    "tags": [],
    "detail": "(t, int) => t",
    "documentation": null
  }, {
    "label": "ForAuto.abd",
    "kind": 12,
    "tags": [],
    "detail": "(t, int) => t",
    "documentation": null
  }]

Complete src/Completion.res 47:21
posCursor:[47:21] posNoWhite:[47:20] Found expr:[47:3->47:21]
posCursor:[47:21] posNoWhite:[47:20] Found expr:[47:12->47:21]
Pexp_ident Js.Dict.u:[47:12->47:21]
Completable: Cpath Value[Js, Dict, u]
[{
    "label": "unsafeGet",
    "kind": 12,
    "tags": [],
    "detail": "(t<'a>, key) => 'a",
    "documentation": {"kind": "markdown", "value": "\n`Js.Dict.unsafeGet(key)` returns the value if the key exists, otherwise an `undefined` value is returned. Use this only when you are sure the key exists (i.e. when having used the `keys()` function to check that the key is valid).\n\n```res example\nJs.Dict.unsafeGet(ages, \"Fred\") == 49\nJs.Dict.unsafeGet(ages, \"Paul\") // returns undefined\n```\n"}
  }, {
    "label": "unsafeDeleteKey",
    "kind": 12,
    "tags": [],
    "detail": "(. t<string>, string) => unit",
    "documentation": {"kind": "markdown", "value": " Experimental internal function "}
  }]

Complete src/Completion.res 59:30
posCursor:[59:30] posNoWhite:[59:29] Found expr:[59:15->59:30]
JSX <O.Comp:[59:15->59:21] second[59:22->59:28]=...[59:29->59:30]> _children:None
Completable: CjsxPropValue [O, Comp] second=z
[{
    "label": "zzz",
    "kind": 12,
    "tags": [],
    "detail": "int",
    "documentation": null
  }]

Complete src/Completion.res 62:23
posCursor:[62:23] posNoWhite:[62:22] Found expr:[62:15->62:23]
JSX <O.Comp:[62:15->62:21] z[62:22->62:23]=...[62:22->62:23]> _children:None
Completable: Cjsx([O, Comp], z, [z])
[{
    "label": "zoo",
    "kind": 4,
    "tags": [],
    "detail": "option<int>",
    "documentation": null
  }]

Complete src/Completion.res 65:8
Attribute id:reac:[65:3->65:8] label:reac
Completable: Cdecorator(reac)
[{
    "label": "react.component",
    "kind": 4,
    "tags": [],
    "detail": "",
    "documentation": {"kind": "markdown", "value": "The `@react.component` decorator is used to annotate functions that are RescriptReact components.\n\nYou will need this decorator whenever you want to use a ReScript / React component in ReScript JSX expressions.\n\nNote: The `@react.component` decorator requires the react-jsx config to be set in your `bsconfig.json` to enable the required React transformations.\n\n[Read more and see examples in the documentation](https://rescript-lang.org/syntax-lookup#react-component-decorator)."}
  }]

Complete src/Completion.res 68:10
posCursor:[68:10] posNoWhite:[68:9] Found expr:[0:-1->86:1]
Pexp_apply ...[80:6->80:7] (...[80:8->86:1])
Attribute id:react.let:[68:3->80:3] label:react.
Completable: Cdecorator(react.)
[{
    "label": "component",
    "kind": 4,
    "tags": [],
    "detail": "",
    "documentation": {"kind": "markdown", "value": "The `@react.component` decorator is used to annotate functions that are RescriptReact components.\n\nYou will need this decorator whenever you want to use a ReScript / React component in ReScript JSX expressions.\n\nNote: The `@react.component` decorator requires the react-jsx config to be set in your `bsconfig.json` to enable the required React transformations.\n\n[Read more and see examples in the documentation](https://rescript-lang.org/syntax-lookup#react-component-decorator)."}
  }]

Complete src/Completion.res 71:27
posCursor:[71:27] posNoWhite:[71:26] Found expr:[71:11->71:27]
Pexp_apply ...[71:11->71:18] (~name71:20->71:24=...[71:20->71:24])
Completable: CnamedArg(Value[Lib, foo], "", [name])
Found type for function (~age: int, ~name: string) => string
[{
    "label": "age",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }]

Complete src/Completion.res 74:26
posCursor:[74:26] posNoWhite:[74:25] Found expr:[74:11->74:26]
Pexp_apply ...[74:11->74:18] (~age74:20->74:23=...[74:20->74:23])
Completable: CnamedArg(Value[Lib, foo], "", [age])
Found type for function (~age: int, ~name: string) => string
[{
    "label": "name",
    "kind": 4,
    "tags": [],
    "detail": "string",
    "documentation": null
  }]

Complete src/Completion.res 77:32
posCursor:[77:32] posNoWhite:[77:31] Found expr:[77:11->77:32]
Pexp_apply ...[77:11->77:18] (~age77:20->77:23=...[77:25->77:28])
Completable: CnamedArg(Value[Lib, foo], "", [age])
Found type for function (~age: int, ~name: string) => string
[{
    "label": "name",
    "kind": 4,
    "tags": [],
    "detail": "string",
    "documentation": null
  }]

Complete src/Completion.res 82:5
posCursor:[82:5] posNoWhite:[82:4] Found expr:[80:8->86:1]
Pexp_apply ...[80:8->80:15] (~age84:3->84:6=...[84:7->84:8], ~name85:3->85:7=...[85:8->85:10])
Completable: CnamedArg(Value[Lib, foo], "", [age, name])
Found type for function (~age: int, ~name: string) => string
[]

Complete src/Completion.res 90:13
posCursor:[90:13] posNoWhite:[90:12] Found expr:[90:3->93:18]
Pexp_send a[90:12->90:13] e:[90:3->90:10]
Completable: Cpath Value[someObj]["a"]
[{
    "label": "age",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }]

Complete src/Completion.res 95:24
posCursor:[95:24] posNoWhite:[95:23] Found expr:[95:3->99:6]
Pexp_send [95:24->95:24] e:[95:3->95:22]
Completable: Cpath Value[nestedObj]["x"]["y"][""]
[{
    "label": "age",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }, {
    "label": "name",
    "kind": 4,
    "tags": [],
    "detail": "string",
    "documentation": null
  }]

Complete src/Completion.res 99:7
posCursor:[99:7] posNoWhite:[99:6] Found expr:[99:3->102:20]
Pexp_send a[99:6->99:7] e:[99:3->99:4]
Completable: Cpath Value[o]["a"]
[{
    "label": "age",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }]

Complete src/Completion.res 104:17
posCursor:[104:17] posNoWhite:[104:16] Found expr:[104:3->125:18]
Pexp_send [104:17->104:17] e:[104:3->104:15]
Completable: Cpath Value[no]["x"]["y"][""]
[{
    "label": "name",
    "kind": 4,
    "tags": [],
    "detail": "string",
    "documentation": null
  }, {
    "label": "age",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }]

Complete src/Completion.res 110:5
posCursor:[110:5] posNoWhite:[110:4] Found expr:[110:3->110:5]
Pexp_field [110:3->110:4] _:[116:0->110:5]
Completable: Cpath Value[r].""
[{
    "label": "x",
    "kind": 5,
    "tags": [],
    "detail": "x: int\n\ntype r = {x: int, y: string}",
    "documentation": null
  }, {
    "label": "y",
    "kind": 5,
    "tags": [],
    "detail": "y: string\n\ntype r = {x: int, y: string}",
    "documentation": null
  }]

Complete src/Completion.res 113:24
posCursor:[113:24] posNoWhite:[113:23] Found expr:[113:3->113:24]
Pexp_field [113:3->113:23] _:[116:0->113:24]
Completable: Cpath Value[Object, Rec, recordVal].""
[{
    "label": "xx",
    "kind": 5,
    "tags": [],
    "detail": "xx: int\n\ntype recordt = {xx: int, ss: string}",
    "documentation": null
  }, {
    "label": "ss",
    "kind": 5,
    "tags": [],
    "detail": "ss: string\n\ntype recordt = {xx: int, ss: string}",
    "documentation": null
  }]

Complete src/Completion.res 120:7
posCursor:[120:7] posNoWhite:[120:6] Found expr:[119:11->123:1]
posCursor:[120:7] posNoWhite:[120:6] Found expr:[120:5->122:5]
posCursor:[120:7] posNoWhite:[120:6] Found expr:[120:5->120:7]
Pexp_ident my:[120:5->120:7]
Completable: Cpath Value[my]
[{
    "label": "myAmazingFunction",
    "kind": 12,
    "tags": [],
    "detail": "(int, int) => int",
    "documentation": null
  }]

Complete src/Completion.res 125:18
posCursor:[125:18] posNoWhite:[125:17] Found expr:[125:3->145:32]
Pexp_send [125:18->125:18] e:[125:3->125:16]
Completable: Cpath Value[Object, object][""]
[{
    "label": "name",
    "kind": 4,
    "tags": [],
    "detail": "string",
    "documentation": null
  }, {
    "label": "age",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }]

Complete src/Completion.res 151:6
posCursor:[151:6] posNoWhite:[151:5] Found expr:[151:4->151:6]
JSX <O.:[151:4->151:6] > _children:None
Completable: Cpath Module[O, ""]
[{
    "label": "Comp",
    "kind": 9,
    "tags": [],
    "detail": "module",
    "documentation": null
  }]

Complete src/Completion.res 157:8
posCursor:[157:8] posNoWhite:[157:7] Found expr:[157:3->157:8]
Pexp_field [157:3->157:7] _:[165:0->157:8]
Completable: Cpath Value[q].aa.""
[{
    "label": "x",
    "kind": 5,
    "tags": [],
    "detail": "x: int\n\ntype aa = {x: int, name: string}",
    "documentation": null
  }, {
    "label": "name",
    "kind": 5,
    "tags": [],
    "detail": "name: string\n\ntype aa = {x: int, name: string}",
    "documentation": null
  }]

Complete src/Completion.res 159:9
posCursor:[159:9] posNoWhite:[159:8] Found expr:[159:3->159:9]
Pexp_field [159:3->159:7] n:[159:8->159:9]
Completable: Cpath Value[q].aa.n
[{
    "label": "name",
    "kind": 5,
    "tags": [],
    "detail": "name: string\n\ntype aa = {x: int, name: string}",
    "documentation": null
  }]

Complete src/Completion.res 162:6
posCursor:[162:6] posNoWhite:[162:5] Found expr:[162:3->162:6]
Pexp_construct Lis:[162:3->162:6] None
Completable: Cpath Value[Lis]
[{
    "label": "List",
    "kind": 9,
    "tags": [],
    "detail": "file module",
    "documentation": null
  }, {
    "label": "ListLabels",
    "kind": 9,
    "tags": [],
    "detail": "file module",
    "documentation": null
  }]

Complete src/Completion.res 169:16
posCursor:[169:16] posNoWhite:[169:15] Found expr:[169:4->169:16]
JSX <WithChildren:[169:4->169:16] > _children:None
Completable: Cpath Module[WithChildren]
[{
    "label": "WithChildren",
    "kind": 9,
    "tags": [],
    "detail": "module",
    "documentation": null
  }]

Complete src/Completion.res 172:16
posCursor:[172:16] posNoWhite:[172:15] Found type:[172:12->172:16]
Ptyp_constr Js.n:[172:12->172:16]
Completable: Cpath Type[Js, n]
[{
    "label": "null_undefined",
    "kind": 22,
    "tags": [],
    "detail": "type null_undefined<'a> = nullable<'a>",
    "documentation": null
  }, {
    "label": "nullable",
    "kind": 22,
    "tags": [],
    "detail": "type nullable<+'a>",
    "documentation": {"kind": "markdown", "value": "\n  A value of this type can be undefined, null or 'a. This type is equivalent to Js.Null_undefined.t.\n"}
  }, {
    "label": "null",
    "kind": 22,
    "tags": [],
    "detail": "type null<+'a>",
    "documentation": {"kind": "markdown", "value": "\n  Nullable value of this type can be either null or 'a. This type is equivalent to Js.Null.t.\n"}
  }]

Complete src/Completion.res 174:20
posCursor:[174:20] posNoWhite:[174:19] Found type:[174:12->174:20]
Ptyp_constr ForAuto.:[174:12->174:20]
Completable: Cpath Type[ForAuto, ""]
[{
    "label": "t",
    "kind": 22,
    "tags": [],
    "detail": "type t = int",
    "documentation": null
  }]

Complete src/Completion.res 179:13
posCursor:[179:13] posNoWhite:[179:12] Found expr:[179:11->179:13]
Pexp_construct As:[179:11->179:13] None
Completable: Cpath Value[As]
[{
    "label": "Asterix",
    "kind": 4,
    "tags": [],
    "detail": "Asterix\n\ntype z = Allo | Asterix | Baba",
    "documentation": null
  }]

Complete src/Completion.res 182:17
Pmod_ident For:[182:14->182:17]
Completable: Cpath Module[For]
[{
    "label": "ForAuto",
    "kind": 9,
    "tags": [],
    "detail": "module",
    "documentation": null
  }]

Complete src/Completion.res 190:11
posCursor:[190:11] posNoWhite:[190:10] Found expr:[190:3->190:11]
Pexp_ident Private.:[190:3->190:11]
Completable: Cpath Value[Private, ""]
[{
    "label": "b",
    "kind": 12,
    "tags": [],
    "detail": "int",
    "documentation": null
  }]

Complete src/Completion.res 202:6
posCursor:[202:6] posNoWhite:[202:5] Found expr:[202:3->202:6]
Pexp_ident sha:[202:3->202:6]
Completable: Cpath Value[sha]
[]

Complete src/Completion.res 205:6
posCursor:[205:6] posNoWhite:[205:5] Found expr:[205:3->205:6]
Pexp_ident sha:[205:3->205:6]
Completable: Cpath Value[sha]
Raw opens: 1 Shadow.A.place holder
Resolved opens 1 Completion.res
[{
    "label": "shadowed",
    "kind": 12,
    "tags": [],
    "detail": "int",
    "documentation": null
  }]

Complete src/Completion.res 208:6
posCursor:[208:6] posNoWhite:[208:5] Found expr:[208:3->208:6]
Pexp_ident sha:[208:3->208:6]
Completable: Cpath Value[sha]
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "shadowed",
    "kind": 12,
    "tags": [],
    "detail": "string",
    "documentation": null
  }]

Complete src/Completion.res 221:22
posCursor:[221:22] posNoWhite:[221:21] Found expr:[221:3->224:22]
Pexp_send [221:22->221:22] e:[221:3->221:20]
Completable: Cpath Value[FAO, forAutoObject][""]
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "age",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }, {
    "label": "forAutoLabel",
    "kind": 4,
    "tags": [],
    "detail": "FAR.forAutoRecord",
    "documentation": null
  }]

Complete src/Completion.res 224:37
posCursor:[224:37] posNoWhite:[224:36] Found expr:[224:3->224:37]
Pexp_field [224:3->224:36] _:[233:0->224:37]
Completable: Cpath Value[FAO, forAutoObject]["forAutoLabel"].""
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "forAuto",
    "kind": 5,
    "tags": [],
    "detail": "forAuto: ForAuto.t\n\ntype forAutoRecord = {\n  forAuto: ForAuto.t,\n  something: option<int>,\n}",
    "documentation": null
  }, {
    "label": "something",
    "kind": 5,
    "tags": [],
    "detail": "something: option<int>\n\ntype forAutoRecord = {\n  forAuto: ForAuto.t,\n  something: option<int>,\n}",
    "documentation": null
  }]

Complete src/Completion.res 227:46
posCursor:[227:46] posNoWhite:[227:45] Found expr:[227:3->0:-1]
Completable: Cpath Value[FAO, forAutoObject]["forAutoLabel"].forAuto->
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "ForAuto.abc",
    "kind": 12,
    "tags": [],
    "detail": "(t, int) => t",
    "documentation": null
  }, {
    "label": "ForAuto.abd",
    "kind": 12,
    "tags": [],
    "detail": "(t, int) => t",
    "documentation": null
  }]

Complete src/Completion.res 230:55
posCursor:[230:55] posNoWhite:[230:54] Found expr:[230:3->230:55]
posCursor:[230:55] posNoWhite:[230:54] Found expr:[230:46->230:55]
Pexp_ident ForAuto.a:[230:46->230:55]
Completable: Cpath Value[ForAuto, a]
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "abc",
    "kind": 12,
    "tags": [],
    "detail": "(t, int) => t",
    "documentation": null
  }, {
    "label": "abd",
    "kind": 12,
    "tags": [],
    "detail": "(t, int) => t",
    "documentation": null
  }]

Complete src/Completion.res 234:34
posCursor:[234:34] posNoWhite:[234:33] Found expr:[234:18->234:36]
Pexp_apply ...__ghost__[0:-1->0:-1] (...[234:18->234:34], ...[234:34->234:35])
posCursor:[234:34] posNoWhite:[234:33] Found expr:[234:18->234:34]
Pexp_apply ...__ghost__[0:-1->0:-1] (...[234:18->234:30], ...[234:32->234:34])
posCursor:[234:34] posNoWhite:[234:33] Found expr:[234:32->234:34]
Pexp_ident na:[234:32->234:34]
Completable: Cpath Value[na]
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "name",
    "kind": 12,
    "tags": [],
    "detail": "string",
    "documentation": null
  }]

Complete src/Completion.res 237:17
posCursor:[237:17] posNoWhite:[237:14] Found expr:[237:14->237:22]
Completable: Cnone
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[]

Complete src/Completion.res 243:8
posCursor:[243:8] posNoWhite:[243:7] Found expr:[241:8->246:1]
posCursor:[243:8] posNoWhite:[243:7] Found expr:[242:14->243:8]
Pexp_apply ...[243:3->243:4] (...[242:14->242:15], ...[243:5->243:8])
posCursor:[243:8] posNoWhite:[243:7] Found expr:[243:5->243:8]
Pexp_field [243:5->243:7] _:[245:0->243:8]
Completable: Cpath Value[_z].""
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "x",
    "kind": 5,
    "tags": [],
    "detail": "x: int\n\ntype r = {x: int, y: string}",
    "documentation": null
  }, {
    "label": "y",
    "kind": 5,
    "tags": [],
    "detail": "y: string\n\ntype r = {x: int, y: string}",
    "documentation": null
  }]

Complete src/Completion.res 254:17
posCursor:[254:17] posNoWhite:[254:16] Found expr:[254:11->254:17]
Pexp_construct SomeLo:[254:11->254:17] None
Completable: Cpath Value[SomeLo]
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "SomeLocalModule",
    "kind": 9,
    "tags": [],
    "detail": "module",
    "documentation": null
  }]

Complete src/Completion.res 256:29
posCursor:[256:29] posNoWhite:[256:28] Found type:[256:13->256:29]
Ptyp_constr SomeLocalModule.:[256:13->256:29]
Completable: Cpath Type[SomeLocalModule, ""]
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "zz",
    "kind": 22,
    "tags": [],
    "detail": "type zz = int",
    "documentation": null
  }]

Complete src/Completion.res 261:33
posCursor:[261:33] posNoWhite:[261:32] Found type:[261:17->263:11]
Ptyp_constr SomeLocalModule.:[261:17->263:11]
Completable: Cpath Type[SomeLocalModule, ""]
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "zz",
    "kind": 22,
    "tags": [],
    "detail": "type zz = int",
    "documentation": null
  }]

Complete src/Completion.res 268:21
Ptype_variant unary SomeLocal:[268:12->268:21]
Completable: Cpath Value[SomeLocal]
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "SomeLocalVariantItem",
    "kind": 4,
    "tags": [],
    "detail": "SomeLocalVariantItem\n\ntype someLocalVariant = SomeLocalVariantItem",
    "documentation": null
  }, {
    "label": "SomeLocalModule",
    "kind": 9,
    "tags": [],
    "detail": "module",
    "documentation": null
  }]

Complete src/Completion.res 271:20
posCursor:[271:20] posNoWhite:[271:19] Found pattern:[271:7->274:3]
posCursor:[271:20] posNoWhite:[271:19] Found type:[271:11->274:3]
Ptyp_constr SomeLocal:[271:11->274:3]
Completable: Cpath Type[SomeLocal]
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "SomeLocalModule",
    "kind": 9,
    "tags": [],
    "detail": "module",
    "documentation": null
  }]

Complete src/Completion.res 275:15
posCursor:[275:15] posNoWhite:[275:14] Found expr:[274:11->278:1]
posCursor:[275:15] posNoWhite:[275:14] Found expr:[275:5->277:3]
posCursor:[275:15] posNoWhite:[275:14] Found expr:[275:13->275:15]
Pexp_ident _w:[275:13->275:15]
Completable: Cpath Value[_w]
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "_world",
    "kind": 12,
    "tags": [],
    "detail": "'a",
    "documentation": null
  }]

Complete src/Completion.res 281:22
posCursor:[281:22] posNoWhite:[281:21] Found type:[281:21->281:22]
Ptyp_constr s:[281:21->281:22]
Completable: Cpath Type[s]
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "someType",
    "kind": 22,
    "tags": [],
    "detail": "type someType = {hello: string}",
    "documentation": null
  }, {
    "label": "someLocalVariant",
    "kind": 22,
    "tags": [],
    "detail": "type someLocalVariant = SomeLocalVariantItem",
    "documentation": null
  }]

Complete src/Completion.res 291:30
posCursor:[291:30] posNoWhite:[291:29] Found expr:[291:11->291:32]
Pexp_apply ...[291:11->291:28] ()
Completable: CnamedArg(Value[funRecord].someFun, "", [])
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
Found type for function (~name: string) => unit
[{
    "label": "name",
    "kind": 4,
    "tags": [],
    "detail": "string",
    "documentation": null
  }]

Complete src/Completion.res 296:11
posCursor:[296:11] posNoWhite:[296:10] Found expr:[296:3->296:11]
Pexp_field [296:3->296:10] _:[299:0->296:11]
Completable: Cpath Value[retAA](Nolabel).""
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "x",
    "kind": 5,
    "tags": [],
    "detail": "x: int\n\ntype aa = {x: int, name: string}",
    "documentation": null
  }, {
    "label": "name",
    "kind": 5,
    "tags": [],
    "detail": "name: string\n\ntype aa = {x: int, name: string}",
    "documentation": null
  }]

Complete src/Completion.res 301:13
posCursor:[301:13] posNoWhite:[301:12] Found expr:[301:3->301:13]
Pexp_apply ...[301:3->301:11] ()
Completable: CnamedArg(Value[ff](~c), "", [])
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
Found type for function (
  ~opt1: int=?,
  ~a: int,
  ~b: int,
  unit,
  ~opt2: int=?,
  unit,
) => int
[{
    "label": "opt1",
    "kind": 4,
    "tags": [],
    "detail": "option<int>",
    "documentation": null
  }, {
    "label": "a",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }, {
    "label": "b",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }, {
    "label": "opt2",
    "kind": 4,
    "tags": [],
    "detail": "option<int>",
    "documentation": null
  }]

Complete src/Completion.res 304:15
posCursor:[304:15] posNoWhite:[304:14] Found expr:[304:3->304:15]
Pexp_apply ...[304:3->304:13] ()
Completable: CnamedArg(Value[ff](~c)(Nolabel), "", [])
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
Found type for function (~a: int, ~b: int, ~opt2: int=?, unit) => int
[{
    "label": "a",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }, {
    "label": "b",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }, {
    "label": "opt2",
    "kind": 4,
    "tags": [],
    "detail": "option<int>",
    "documentation": null
  }]

Complete src/Completion.res 307:17
posCursor:[307:17] posNoWhite:[307:16] Found expr:[307:3->307:17]
Pexp_apply ...[307:3->307:15] ()
Completable: CnamedArg(Value[ff](~c, Nolabel), "", [])
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
Found type for function (~a: int, ~b: int, ~opt2: int=?, unit) => int
[{
    "label": "a",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }, {
    "label": "b",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }, {
    "label": "opt2",
    "kind": 4,
    "tags": [],
    "detail": "option<int>",
    "documentation": null
  }]

Complete src/Completion.res 310:21
posCursor:[310:21] posNoWhite:[310:20] Found expr:[310:3->310:21]
Pexp_apply ...[310:3->310:19] ()
Completable: CnamedArg(Value[ff](~c, Nolabel, Nolabel), "", [])
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
Found type for function (~a: int, ~b: int) => int
[{
    "label": "a",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }, {
    "label": "b",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }]

Complete src/Completion.res 313:23
posCursor:[313:23] posNoWhite:[313:22] Found expr:[313:3->313:23]
Pexp_apply ...[313:3->313:21] ()
Completable: CnamedArg(Value[ff](~c, Nolabel, ~b), "", [])
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
Found type for function (~a: int, ~opt2: int=?, unit) => int
[{
    "label": "a",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }, {
    "label": "opt2",
    "kind": 4,
    "tags": [],
    "detail": "option<int>",
    "documentation": null
  }]

Complete src/Completion.res 316:16
posCursor:[316:16] posNoWhite:[316:15] Found expr:[316:3->316:16]
Pexp_apply ...[316:3->316:14] ()
Completable: CnamedArg(Value[ff](~opt2), "", [])
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
Found type for function (~opt1: int=?, ~a: int, ~b: int, unit, unit, ~c: int) => int
[{
    "label": "opt1",
    "kind": 4,
    "tags": [],
    "detail": "option<int>",
    "documentation": null
  }, {
    "label": "a",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }, {
    "label": "b",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }, {
    "label": "c",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }]

Complete src/Completion.res 323:17
posCursor:[323:17] posNoWhite:[323:16] Found expr:[323:3->323:17]
Pexp_apply ...[323:3->323:15] ()
Completable: CnamedArg(Value[withCallback], "", [])
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
Found type for function (~b: int) => callback
[{
    "label": "b",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }, {
    "label": "a",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }]

Complete src/Completion.res 326:21
posCursor:[326:21] posNoWhite:[326:20] Found expr:[326:3->326:21]
Pexp_apply ...[326:3->326:19] ()
Completable: CnamedArg(Value[withCallback](~a), "", [])
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
Found type for function (~b: int) => int
[{
    "label": "b",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }]

Complete src/Completion.res 329:21
posCursor:[329:21] posNoWhite:[329:20] Found expr:[329:3->329:21]
Pexp_apply ...[329:3->329:19] ()
Completable: CnamedArg(Value[withCallback](~b), "", [])
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
Found type for function (~a: int) => int
[{
    "label": "a",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }]

Complete src/Completion.res 336:26
posCursor:[336:26] posNoWhite:[336:25] Found expr:[333:3->346:23]
JSX <div:[333:3->333:6] onClick[334:4->334:11]=...[334:13->346:23]> _children:None
posCursor:[336:26] posNoWhite:[336:25] Found expr:[334:13->346:23]
posCursor:[336:26] posNoWhite:[336:25] Found expr:[334:13->338:6]
posCursor:[336:26] posNoWhite:[336:25] Found expr:[335:6->338:5]
posCursor:[336:26] posNoWhite:[336:25] Found expr:[336:16->338:5]
posCursor:[336:26] posNoWhite:[336:25] Found pattern:[336:20->338:5]
posCursor:[336:26] posNoWhite:[336:25] Found type:[336:23->338:5]
Ptyp_constr Res:[336:23->338:5]
Completable: Cpath Type[Res]
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "RescriptReactErrorBoundary",
    "kind": 9,
    "tags": [],
    "detail": "file module",
    "documentation": null
  }, {
    "label": "RescriptReactRouter",
    "kind": 9,
    "tags": [],
    "detail": "file module",
    "documentation": null
  }]

Complete src/Completion.res 343:57
posCursor:[343:57] posNoWhite:[343:56] Found expr:[343:10->346:23]
posCursor:[343:57] posNoWhite:[343:56] Found expr:[343:53->346:23]
posCursor:[343:57] posNoWhite:[343:56] Found expr:[343:53->343:57]
Pexp_ident this:[343:53->343:57]
Completable: Cpath Value[this]
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "thisIsNotSaved",
    "kind": 12,
    "tags": [],
    "detail": "\\\"Type Not Known\"",
    "documentation": null
  }]

Hover src/Completion.res 346:14
Nothing at that position. Now trying to use completion.
posCursor:[346:14] posNoWhite:[346:13] Found expr:[346:9->346:23]
JSX <div:[346:9->346:12] name[346:13->346:17]=...[346:18->346:20]> _children:346:21
Completable: Cjsx([div], name, [name])
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
{"contents": {"kind": "markdown", "value": "```rescript\nstring\n```"}}

Hover src/Completion.res 349:17
Nothing at that position. Now trying to use completion.
posCursor:[349:17] posNoWhite:[349:16] Found expr:[349:11->349:35]
Pexp_send age[349:30->349:33] e:[349:11->349:28]
posCursor:[349:17] posNoWhite:[349:16] Found expr:[349:11->349:28]
Pexp_ident FAO.forAutoObject:[349:11->349:28]
Completable: Cpath Value[FAO, forAutoObject]
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
{"contents": {"kind": "markdown", "value": "```rescript\n{\"age\": int, \"forAutoLabel\": FAR.forAutoRecord}\n```"}}

Hover src/Completion.res 352:17
Nothing at that position. Now trying to use completion.
posCursor:[352:17] posNoWhite:[352:16] Found expr:[352:11->352:22]
Pexp_apply ...[352:11->352:13] (~opt1352:15->352:19=...[352:20->352:21])
Completable: CnamedArg(Value[ff], opt1, [opt1])
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
Found type for function (
  ~opt1: int=?,
  ~a: int,
  ~b: int,
  unit,
  ~opt2: int=?,
  unit,
  ~c: int,
) => int
{"contents": {"kind": "markdown", "value": "```rescript\noption<int>\n```"}}

Complete src/Completion.res 355:23
posCursor:[355:23] posNoWhite:[355:22] Found expr:[0:-1->355:23]
posCursor:[355:23] posNoWhite:[355:22] Found expr:[355:12->355:23]
[]

Complete src/Completion.res 362:8
posCursor:[362:8] posNoWhite:[362:7] Found expr:[360:8->365:3]
posCursor:[362:8] posNoWhite:[362:7] Found expr:[361:2->365:3]
posCursor:[362:8] posNoWhite:[362:7] Found pattern:[362:7->364:5]
posCursor:[362:8] posNoWhite:[362:7] Found pattern:[362:7->362:8]
Ppat_construct T:[362:7->362:8]
Completable: Cpath Value[T]
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "That",
    "kind": 4,
    "tags": [],
    "detail": "That\n\ntype v = This | That",
    "documentation": null
  }, {
    "label": "This",
    "kind": 4,
    "tags": [],
    "detail": "This\n\ntype v = This | That",
    "documentation": null
  }, {
    "label": "TableclothMap",
    "kind": 9,
    "tags": [],
    "detail": "file module",
    "documentation": null
  }, {
    "label": "TypeDefinition",
    "kind": 9,
    "tags": [],
    "detail": "file module",
    "documentation": null
  }]

Complete src/Completion.res 373:21
posCursor:[373:21] posNoWhite:[373:20] Found expr:[371:8->376:3]
posCursor:[373:21] posNoWhite:[373:20] Found expr:[372:2->376:3]
posCursor:[373:21] posNoWhite:[373:20] Found pattern:[373:7->375:5]
posCursor:[373:21] posNoWhite:[373:20] Found pattern:[373:7->373:21]
Ppat_construct AndThatOther.T:[373:7->373:21]
Completable: Cpath Value[AndThatOther, T]
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "ThatOther",
    "kind": 4,
    "tags": [],
    "detail": "ThatOther\n\ntype v = And | ThatOther",
    "documentation": null
  }]

Complete src/Completion.res 378:24
posCursor:[378:24] posNoWhite:[378:23] Found expr:[378:12->378:26]
Pexp_apply ...__ghost__[0:-1->0:-1] (...[378:12->378:24], ...[378:24->378:25])
posCursor:[378:24] posNoWhite:[378:23] Found expr:[378:12->378:24]
Pexp_apply ...__ghost__[0:-1->0:-1] (...[378:12->378:14], ...[378:16->378:24])
posCursor:[378:24] posNoWhite:[378:23] Found expr:[378:16->378:24]
Pexp_ident ForAuto.:[378:16->378:24]
Completable: Cpath Value[ForAuto, ""]
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "abc",
    "kind": 12,
    "tags": [],
    "detail": "(t, int) => t",
    "documentation": null
  }, {
    "label": "abd",
    "kind": 12,
    "tags": [],
    "detail": "(t, int) => t",
    "documentation": null
  }]

Complete src/Completion.res 381:38
posCursor:[381:38] posNoWhite:[381:37] Found expr:[381:12->381:41]
Pexp_apply ...__ghost__[0:-1->0:-1] (...[381:12->381:39], ...[381:39->381:40])
posCursor:[381:38] posNoWhite:[381:37] Found expr:[381:12->381:39]
Pexp_apply ...__ghost__[0:-1->0:-1] (...[381:12->381:17], ...[381:19->381:39])
posCursor:[381:38] posNoWhite:[381:37] Found expr:[381:19->381:39]
Pexp_send [381:38->381:38] e:[381:19->381:36]
Completable: Cpath Value[FAO, forAutoObject][""]
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "age",
    "kind": 4,
    "tags": [],
    "detail": "int",
    "documentation": null
  }, {
    "label": "forAutoLabel",
    "kind": 4,
    "tags": [],
    "detail": "FAR.forAutoRecord",
    "documentation": null
  }]

Complete src/Completion.res 384:24
posCursor:[384:24] posNoWhite:[384:23] Found expr:[384:11->384:26]
Pexp_apply ...__ghost__[0:-1->0:-1] (...[384:11->384:24], ...[384:24->384:25])
posCursor:[384:24] posNoWhite:[384:23] Found expr:[384:11->384:24]
Pexp_apply ...__ghost__[0:-1->0:-1] (...[384:11->384:12], ...[384:14->384:24])
posCursor:[384:24] posNoWhite:[384:23] Found expr:[384:14->384:24]
Pexp_field [384:14->384:23] _:[384:24->384:24]
Completable: Cpath Value[funRecord].""
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "someFun",
    "kind": 5,
    "tags": [],
    "detail": "someFun: (~name: string) => unit\n\ntype funRecord = {\n  someFun: (~name: string) => unit,\n  stuff: string,\n}",
    "documentation": null
  }, {
    "label": "stuff",
    "kind": 5,
    "tags": [],
    "detail": "stuff: string\n\ntype funRecord = {\n  someFun: (~name: string) => unit,\n  stuff: string,\n}",
    "documentation": null
  }]

Complete src/Completion.res 389:12
posCursor:[389:12] posNoWhite:[389:11] Found expr:[387:8->392:1]
posCursor:[389:12] posNoWhite:[389:11] Found expr:[388:2->391:4]
posCursor:[389:12] posNoWhite:[389:11] Found expr:[389:6->391:4]
posCursor:[389:12] posNoWhite:[389:11] Found expr:[389:6->389:12]
Completable: Cpath array->ma
Raw opens: 3 Js.place holder ... Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 3 Completion.res Completion.res js.ml
[{
    "label": "Array2.mapi",
    "kind": 12,
    "tags": [],
    "detail": "(t<'a>, ('a, int) => 'b) => t<'b>",
    "documentation": {"kind": "markdown", "value": "\nApplies the function (the second argument) to each item in the array, returning\na new array. The function acceps two arguments: an item from the array and its\nindex number. The result array does not have to have elements of the same type\nas the input array. See\n[`Array.map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\non MDN.\n\n```res example\n// multiply each item in array by its position\nlet product = (item, index) => item * index\nJs.Array2.mapi([10, 11, 12], product) == [0, 11, 24]\n```\n"}
  }, {
    "label": "Array2.map",
    "kind": 12,
    "tags": [],
    "detail": "(t<'a>, 'a => 'b) => t<'b>",
    "documentation": {"kind": "markdown", "value": "\nApplies the function (the second argument) to each item in the array, returning\na new array. The result array does not have to have elements of the same type\nas the input array. See\n[`Array.map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\non MDN.\n\n```res example\nJs.Array2.map([12, 4, 8], x => x * x) == [144, 16, 64]\nJs.Array2.map([\"animal\", \"vegetable\", \"mineral\"], Js.String.length) == [6, 9, 7]\n```\n"}
  }]

Complete src/Completion.res 397:14
posCursor:[397:14] posNoWhite:[397:13] Found expr:[396:14->397:20]
Pexp_apply ...__ghost__[0:-1->0:-1] (...[396:14->397:16], ...[397:16->397:19])
posCursor:[397:14] posNoWhite:[397:13] Found expr:[396:14->397:16]
Pexp_apply ...__ghost__[0:-1->0:-1] (...[396:14->397:11], ...[397:13->397:16])
posCursor:[397:14] posNoWhite:[397:13] Found expr:[397:13->397:16]
Pexp_ident red:[397:13->397:16]
Completable: Cpath Value[red]
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "red",
    "kind": 12,
    "tags": [],
    "detail": "string",
    "documentation": null
  }]

Complete src/Completion.res 402:25
posCursor:[402:25] posNoWhite:[402:24] Found expr:[400:14->402:31]
Pexp_apply ...__ghost__[0:-1->0:-1] (...[400:14->402:27], ...[402:27->402:30])
posCursor:[402:25] posNoWhite:[402:24] Found expr:[400:14->402:27]
Pexp_apply ...__ghost__[0:-1->0:-1] (...[400:14->402:22], ...[402:24->402:27])
posCursor:[402:25] posNoWhite:[402:24] Found expr:[402:24->402:27]
Pexp_ident red:[402:24->402:27]
Completable: Cpath Value[red]
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "red",
    "kind": 12,
    "tags": [],
    "detail": "string",
    "documentation": null
  }]

Complete src/Completion.res 405:22
posCursor:[405:22] posNoWhite:[405:21] Found expr:[405:11->428:0]
Pexp_apply ...__ghost__[0:-1->0:-1] (...[405:11->423:17], ...[428:0->428:0])
posCursor:[405:22] posNoWhite:[405:21] Found expr:[405:11->423:17]
Pexp_apply ...__ghost__[0:-1->0:-1] (...[405:11->405:19], ...[405:21->423:17])
posCursor:[405:22] posNoWhite:[405:21] Found expr:[405:21->423:17]
posCursor:[405:22] posNoWhite:[405:21] Found expr:[405:21->405:22]
Pexp_ident r:[405:21->405:22]
Completable: Cpath Value[r]
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "red",
    "kind": 12,
    "tags": [],
    "detail": "string",
    "documentation": null
  }, {
    "label": "retAA",
    "kind": 12,
    "tags": [],
    "detail": "unit => aa",
    "documentation": null
  }, {
    "label": "r",
    "kind": 12,
    "tags": [],
    "detail": "rAlias",
    "documentation": null
  }]

Complete src/Completion.res 409:21
posCursor:[409:21] posNoWhite:[409:20] Found expr:[408:14->415:1]
posCursor:[409:21] posNoWhite:[409:20] Found expr:[409:5->414:17]
posCursor:[409:21] posNoWhite:[409:20] Found expr:[409:5->411:42]
posCursor:[409:21] posNoWhite:[409:20] Found expr:[409:5->411:5]
Pexp_ident SomeLocalModule.:[409:5->411:5]
Completable: Cpath Value[SomeLocalModule, ""]
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "bb",
    "kind": 12,
    "tags": [],
    "detail": "int",
    "documentation": null
  }, {
    "label": "aa",
    "kind": 12,
    "tags": [],
    "detail": "int",
    "documentation": null
  }]

Complete src/Completion.res 412:21
posCursor:[412:21] posNoWhite:[412:20] Found expr:[408:14->415:1]
posCursor:[412:21] posNoWhite:[412:20] Found expr:[411:2->414:17]
posCursor:[412:21] posNoWhite:[412:20] Found expr:[412:5->414:17]
Pexp_apply ...[412:5->414:8] (...[414:9->414:16])
posCursor:[412:21] posNoWhite:[412:20] Found expr:[412:5->414:8]
Pexp_ident SomeLocalModule.:[412:5->414:8]
Completable: Cpath Value[SomeLocalModule, ""]
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "bb",
    "kind": 12,
    "tags": [],
    "detail": "int",
    "documentation": null
  }, {
    "label": "aa",
    "kind": 12,
    "tags": [],
    "detail": "int",
    "documentation": null
  }]

Complete src/Completion.res 417:17
posCursor:[417:17] posNoWhite:[417:16] Found expr:[417:11->417:17]
Completable: Cpath int->t
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "Belt.Int.toString",
    "kind": 12,
    "tags": [],
    "detail": "int => string",
    "documentation": {"kind": "markdown", "value": "\n  Converts a given `int` to a `string`. Uses the JavaScript `String` constructor under the hood.\n\n  ```res example\n  Js.log(Belt.Int.toString(1) === \"1\") /* true */\n  ```\n"}
  }, {
    "label": "Belt.Int.toFloat",
    "kind": 12,
    "tags": [],
    "detail": "int => float",
    "documentation": {"kind": "markdown", "value": "\n  Converts a given `int` to a `float`.\n\n  ```res example\n  Js.log(Belt.Int.toFloat(1) === 1.0) /* true */\n  ```\n"}
  }]

Complete src/Completion.res 420:19
posCursor:[420:19] posNoWhite:[420:18] Found expr:[420:11->420:19]
Completable: Cpath float->t
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "Belt.Float.toInt",
    "kind": 12,
    "tags": [],
    "detail": "float => int",
    "documentation": {"kind": "markdown", "value": "\nConverts a given `float` to an `int`.\n\n```res example\nJs.log(Belt.Float.toInt(1.0) === 1) /* true */\n```\n"}
  }, {
    "label": "Belt.Float.toString",
    "kind": 12,
    "tags": [],
    "detail": "float => string",
    "documentation": {"kind": "markdown", "value": "\n  Converts a given `float` to a `string`. Uses the JavaScript `String` constructor under the hood.\n\n  ```res example\n  Js.log(Belt.Float.toString(1.0) === \"1.0\") /* true */\n  ```\n"}
  }]

Complete src/Completion.res 425:7
posCursor:[425:7] posNoWhite:[425:6] Found expr:[425:3->0:-1]
Completable: Cpath Value[ok]->
Raw opens: 2 Shadow.B.place holder ... Shadow.A.place holder
Resolved opens 2 Completion.res Completion.res
[{
    "label": "Pervasives.neg_infinity",
    "kind": 12,
    "tags": [],
    "detail": "float",
    "documentation": {"kind": "markdown", "value": " Negative infinity. "}
  }, {
    "label": "Pervasives.print_newline",
    "kind": 12,
    "tags": [],
    "detail": "unit => unit",
    "documentation": {"kind": "markdown", "value": " Print a newline character on standard output, and flush\n   standard output. This can be used to simulate line\n   buffering of standard output. "}
  }, {
    "label": "Pervasives.lor",
    "kind": 12,
    "tags": [],
    "detail": "(int, int) => int",
    "documentation": {"kind": "markdown", "value": " Bitwise logical or.\n    Left-associative operator at precedence level 7/11. "}
  }, {
    "label": "Pervasives.float_of_int",
    "kind": 12,
    "tags": [],
    "detail": "int => float",
    "documentation": {"kind": "markdown", "value": " Convert an integer to floating-point. "}
  }, {
    "label": "Pervasives.:=",
    "kind": 12,
    "tags": [],
    "detail": "(ref<'a>, 'a) => unit",
    "documentation": {"kind": "markdown", "value": " [r := a] stores the value of [a] in reference [r].\n   Equivalent to [fun r v -> r.contents <- v].\n   Right-associative operator at precedence level 1/11. "}
  }, {
    "label": "Pervasives.<>",
    "kind": 12,
    "tags": [],
    "detail": "('a, 'a) => bool",
    "documentation": {"kind": "markdown", "value": " Negation of {!Pervasives.( = )}.\n    Left-associative operator at precedence level 4/11. "}
  }, {
    "label": "Pervasives.atan2",
    "kind": 12,
    "tags": [],
    "detail": "(float, float) => float",
    "documentation": {"kind": "markdown", "value": " [atan2 y x] returns the arc tangent of [y /. x].  The signs of [x]\n    and [y] are used to determine the quadrant of the result.\n    Result is in radians and is between [-pi] and [pi]. "}
  }, {
    "label": "Pervasives.mod_float",
    "kind": 12,
    "tags": [],
    "detail": "(float, float) => float",
    "documentation": {"kind": "markdown", "value": " [mod_float a b] returns the remainder of [a] with respect to\n   [b].  The returned value is [a -. n *. b], where [n]\n   is the quotient [a /. b] rounded towards zero to an integer. "}
  }, {
    "label": "Pervasives.*",
    "kind": 12,
    "tags": [],
    "detail": "(int, int) => int",
    "documentation": {"kind": "markdown", "value": " Integer multiplication.\n    Left-associative operator at precedence level 7/11. "}
  }, {
    "label": "Pervasives.abs_float",
    "kind": 12,
    "tags": [],
    "detail": "float => float",
    "documentation": {"kind": "markdown", "value": " [abs_float f] returns the absolute value of [f]. "}
  }, {
    "label": "Pervasives.char_of_int",
    "kind": 12,
    "tags": [],
    "detail": "int => char",
    "documentation": {"kind": "markdown", "value": " Return the character with the given ASCII code.\n   Raise [Invalid_argument \"char_of_int\"] if the argument is\n   outside the range 0--255. "}
  }, {
    "label": "Pervasives.lsr",
    "kind": 12,
    "tags": [],
    "detail": "(int, int) => int",
    "documentation": {"kind": "markdown", "value": " [n lsr m] shifts [n] to the right by [m] bits.\n   This is a logical shift: zeroes are inserted regardless of\n   the sign of [n].\n   The result is unspecified if [m < 0] or [m >= bitsize].\n   Right-associative operator at precedence level 8/11. "}
  }, {
    "label": "Pervasives.<",
    "kind": 12,
    "tags": [],
    "detail": "('a, 'a) => bool",
    "documentation": {"kind": "markdown", "value": " See {!Pervasives.( >= )}.\n    Left-associative operator at precedence level 4/11. "}
  }, {
    "label": "Pervasives./.",
    "kind": 12,
    "tags": [],
    "detail": "(float, float) => float",
    "documentation": {"kind": "markdown", "value": " Floating-point division.\n    Left-associative operator at precedence level 7/11. "}
  }, {
    "label": "Pervasives.sin",
    "kind": 12,
    "tags": [],
    "detail": "float => float",
    "documentation": {"kind": "markdown", "value": " Sine.  Argument is in radians. "}
  }, {
    "label": "Pervasives.ceil",
    "kind": 12,
    "tags": [],
    "detail": "float => float",
    "documentation": {"kind": "markdown", "value": " Round above to an integer value.\n    [ceil f] returns the least integer value greater than or equal to [f].\n    The result is returned as a float. "}
  }, {
    "label": "Pervasives.__LOC__",
    "kind": 12,
    "tags": [],
    "detail": "string",
    "documentation": {"kind": "markdown", "value": " [__LOC__] returns the location at which this expression appears in\n    the file currently being parsed by the compiler, with the standard\n    error format of OCaml: \"File %S, line %d, characters %d-%d\".\n    @since 4.02.0\n"}
  }, {
    "label": "Pervasives.asr",
    "kind": 12,
    "tags": [],
    "detail": "(int, int) => int",
    "documentation": {"kind": "markdown", "value": " [n asr m] shifts [n] to the right by [m] bits.\n   This is an arithmetic shift: the sign bit of [n] is replicated.\n   The result is unspecified if [m < 0] or [m >= bitsize].\n   Right-associative operator at precedence level 8/11. "}
  }, {
    "label": "Pervasives.==",
    "kind": 12,
    "tags": [],
    "detail": "('a, 'a) => bool",
    "documentation": {"kind": "markdown", "value": " [e1 == e2] tests for physical equality of [e1] and [e2].\n   On mutable types such as references, arrays, byte sequences, records with\n   mutable fields and objects with mutable instance variables,\n   [e1 == e2] is true if and only if physical modification of [e1]\n   also affects [e2].\n   On non-mutable types, the behavior of [( == )] is\n   implementation-dependent; however, it is guaranteed that\n   [e1 == e2] implies [compare e1 e2 = 0].\n   Left-associative operator at precedence level 4/11. "}
  }, {
    "label": "Pervasives.not",
    "kind": 12,
    "tags": [],
    "detail": "bool => bool",
    "documentation": {"kind": "markdown", "value": " The boolean negation. "}
  }, {
    "label": "Pervasives.|>",
    "kind": 12,
    "tags": [],
    "detail": "('a, 'a => 'b) => 'b",
    "documentation": {"kind": "markdown", "value": " Reverse-application operator: [x |> f |> g] is exactly equivalent\n to [g (f (x))].\n Left-associative operator at precedence level 4/11.\n   @since 4.01\n "}
  }, {
    "label": "Pervasives.!=",
    "kind": 12,
    "tags": [],
    "detail": "('a, 'a) => bool",
    "documentation": {"kind": "markdown", "value": " Negation of {!Pervasives.( == )}.\n    Left-associative operator at precedence level 4/11. "}
  }, {
    "label": "Pervasives.pred",
    "kind": 12,
    "tags": [],
    "detail": "int => int",
    "documentation": {"kind": "markdown", "value": " [pred x] is [x - 1]. "}
  }, {
    "label": "Pervasives.decr",
    "kind": 12,
    "tags": [],
    "detail": "ref<int> => unit",
    "documentation": {"kind": "markdown", "value": " Decrement the integer contained in the given reference.\n   Equivalent to [fun r -> r := pred !r]. "}
  }, {
    "label": "Pervasives.modf",
    "kind": 12,
    "tags": [],
    "detail": "float => (float, float)",
    "documentation": {"kind": "markdown", "value": " [modf f] returns the pair of the fractional and integral\n   part of [f]. "}
  }, {
    "label": "Pervasives.~-.",
    "kind": 12,
    "tags": [],
    "detail": "float => float",
    "documentation": {"kind": "markdown", "value": " Unary negation. You can also write [-. e] instead of [~-. e].\n    Unary operator at precedence level 9/11 for [-. e]\n    and 11/11 for [~-. e]. "}
  }, {
    "label": "Pervasives.^",
    "kind": 12,
    "tags": [],
    "detail": "(string, string) => string",
    "documentation": {"kind": "markdown", "value": " {1 String operations}\n\n   More string operations are provided in module {!String}.\n"}
  }, {
    "label": "Pervasives.~-",
    "kind": 12,
    "tags": [],
    "detail": "int => int",
    "documentation": {"kind": "markdown", "value": " Unary negation. You can also write [- e] instead of [~- e].\n    Unary operator at precedence level 9/11 for [- e]\n    and 11/11 for [~- e]. "}
  }, {
    "label": "Pervasives.print_endline",
    "kind": 12,
    "tags": [],
    "detail": "string => unit",
    "documentation": {"kind": "markdown", "value": " Print a string, followed by a newline character, on\n   standard output and flush standard output. "}
  }, {
    "label": "Pervasives.-.",
    "kind": 12,
    "tags": [],
    "detail": "(float, float) => float",
    "documentation": {"kind": "markdown", "value": " Floating-point subtraction.\n    Left-associative operator at precedence level 6/11. "}
  }, {
    "label": "Pervasives.string_of_float",
    "kind": 12,
    "tags": [],
    "detail": "float => string",
    "documentation": {"kind": "markdown", "value": " Return the string representation of a floating-point number. "}
  }, {
    "label": "Pervasives.lsl",
    "kind": 12,
    "tags": [],
    "detail": "(int, int) => int",
    "documentation": {"kind": "markdown", "value": " [n lsl m] shifts [n] to the left by [m] bits.\n   The result is unspecified if [m < 0] or [m >= bitsize],\n   where [bitsize] is [32] on a 32-bit platform and\n   [64] on a 64-bit platform.\n   Right-associative operator at precedence level 8/11. "}
  }, {
    "label": "Pervasives.+.",
    "kind": 12,
    "tags": [],
    "detail": "(float, float) => float",
    "documentation": {"kind": "markdown", "value": " Floating-point addition.\n    Left-associative operator at precedence level 6/11. "}
  }, {
    "label": "Pervasives.!",
    "kind": 12,
    "tags": [],
    "detail": "ref<'a> => 'a",
    "documentation": {"kind": "markdown", "value": " [!r] returns the current contents of reference [r].\n   Equivalent to [fun r -> r.contents].\n   Unary operator at precedence level 11/11."}
  }, {
    "label": "Pervasives.sqrt",
    "kind": 12,
    "tags": [],
    "detail": "float => float",
    "documentation": {"kind": "markdown", "value": " Square root. "}
  }, {
    "label": "Pervasives.cosh",
    "kind": 12,
    "tags": [],
    "detail": "float => float",
    "documentation": {"kind": "markdown", "value": " Hyperbolic cosine.  Argument is in radians. "}
  }, {
    "label": "Pervasives.prerr_newline",
    "kind": 12,
    "tags": [],
    "detail": "unit => unit",
    "documentation": {"kind": "markdown", "value": " Print a newline character on standard error, and flush\n   standard error. "}
  }, {
    "label": "Pervasives.invalid_arg",
    "kind": 12,
    "tags": [],
    "detail": "string => 'a",
    "documentation": {"kind": "markdown", "value": " Raise exception [Invalid_argument] with the given string. "}
  }, {
    "label": "Pervasives.__LOC_OF__",
    "kind": 12,
    "tags": [],
    "detail": "'a => (string, 'a)",
    "documentation": {"kind": "markdown", "value": " [__LOC_OF__ expr] returns a pair [(loc, expr)] where [loc] is the\n    location of [expr] in the file currently being parsed by the\n    compiler, with the standard error format of OCaml: \"File %S, line\n    %d, characters %d-%d\".\n    @since 4.02.0\n"}
  }, {
    "label": "Pervasives.min_float",
    "kind": 12,
    "tags": [],
    "detail": "float",
    "documentation": {"kind": "markdown", "value": " The smallest positive, non-zero, non-denormalized value of type [float]. "}
  }, {
    "label": "Pervasives.abs",
    "kind": 12,
    "tags": [],
    "detail": "int => int",
    "documentation": {"kind": "markdown", "value": " Return the absolute value of the argument.  Note that this may be\n  negative if the argument is [min_int]. "}
  }, {
    "label": "Pervasives.@",
    "kind": 12,
    "tags": [],
    "detail": "(list<'a>, list<'a>) => list<'a>",
    "documentation": {"kind": "markdown", "value": " List concatenation.  Tail-recursive (length of the first argument).\n    Right-associative operator at precedence level 5/11. "}
  }, {
    "label": "Pervasives.*.",
    "kind": 12,
    "tags": [],
    "detail": "(float, float) => float",
    "documentation": {"kind": "markdown", "value": " Floating-point multiplication.\n    Left-associative operator at precedence level 7/11. "}
  }, {
    "label": "Pervasives.max_float",
    "kind": 12,
    "tags": [],
    "detail": "float",
    "documentation": {"kind": "markdown", "value": " The largest positive finite value of type [float]. "}
  }, {
    "label": "Pervasives.int_of_float",
    "kind": 12,
    "tags": [],
    "detail": "float => int",
    "documentation": {"kind": "markdown", "value": " Truncate the given floating-point number to an integer.\n   The result is unspecified if the argument is [nan] or falls outside the\n   range of representable integers. "}
  }, {
    "label": "Pervasives.raise",
    "kind": 12,
    "tags": [],
    "detail": "exn => 'a",
    "documentation": {"kind": "markdown", "value": " Raise the given exception value "}
  }, {
    "label": "Pervasives.max_int",
    "kind": 12,
    "tags": [],
    "detail": "int",
    "documentation": {"kind": "markdown", "value": " The greatest representable integer. "}
  }, {
    "label": "Pervasives.log10",
    "kind": 12,
    "tags": [],
    "detail": "float => float",
    "documentation": {"kind": "markdown", "value": " Base 10 logarithm. "}
  }, {
    "label": "Pervasives.int_of_char",
    "kind": 12,
    "tags": [],
    "detail": "char => int",
    "documentation": {"kind": "markdown", "value": " Return the ASCII code of the argument. "}
  }, {
    "label": "Pervasives.-",
    "kind": 12,
    "tags": [],
    "detail": "(int, int) => int",
    "documentation": {"kind": "markdown", "value": " Integer subtraction.\n    Left-associative operator at precedence level 6/11. "}
  }, {
    "label": "Pervasives.print_string",
    "kind": 12,
    "tags": [],
    "detail": "string => unit",
    "documentation": {"kind": "markdown", "value": " Print a string on standard output. "}
  }, {
    "label": "Pervasives.print_int",
    "kind": 12,
    "tags": [],
    "detail": "int => unit",
    "documentation": {"kind": "markdown", "value": " Print an integer, in decimal, on standard output. "}
  }, {
    "label": "Pervasives.cos",
    "kind": 12,
    "tags": [],
    "detail": "float => float",
    "documentation": {"kind": "markdown", "value": " Cosine.  Argument is in radians. "}
  }, {
    "label": "Pervasives.string_of_bool",
    "kind": 12,
    "tags": [],
    "detail": "bool => string",
    "documentation": {"kind": "markdown", "value": " Return the string representation of a boolean. As the returned values\n   may be shared, the user should not modify them directly.\n"}
  }, {
    "label": "Pervasives.__MODULE__",
    "kind": 12,
    "tags": [],
    "detail": "string",
    "documentation": {"kind": "markdown", "value": " [__MODULE__] returns the module name of the file being\n    parsed by the compiler.\n    @since 4.02.0\n"}
  }, {
    "label": "Pervasives.+",
    "kind": 12,
    "tags": [],
    "detail": "(int, int) => int",
    "documentation": {"kind": "markdown", "value": " Integer addition.\n    Left-associative operator at precedence level 6/11. "}
  }, {
    "label": "Pervasives.expm1",
    "kind": 12,
    "tags": [],
    "detail": "float => float",
    "documentation": {"kind": "markdown", "value": " [expm1 x] computes [exp x -. 1.0], giving numerically-accurate results\n    even if [x] is close to [0.0].\n    @since 3.12.0\n"}
  }, {
    "label": "Pervasives.__LINE__",
    "kind": 12,
    "tags": [],
    "detail": "int",
    "documentation": {"kind": "markdown", "value": " [__LINE__] returns the line number at which this expression\n    appears in the file currently being parsed by the compiler.\n    @since 4.02.0\n"}
  }, {
    "label": "Pervasives.string_of_int",
    "kind": 12,
    "tags": [],
    "detail": "int => string",
    "documentation": {"kind": "markdown", "value": " Return the string representation of an integer, in decimal. "}
  }, {
    "label": "Pervasives.exit",
    "kind": 12,
    "tags": [],
    "detail": "int => 'a",
    "documentation": {"kind": "markdown", "value": " Terminate the process, returning the given status code\n   to the operating system: usually 0 to indicate no errors,\n   and a small positive integer to indicate failure.\n   All open output channels are flushed with [flush_all].\n   An implicit [exit 0] is performed each time a program\n   terminates normally.  An implicit [exit 2] is performed if the program\n   terminates early because of an uncaught exception. "}
  }, {
    "label": "Pervasives.>",
    "kind": 12,
    "tags": [],
    "detail": "('a, 'a) => bool",
    "documentation": {"kind": "markdown", "value": " See {!Pervasives.( >= )}.\n    Left-associative operator at precedence level 4/11. "}
  }, {
    "label": "Pervasives.ref",
    "kind": 12,
    "tags": [],
    "detail": "'a => ref<'a>",
    "documentation": {"kind": "markdown", "value": " Return a fresh reference containing the given value. "}
  }, {
    "label": "Pervasives.failwith",
    "kind": 12,
    "tags": [],
    "detail": "string => 'a",
    "documentation": {"kind": "markdown", "value": " Raise exception [Failure] with the given string. "}
  }, {
    "label": "Pervasives.bool_of_string_opt",
    "kind": 12,
    "tags": [],
    "detail": "string => option<bool>",
    "documentation": {"kind": "markdown", "value": " Convert the given string to a boolean.\n    Return [None] if the string is not\n    [\"true\"] or [\"false\"].\n    @since 4.05\n"}
  }, {
    "label": "Pervasives.raise_notrace",
    "kind": 12,
    "tags": [],
    "detail": "exn => 'a",
    "documentation": {"kind": "markdown", "value": " A faster version [raise] which does not record the backtrace.\n    @since 4.02.0\n"}
  }, {
    "label": "Pervasives.<=",
    "kind": 12,
    "tags": [],
    "detail": "('a, 'a) => bool",
    "documentation": {"kind": "markdown", "value": " See {!Pervasives.( >= )}.\n    Left-associative operator at precedence level 4/11. "}
  }, {
    "label": "Pervasives.compare",
    "kind": 12,
    "tags": [],
    "detail": "('a, 'a) => int",
    "documentation": {"kind": "markdown", "value": " [compare x y] returns [0] if [x] is equal to [y],\n   a negative integer if [x] is less than [y], and a positive integer\n   if [x] is greater than [y].  The ordering implemented by [compare]\n   is compatible with the comparison predicates [=], [<] and [>]\n   defined above,  with one difference on the treatment of the float value\n   {!Pervasives.nan}.  Namely, the comparison predicates treat [nan]\n   as different from any other float value, including itself;\n   while [compare] treats [nan] as equal to itself and less than any\n   other float value.  This treatment of [nan] ensures that [compare]\n   defines a total ordering relation.\n\n   [compare] applied to functional values may raise [Invalid_argument].\n   [compare] applied to cyclic structures may not terminate.\n\n   The [compare] function can be used as the comparison function\n   required by the {!Set.Make} and {!Map.Make} functors, as well as\n   the {!List.sort} and {!Array.sort} functions. "}
  }, {
    "label": "Pervasives.__LINE_OF__",
    "kind": 12,
    "tags": [],
    "detail": "'a => (int, 'a)",
    "documentation": {"kind": "markdown", "value": " [__LINE__ expr] returns a pair [(line, expr)], where [line] is the\n    line number at which the expression [expr] appears in the file\n    currently being parsed by the compiler.\n    @since 4.02.0\n "}
  }, {
    "label": "Pervasives.succ",
    "kind": 12,
    "tags": [],
    "detail": "int => int",
    "documentation": {"kind": "markdown", "value": " [succ x] is [x + 1]. "}
  }, {
    "label": "Pervasives./",
    "kind": 12,
    "tags": [],
    "detail": "(int, int) => int",
    "documentation": {"kind": "markdown", "value": " Integer division.\n   Raise [Division_by_zero] if the second argument is 0.\n   Integer division rounds the real quotient of its arguments towards zero.\n   More precisely, if [x >= 0] and [y > 0], [x / y] is the greatest integer\n   less than or equal to the real quotient of [x] by [y].  Moreover,\n   [(- x) / y = x / (- y) = - (x / y)].\n   Left-associative operator at precedence level 7/11. "}
  }, {
    "label": "Pervasives.float",
    "kind": 12,
    "tags": [],
    "detail": "int => float",
    "documentation": {"kind": "markdown", "value": " Same as {!Pervasives.float_of_int}. "}
  }, {
    "label": "Pervasives.ignore",
    "kind": 12,
    "tags": [],
    "detail": "'a => unit",
    "documentation": {"kind": "markdown", "value": " Discard the value of its argument and return [()].\n   For instance, [ignore(f x)] discards the result of\n   the side-effecting function [f].  It is equivalent to\n   [f x; ()], except that the latter may generate a\n   compiler warning; writing [ignore(f x)] instead\n   avoids the warning. "}
  }, {
    "label": "Pervasives.hypot",
    "kind": 12,
    "tags": [],
    "detail": "(float, float) => float",
    "documentation": {"kind": "markdown", "value": " [hypot x y] returns [sqrt(x *. x + y *. y)], that is, the length\n  of the hypotenuse of a right-angled triangle with sides of length\n  [x] and [y], or, equivalently, the distance of the point [(x,y)]\n  to origin.\n  @since 4.00.0  "}
  }, {
    "label": "Pervasives.=",
    "kind": 12,
    "tags": [],
    "detail": "('a, 'a) => bool",
    "documentation": {"kind": "markdown", "value": " [e1 = e2] tests for structural equality of [e1] and [e2].\n   Mutable structures (e.g. references and arrays) are equal\n   if and only if their current contents are structurally equal,\n   even if the two mutable objects are not the same physical object.\n   Equality between functional values raises [Invalid_argument].\n   Equality between cyclic data structures may not terminate.\n   Left-associative operator at precedence level 4/11. "}
  }, {
    "label": "Pervasives.__POS_OF__",
    "kind": 12,
    "tags": [],
    "detail": "'a => ((string, int, int, int), 'a)",
    "documentation": {"kind": "markdown", "value": " [__POS_OF__ expr] returns a pair [(loc,expr)], where [loc] is a\n    tuple [(file,lnum,cnum,enum)] corresponding to the location at\n    which the expression [expr] appears in the file currently being\n    parsed by the compiler. [file] is the current filename, [lnum] the\n    line number, [cnum] the character position in the line and [enum]\n    the last character position in the line.\n    @since 4.02.0\n "}
  }, {
    "label": "Pervasives.float_of_string_opt",
    "kind": 12,
    "tags": [],
    "detail": "string => option<float>",
    "documentation": {"kind": "markdown", "value": " Same as [float_of_string], but returns [None] instead of raising.\n    @since 4.05\n"}
  }, {
    "label": "Pervasives.max",
    "kind": 12,
    "tags": [],
    "detail": "('a, 'a) => 'a",
    "documentation": {"kind": "markdown", "value": " Return the greater of the two arguments.\n    The result is unspecified if one of the arguments contains\n    the float value [nan]. "}
  }, {
    "label": "Pervasives.frexp",
    "kind": 12,
    "tags": [],
    "detail": "float => (float, int)",
    "documentation": {"kind": "markdown", "value": " [frexp f] returns the pair of the significant\n   and the exponent of [f].  When [f] is zero, the\n   significant [x] and the exponent [n] of [f] are equal to\n   zero.  When [f] is non-zero, they are defined by\n   [f = x *. 2 ** n] and [0.5 <= x < 1.0]. "}
  }, {
    "label": "Pervasives.copysign",
    "kind": 12,
    "tags": [],
    "detail": "(float, float) => float",
    "documentation": {"kind": "markdown", "value": " [copysign x y] returns a float whose absolute value is that of [x]\n  and whose sign is that of [y].  If [x] is [nan], returns [nan].\n  If [y] is [nan], returns either [x] or [-. x], but it is not\n  specified which.\n  @since 4.00.0  "}
  }, {
    "label": "Pervasives.float_of_string",
    "kind": 12,
    "tags": [],
    "detail": "string => float",
    "documentation": {"kind": "markdown", "value": " Convert the given string to a float.  The string is read in decimal\n   (by default) or in hexadecimal (marked by [0x] or [0X]).\n   The format of decimal floating-point numbers is\n   [ [-] dd.ddd (e|E) [+|-] dd ], where [d] stands for a decimal digit.\n   The format of hexadecimal floating-point numbers is\n   [ [-] 0(x|X) hh.hhh (p|P) [+|-] dd ], where [h] stands for an\n   hexadecimal digit and [d] for a decimal digit.\n   In both cases, at least one of the integer and fractional parts must be\n   given; the exponent part is optional.\n   The [_] (underscore) character can appear anywhere in the string\n   and is ignored.\n   Depending on the execution platforms, other representations of\n   floating-point numbers can be accepted, but should not be relied upon.\n   Raise [Failure \"float_of_string\"] if the given string is not a valid\n   representation of a float. "}
  }, {
    "label": "Pervasives.log1p",
    "kind": 12,
    "tags": [],
    "detail": "float => float",
    "documentation": {"kind": "markdown", "value": " [log1p x] computes [log(1.0 +. x)] (natural logarithm),\n    giving numerically-accurate results even if [x] is close to [0.0].\n    @since 3.12.0\n"}
  }, {
    "label": "Pervasives.epsilon_float",
    "kind": 12,
    "tags": [],
    "detail": "float",
    "documentation": {"kind": "markdown", "value": " The difference between [1.0] and the smallest exactly representable\n    floating-point number greater than [1.0]. "}
  }, {
    "label": "Pervasives.nan",
    "kind": 12,
    "tags": [],
    "detail": "float",
    "documentation": {"kind": "markdown", "value": " A special floating-point value denoting the result of an\n   undefined operation such as [0.0 /. 0.0].  Stands for\n   'not a number'.  Any floating-point operation with [nan] as\n   argument returns [nan] as result.  As for floating-point comparisons,\n   [=], [<], [<=], [>] and [>=] return [false] and [<>] returns [true]\n   if one or both of their arguments is [nan]. "}
  }, {
    "label": "Pervasives.classify_float",
    "kind": 12,
    "tags": [],
    "detail": "float => fpclass",
    "documentation": {"kind": "markdown", "value": " Return the class of the given floating-point number:\n   normal, subnormal, zero, infinite, or not a number. "}
  }, {
    "label": "Pervasives.valid_float_lexem",
    "kind": 12,
    "tags": [],
    "detail": "string => string",
    "documentation": null
  }, {
    "label": "Pervasives.||",
    "kind": 12,
    "tags": [],
    "detail": "(bool, bool) => bool",
    "documentation": {"kind": "markdown", "value": " The boolean 'or'. Evaluation is sequential, left-to-right:\n   in [e1 || e2], [e1] is evaluated first, and if it returns [true],\n   [e2] is not evaluated at all.\n   Right-associative operator at precedence level 2/11.\n"}
  }, {
    "label": "Pervasives.sinh",
    "kind": 12,
    "tags": [],
    "detail": "float => float",
    "documentation": {"kind": "markdown", "value": " Hyperbolic sine.  Argument is in radians. "}
  }, {
    "label": "Pervasives.snd",
    "kind": 12,
    "tags": [],
    "detail": "(('a, 'b)) => 'b",
    "documentation": {"kind": "markdown", "value": " Return the second component of a pair. "}
  }, {
    "label": "Pervasives.>=",
    "kind": 12,
    "tags": [],
    "detail": "('a, 'a) => bool",
    "documentation": {"kind": "markdown", "value": " Structural ordering functions. These functions coincide with\n   the usual orderings over integers, characters, strings, byte sequences\n   and floating-point numbers, and extend them to a\n   total ordering over all types.\n   The ordering is compatible with [( = )]. As in the case\n   of [( = )], mutable structures are compared by contents.\n   Comparison between functional values raises [Invalid_argument].\n   Comparison between cyclic structures may not terminate.\n   Left-associative operator at precedence level 4/11. "}
  }, {
    "label": "Pervasives.lnot",
    "kind": 12,
    "tags": [],
    "detail": "int => int",
    "documentation": {"kind": "markdown", "value": " Bitwise logical negation. "}
  }, {
    "label": "Pervasives.truncate",
    "kind": 12,
    "tags": [],
    "detail": "float => int",
    "documentation": {"kind": "markdown", "value": " Same as {!Pervasives.int_of_float}. "}
  }, {
    "label": "Pervasives.int_of_string_opt",
    "kind": 12,
    "tags": [],
    "detail": "string => option<int>",
    "documentation": {"kind": "markdown", "value": " Same as [int_of_string], but returns [None] instead of raising.\n    @since 4.05\n"}
  }, {
    "label": "Pervasives.asin",
    "kind": 12,
    "tags": [],
    "detail": "float => float",
    "documentation": {"kind": "markdown", "value": " Arc sine.  The argument must fall within the range [[-1.0, 1.0]].\n    Result is in radians and is between [-pi/2] and [pi/2]. "}
  }, {
    "label": "Pervasives.prerr_endline",
    "kind": 12,
    "tags": [],
    "detail": "string => unit",
    "documentation": {"kind": "markdown", "value": " Print a string, followed by a newline character on standard\n   error and flush standard error. "}
  }, {
    "label": "Pervasives.__POS__",
    "kind": 12,
    "tags": [],
    "detail": "(string, int, int, int)",
    "documentation": {"kind": "markdown", "value": " [__POS__] returns a tuple [(file,lnum,cnum,enum)], corresponding\n    to the location at which this expression appears in the file\n    currently being parsed by the compiler. [file] is the current\n    filename, [lnum] the line number, [cnum] the character position in\n    the line and [enum] the last character position in the line.\n    @since 4.02.0\n "}
  }, {
    "label": "Pervasives.lxor",
    "kind": 12,
    "tags": [],
    "detail": "(int, int) => int",
    "documentation": {"kind": "markdown", "value": " Bitwise logical exclusive or.\n    Left-associative operator at precedence level 7/11. "}
  }, {
    "label": "Pervasives.exp",
    "kind": 12,
    "tags": [],
    "detail": "float => float",
    "documentation": {"kind": "markdown", "value": " Exponential. "}
  }, {
    "label": "Pervasives.floor",
    "kind": 12,
    "tags": [],
    "detail": "float => float",
    "documentation": {"kind": "markdown", "value": " Round below to an integer value.\n    [floor f] returns the greatest integer value less than or\n    equal to [f].\n    The result is returned as a float. "}
  }, {
    "label": "Pervasives.ldexp",
    "kind": 12,
    "tags": [],
    "detail": "(float, int) => float",
    "documentation": {"kind": "markdown", "value": " [ldexp x n] returns [x *. 2 ** n]. "}
  }, {
    "label": "Pervasives.tan",
    "kind": 12,
    "tags": [],
    "detail": "float => float",
    "documentation": {"kind": "markdown", "value": " Tangent.  Argument is in radians. "}
  }, {
    "label": "Pervasives.int_of_string",
    "kind": 12,
    "tags": [],
    "detail": "string => int",
    "documentation": {"kind": "markdown", "value": " Convert the given string to an integer.\n   The string is read in decimal (by default, or if the string \n   begins with [0u]), in hexadecimal (if it begins with [0x] or\n   [0X]), in octal (if it begins with [0o] or [0O]), or in binary\n   (if it begins with [0b] or [0B]).\n\n   The [0u] prefix reads the input as an unsigned integer in the range\n   [[0, 2*max_int+1]].  If the input exceeds {!max_int}\n   it is converted to the signed integer\n   [min_int + input - max_int - 1].\n\n   The [_] (underscore) character can appear anywhere in the string\n   and is ignored.\n   Raise [Failure \"int_of_string\"] if the given string is not\n   a valid representation of an integer, or if the integer represented\n   exceeds the range of integers representable in type [int]. "}
  }, {
    "label": "Pervasives.**",
    "kind": 12,
    "tags": [],
    "detail": "(float, float) => float",
    "documentation": {"kind": "markdown", "value": " Exponentiation. "}
  }, {
    "label": "Pervasives.log",
    "kind": 12,
    "tags": [],
    "detail": "float => float",
    "documentation": {"kind": "markdown", "value": " Natural logarithm. "}
  }, {
    "label": "Pervasives.infinity",
    "kind": 12,
    "tags": [],
    "detail": "float",
    "documentation": {"kind": "markdown", "value": " Positive infinity. "}
  }, {
    "label": "Pervasives.~+.",
    "kind": 12,
    "tags": [],
    "detail": "float => float",
    "documentation": {"kind": "markdown", "value": " Unary addition. You can also write [+. e] instead of [~+. e].\n    Unary operator at precedence level 9/11 for [+. e]\n    and 11/11 for [~+. e].\n    @since 3.12.0\n"}
  }, {
    "label": "Pervasives.at_exit",
    "kind": 12,
    "tags": [],
    "detail": "(unit => unit) => unit",
    "documentation": {"kind": "markdown", "value": " Register the given function to be called at program termination\n   time. The functions registered with [at_exit] will be called when\n   the program does any of the following:\n   - executes {!Pervasives.exit}\n   - terminates, either normally or because of an uncaught\n     exception\n   - executes the C function [caml_shutdown].\n   The functions are called in 'last in, first out' order: the\n   function most recently added with [at_exit] is called first. "}
  }, {
    "label": "Pervasives.min_int",
    "kind": 12,
    "tags": [],
    "detail": "int",
    "documentation": {"kind": "markdown", "value": " The smallest representable integer. "}
  }, {
    "label": "Pervasives.land",
    "kind": 12,
    "tags": [],
    "detail": "(int, int) => int",
    "documentation": {"kind": "markdown", "value": " Bitwise logical and.\n    Left-associative operator at precedence level 7/11. "}
  }, {
    "label": "Pervasives.fst",
    "kind": 12,
    "tags": [],
    "detail": "(('a, 'b)) => 'a",
    "documentation": {"kind": "markdown", "value": " Return the first component of a pair. "}
  }, {
    "label": "Pervasives.incr",
    "kind": 12,
    "tags": [],
    "detail": "ref<int> => unit",
    "documentation": {"kind": "markdown", "value": " Increment the integer contained in the given reference.\n   Equivalent to [fun r -> r := succ !r]. "}
  }, {
    "label": "Pervasives.tanh",
    "kind": 12,
    "tags": [],
    "detail": "float => float",
    "documentation": {"kind": "markdown", "value": " Hyperbolic tangent.  Argument is in radians. "}
  }, {
    "label": "Pervasives.bool_of_string",
    "kind": 12,
    "tags": [],
    "detail": "string => bool",
    "documentation": {"kind": "markdown", "value": " Convert the given string to a boolean.\n   Raise [Invalid_argument \"bool_of_string\"] if the string is not\n   [\"true\"] or [\"false\"]. "}
  }, {
    "label": "Pervasives.~+",
    "kind": 12,
    "tags": [],
    "detail": "int => int",
    "documentation": {"kind": "markdown", "value": " Unary addition. You can also write [+ e] instead of [~+ e].\n    Unary operator at precedence level 9/11 for [+ e]\n    and 11/11 for [~+ e].\n    @since 3.12.0\n"}
  }, {
    "label": "Pervasives.mod",
    "kind": 12,
    "tags": [],
    "detail": "(int, int) => int",
    "documentation": {"kind": "markdown", "value": " Integer remainder.  If [y] is not zero, the result\n   of [x mod y] satisfies the following properties:\n   [x = (x / y) * y + x mod y] and\n   [abs(x mod y) <= abs(y) - 1].\n   If [y = 0], [x mod y] raises [Division_by_zero].\n   Note that [x mod y] is negative only if [x < 0].\n   Raise [Division_by_zero] if [y] is zero.\n   Left-associative operator at precedence level 7/11. "}
  }, {
    "label": "Pervasives.__FILE__",
    "kind": 12,
    "tags": [],
    "detail": "string",
    "documentation": {"kind": "markdown", "value": " [__FILE__] returns the name of the file currently being\n    parsed by the compiler.\n    @since 4.02.0\n"}
  }, {
    "label": "Pervasives.@@",
    "kind": 12,
    "tags": [],
    "detail": "('a => 'b, 'a) => 'b",
    "documentation": {"kind": "markdown", "value": " Application operator: [g @@ f @@ x] is exactly equivalent to\n [g (f (x))].\n Right-associative operator at precedence level 5/11.\n   @since 4.01\n"}
  }, {
    "label": "Pervasives.acos",
    "kind": 12,
    "tags": [],
    "detail": "float => float",
    "documentation": {"kind": "markdown", "value": " Arc cosine.  The argument must fall within the range [[-1.0, 1.0]].\n    Result is in radians and is between [0.0] and [pi]. "}
  }, {
    "label": "Pervasives.print_float",
    "kind": 12,
    "tags": [],
    "detail": "float => unit",
    "documentation": {"kind": "markdown", "value": " Print a floating-point number, in decimal, on standard output. "}
  }, {
    "label": "Pervasives.min",
    "kind": 12,
    "tags": [],
    "detail": "('a, 'a) => 'a",
    "documentation": {"kind": "markdown", "value": " Return the smaller of the two arguments.\n    The result is unspecified if one of the arguments contains\n    the float value [nan]. "}
  }, {
    "label": "Pervasives.__unsafe_cast",
    "kind": 12,
    "tags": [],
    "detail": "'a => 'b",
    "documentation": null
  }, {
    "label": "Pervasives.&&",
    "kind": 12,
    "tags": [],
    "detail": "(bool, bool) => bool",
    "documentation": {"kind": "markdown", "value": " The boolean 'and'. Evaluation is sequential, left-to-right:\n   in [e1 && e2], [e1] is evaluated first, and if it returns [false],\n   [e2] is not evaluated at all.\n   Right-associative operator at precedence level 3/11. "}
  }, {
    "label": "Pervasives.atan",
    "kind": 12,
    "tags": [],
    "detail": "float => float",
    "documentation": {"kind": "markdown", "value": " Arc tangent.\n    Result is in radians and is between [-pi/2] and [pi/2]. "}
  }, {
    "label": "Pervasives.Ok",
    "kind": 4,
    "tags": [],
    "detail": "Ok('a)\n\ntype result<'a, 'b> = Belt.Result.t<'a, 'b> =\n  | Ok('a)\n  | Error('b)",
    "documentation": null
  }, {
    "label": "Pervasives.Error",
    "kind": 4,
    "tags": [],
    "detail": "Error('b)\n\ntype result<'a, 'b> = Belt.Result.t<'a, 'b> =\n  | Ok('a)\n  | Error('b)",
    "documentation": null
  }, {
    "label": "Pervasives.FP_normal",
    "kind": 4,
    "tags": [],
    "detail": "FP_normal\n\ntype fpclass =\n  | FP_normal\n  | FP_subnormal\n  | FP_zero\n  | FP_infinite\n  | FP_nan",
    "documentation": null
  }, {
    "label": "Pervasives.FP_subnormal",
    "kind": 4,
    "tags": [],
    "detail": "FP_subnormal\n\ntype fpclass =\n  | FP_normal\n  | FP_subnormal\n  | FP_zero\n  | FP_infinite\n  | FP_nan",
    "documentation": null
  }, {
    "label": "Pervasives.FP_zero",
    "kind": 4,
    "tags": [],
    "detail": "FP_zero\n\ntype fpclass =\n  | FP_normal\n  | FP_subnormal\n  | FP_zero\n  | FP_infinite\n  | FP_nan",
    "documentation": null
  }, {
    "label": "Pervasives.FP_infinite",
    "kind": 4,
    "tags": [],
    "detail": "FP_infinite\n\ntype fpclass =\n  | FP_normal\n  | FP_subnormal\n  | FP_zero\n  | FP_infinite\n  | FP_nan",
    "documentation": null
  }, {
    "label": "Pervasives.FP_nan",
    "kind": 4,
    "tags": [],
    "detail": "FP_nan\n\ntype fpclass =\n  | FP_normal\n  | FP_subnormal\n  | FP_zero\n  | FP_infinite\n  | FP_nan",
    "documentation": null
  }]

