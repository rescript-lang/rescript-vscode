// --- BROKEN PARSER CASES ---
// This below demonstrates an issue when what you're completing is the _last_ labelled argument, and there's a unit application after it. The parser wrongly merges the unit argument as the expression of the labelled argument assignment, where is should really let the trailing unit argument be, and set a %rescript.exprhole as the expression of the assignment, just like it normally does.
// let _ = someFn(~isOff=, ())
//                      ^com

// This should parse as a single item tuple when in a pattern?
// switch s { | (t) }
//               ^com

// Here the parser eats the arrow and considers the None in the expression part of the pattern.
// let _ = switch x { | None |  => None }
//                           ^com

Complete src/BrokenParserCases.res 2:24
posCursor:[2:24] posNoWhite:[2:23] Found expr:[2:11->2:30]
Pexp_apply ...[2:11->2:17] (~isOff2:19->2:24=...[2:27->2:29])
Completable: CnamedArg(Value[someFn], isOff, [isOff])
Package opens Pervasives.JsxModules.place holder
Resolved opens 1 pervasives
ContextPath Value[someFn]
Path someFn
[]

Complete src/BrokenParserCases.res 6:17
posCursor:[6:17] posNoWhite:[6:16] Found pattern:[6:16->6:19]
Completable: Cpattern Value[s]=t
Package opens Pervasives.JsxModules.place holder
Resolved opens 1 pervasives
ContextPath Value[s]
Path s
[]

Complete src/BrokenParserCases.res 10:29
posCursor:[10:29] posNoWhite:[10:27] Found pattern:[10:24->10:39]
posCursor:[10:29] posNoWhite:[10:27] Found pattern:[10:24->10:28]
Ppat_construct None:[10:24->10:28]
Completable: Cpath Value[None]
Package opens Pervasives.JsxModules.place holder
Resolved opens 1 pervasives
ContextPath Value[None]
Path None
[]

