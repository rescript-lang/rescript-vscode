// Generated by ReScript, PLEASE EDIT WITH CARE

import * as List from "rescript/lib/es6/list.js";
import * as Random from "rescript/lib/es6/random.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

var counter = {
  contents: Random.$$int(100)
};

function progress() {
  if (counter.contents < 0) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "TestCyberTruck.res",
            8,
            6
          ],
          Error: new Error()
        };
  }
  counter.contents = counter.contents - 1 | 0;
}

var Nested = {
  f: progress
};

var Progress = {
  Nested: Nested
};

function justReturn() {
  
}

function alwaysLoop() {
  while(true) {
    continue ;
  };
}

function alwaysProgress() {
  while(true) {
    progress();
    continue ;
  };
}

function alwaysProgressWrongOrder() {
  alwaysProgressWrongOrder();
  progress();
}

function doNotAlias() {
  while(true) {
    continue ;
  };
}

function progressOnBothBranches(x) {
  while(true) {
    progress();
    continue ;
  };
}

function progressOnOneBranch(x) {
  while(true) {
    if (x > 3) {
      progress();
    }
    continue ;
  };
}

function testParametricFunction(x) {
  if (x > 3) {
    progress();
  }
  return callParseFunction(x, testParametricFunction);
}

function callParseFunction(x, parseFunction) {
  return parseFunction(x);
}

function testParametricFunction2(x) {
  return testParametricFunction(x);
}

function testCacheHit(x) {
  while(true) {
    if (x > 0) {
      progress();
    }
    continue ;
  };
}

function doNothing(param) {
  
}

function evalOrderIsNotLeftToRight(x) {
  evalOrderIsNotLeftToRight(x);
  progress();
}

function evalOrderIsNotRightToLeft(x) {
  progress();
  evalOrderIsNotRightToLeft(x);
}

function butFirstArgumentIsAlwaysEvaluated(x) {
  while(true) {
    progress();
    continue ;
  };
}

function butSecondArgumentIsAlwaysEvaluated(x) {
  while(true) {
    progress();
    continue ;
  };
}

function tokenToString(token) {
  if (typeof token === "object") {
    return String(token._0);
  }
  switch (token) {
    case "Asterisk" :
        return "*";
    case "Eof" :
        return "Eof";
    case "Lparen" :
        return "(";
    case "Plus" :
        return "+";
    case "Rparen" :
        return ")";
    
  }
}

function next(p) {
  p.token = Random.bool() ? "Eof" : ({
        TAG: "Int",
        _0: Random.$$int(1000)
      });
  p.position = {
    lnum: Random.$$int(1000),
    cnum: Random.$$int(80)
  };
}

function err(p, s) {
  p.errors = {
    hd: s,
    tl: p.errors
  };
}

function expect(p, token) {
  if (Caml_obj.equal(p.token, token)) {
    return next(p);
  } else {
    return err(p, "expected token " + tokenToString(p.token));
  }
}

var Parser = {
  tokenToString: tokenToString,
  next: next,
  err: err,
  expect: expect
};

var Expr = {};

function parseList(p, f) {
  var loop = function (p) {
    if (p.token === "Asterisk") {
      return /* [] */0;
    }
    var item = f(p);
    var l = loop(p);
    return {
            hd: item,
            tl: l
          };
  };
  return loop(p);
}

function $$parseInt(p) {
  var n = p.token;
  var res;
  if (typeof n !== "object") {
    err(p, "integer expected");
    res = -1;
  } else {
    res = n._0;
  }
  next(p);
  return res;
}

function parseExpression(xOpt, p) {
  var match = p.token;
  if (typeof match === "object") {
    return {
            TAG: "Int",
            _0: $$parseInt(p)
          };
  }
  if (match !== "Lparen") {
    return {
            TAG: "Int",
            _0: $$parseInt(p)
          };
  }
  next(p);
  var e1 = parseExpression(undefined, p);
  expect(p, "Plus");
  var e2 = parseExpression(undefined, p);
  expect(p, "Lparen");
  return {
          TAG: "Plus",
          _0: e1,
          _1: e2
        };
}

function parseListInt(p) {
  return parseList(p, $$parseInt);
}

function parseListListInt(p) {
  return parseList(p, parseListInt);
}

function parseListExpression(p) {
  return parseList(p, (function (__x) {
                return parseExpression(undefined, __x);
              }));
}

function parseListExpression2(p) {
  return parseList(p, (function (__x) {
                return parseExpression(7, __x);
              }));
}

function parseListIntTailRecursive(p) {
  var _l = /* [] */0;
  while(true) {
    var l = _l;
    if (p.token === "Asterisk") {
      return List.rev(l);
    }
    _l = {
      hd: $$parseInt(p),
      tl: l
    };
    continue ;
  };
}

function loopAfterProgress() {
  while(true) {
    continue ;
  };
}

function testLoopAfterProgress() {
  progress();
  return loopAfterProgress();
}

function nothing() {
  
}

function div(text, onClick) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "TestCyberTruck.res",
          250,
          38
        ],
        Error: new Error()
      };
}

function initState(n) {
  if (n === 0) {
    return 42;
  }
  
}

function increment(n) {
  return n + 1 | 0;
}

function incrementOnClick(setState) {
  return function () {
    setState(increment);
  };
}

function counter$1(state, setState) {
  setState(initState);
  return div(String(state), (function () {
                setState(increment);
              }));
}

function counterCompiled(state) {
  var newState = initState(state);
  if (newState !== undefined) {
    counterCompiled(newState);
  }
  String(state);
}

function onClick1(state) {
  var newState = state + 1 | 0;
  if (newState !== undefined) {
    return counterCompiled(newState);
  }
  
}

function countRenders(state, setState) {
  setState(increment);
  return div("I have been rendered " + (String(state) + " times"), nothing);
}

function countRendersCompiled(state) {
  var newState = state + 1 | 0;
  if (newState !== undefined) {
    countRendersCompiled(newState);
  }
  "I have been rendered " + (String(state) + " times");
}

var UITermination = {
  nothing: nothing,
  div: div,
  initState: initState,
  increment: increment,
  incrementOnClick: incrementOnClick,
  counter: counter$1,
  counterCompiled: counterCompiled,
  onClick1: onClick1,
  countRenders: countRenders,
  countRendersCompiled: countRendersCompiled
};

function parseListO(p, f) {
  var _nodes = /* [] */0;
  while(true) {
    var nodes = _nodes;
    if (p.token === "Asterisk") {
      next(p);
      return /* [] */0;
    }
    var item = f(p);
    if (item === undefined) {
      return List.rev(nodes);
    }
    _nodes = {
      hd: Caml_option.valFromOption(item),
      tl: nodes
    };
    continue ;
  };
}

function parseIntO(p) {
  var n = p.token;
  if (typeof n !== "object") {
    err(p, "integer expected");
    return ;
  }
  next(p);
  return n._0;
}

function alwaysReturnNone(p) {
  while(true) {
    var match = p.token;
    if (typeof match !== "object") {
      return ;
    }
    next(p);
    continue ;
  };
}

function parseListIntO(p) {
  return parseListO(p, parseIntO);
}

function testAlwaysReturnNone(p) {
  return alwaysReturnNone(p);
}

function parseIntOWrapper(p) {
  return parseIntO(p);
}

function thisMakesNoProgress(p, y) {
  if (y !== undefined) {
    return ;
  } else {
    next(p);
    return 10;
  }
}

var ParserWihtOptionals = {
  parseListO: parseListO,
  parseIntO: parseIntO,
  parseListIntO: parseListIntO,
  alwaysReturnNone: alwaysReturnNone,
  testAlwaysReturnNone: testAlwaysReturnNone,
  parseIntOWrapper: parseIntOWrapper,
  thisMakesNoProgress: thisMakesNoProgress
};

function f(p) {
  while(true) {
    var i = p.token;
    if (typeof i === "object") {
      return g(p) + i._0 | 0;
    }
    if (i === "Eof") {
      return 0;
    }
    next(p);
    continue ;
  };
}

function gParam(p, g) {
  var i = p.token;
  if (typeof i !== "object") {
    return f(p);
  } else {
    return g(p) + i._0 | 0;
  }
}

function g(p) {
  next(p);
  return gParam(p, g);
}

var Riddle = {
  f: f,
  gParam: gParam,
  g: g
};

function g$1(p) {
  while(true) {
    next(p);
    continue ;
  };
}

function f$1(p) {
  return g$1(p);
}

function kleene0(f, p) {
  while(true) {
    f(p);
    continue ;
  };
}

function union(f, g, p) {
  var x = f(p);
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  } else {
    return g(p);
  }
}

function concat(f, g, p) {
  var x = f(p);
  if (x === undefined) {
    return ;
  }
  var y = g(p);
  if (y !== undefined) {
    return x + y;
  }
  
}

function kleene(f, p) {
  var x = f(p);
  if (x !== undefined) {
    return {
            hd: x,
            tl: kleene(f, p)
          };
  } else {
    return /* [] */0;
  }
}

function two(p) {
  var match = p.token;
  if (typeof match !== "object" || match._0 !== 2) {
    return ;
  } else {
    next(p);
    return "2";
  }
}

function one(p) {
  var match = p.token;
  if (typeof match !== "object" || match._0 !== 1) {
    return ;
  } else {
    next(p);
    return "1";
  }
}

function oneTwo(p) {
  return concat(one, two, p);
}

function oneTwoStar(p) {
  return kleene(oneTwo, p);
}

var TerminationTypes = {
  f: f$1,
  g: g$1,
  kleene0: kleene0,
  union: union,
  concat: concat,
  kleene: kleene,
  one: one,
  two: two,
  oneTwo: oneTwo,
  oneTwoStar: oneTwoStar
};

function testTry() {
  while(true) {
    try {
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        progress();
        continue ;
      }
      [
        undefined,
        progress(),
        undefined
      ];
      continue ;
    }
  };
}

var progress2 = progress;

export {
  progress ,
  progress2 ,
  Progress ,
  justReturn ,
  alwaysLoop ,
  alwaysProgress ,
  alwaysProgressWrongOrder ,
  doNotAlias ,
  progressOnBothBranches ,
  progressOnOneBranch ,
  testParametricFunction ,
  testParametricFunction2 ,
  callParseFunction ,
  testCacheHit ,
  doNothing ,
  evalOrderIsNotLeftToRight ,
  evalOrderIsNotRightToLeft ,
  butFirstArgumentIsAlwaysEvaluated ,
  butSecondArgumentIsAlwaysEvaluated ,
  Parser ,
  Expr ,
  parseList ,
  $$parseInt ,
  parseListInt ,
  parseListListInt ,
  parseExpression ,
  parseListExpression ,
  parseListExpression2 ,
  parseListIntTailRecursive ,
  testLoopAfterProgress ,
  loopAfterProgress ,
  UITermination ,
  ParserWihtOptionals ,
  Riddle ,
  TerminationTypes ,
  testTry ,
}
/* counter Not a pure module */
