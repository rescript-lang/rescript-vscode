
{
  "name": "RescriptCore",
  "docstrings": [],
  "items": [
  {
    "id": "RescriptCore.timeoutId",
    "kind": "type",
    "name": "timeoutId",
    "signature": "type timeoutId = Js.Global.timeoutId",
    "docstrings": ["An `id` representing a timeout started via `setTimeout`.\n\nSee [`setTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout) on MDN."]
  }, 
  {
    "id": "RescriptCore.setTimeout",
    "kind": "value",
    "name": "setTimeout",
    "signature": "let setTimeout: (unit => unit, int) => timeoutId",
    "docstrings": ["`setTimeout(callback, durationInMilliseconds)` starts a timer that will execute `callback` after `durationInMilliseconds`.\n\nSee [`setTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout) on MDN.\n\n## Examples\n```rescript\n// Log to the console after 2 seconds (2000 milliseconds).\nlet timeoutId = setTimeout(() => {\n  Console.log(\"This prints in 2 seconds.\")\n}, 2000)\n```"]
  }, 
  {
    "id": "RescriptCore.setTimeoutFloat",
    "kind": "value",
    "name": "setTimeoutFloat",
    "signature": "let setTimeoutFloat: (unit => unit, float) => timeoutId",
    "docstrings": ["`setTimeoutFloat(callback, durationInMilliseconds)` starts a timer that will execute `callback` after `durationInMilliseconds`.\n\nThe same as `setTimeout`, but allows you to pass a `float` instead of an `int` for the duration.\n\nSee [`setTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout) on MDN.\n\n## Examples\n```rescript\n// Log to the console after 2 seconds (2000 milliseconds).\nlet timeoutId = setTimeoutFloat(() => {\n  Console.log(\"This prints in 2 seconds.\")\n}, 2000.)\n```"]
  }, 
  {
    "id": "RescriptCore.clearTimeout",
    "kind": "value",
    "name": "clearTimeout",
    "signature": "let clearTimeout: timeoutId => unit",
    "docstrings": ["`clearTimeout(timeoutId)` clears a scheduled timeout if it hasn't already executed.\n\nSee [`clearTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout) on MDN.\n\n## Examples\n```rescript\nlet timeoutId = setTimeout(() => {\n  Console.log(\"This prints in 2 seconds.\")\n}, 2000)\n\n// Clearing the timeout right away, before 2 seconds has passed, means that the above callback logging to the console will never run.\nclearTimeout(timeoutId)\n```"]
  }, 
  {
    "id": "RescriptCore.intervalId",
    "kind": "type",
    "name": "intervalId",
    "signature": "type intervalId = Js.Global.intervalId",
    "docstrings": ["An `id` representing an interval started via `setInterval`.\n\nSee [`setInterval`](https://developer.mozilla.org/en-US/docs/Web/API/setInterval) on MDN."]
  }, 
  {
    "id": "RescriptCore.setInterval",
    "kind": "value",
    "name": "setInterval",
    "signature": "let setInterval: (unit => unit, int) => intervalId",
    "docstrings": ["`setInterval(callback, intervalInMilliseconds)` starts an interval that will execute `callback` every `durationInMilliseconds` milliseconds.\n\nSee [`setInterval`](https://developer.mozilla.org/en-US/docs/Web/API/setInterval) on MDN.\n\n## Examples\n```rescript\n// Log to the console ever 2 seconds (2000 milliseconds).\nlet intervalId = setInterval(() => {\n  Console.log(\"This prints every 2 seconds.\")\n}, 2000)\n```"]
  }, 
  {
    "id": "RescriptCore.setIntervalFloat",
    "kind": "value",
    "name": "setIntervalFloat",
    "signature": "let setIntervalFloat: (unit => unit, float) => intervalId",
    "docstrings": ["`setIntervalFloat(callback, intervalInMilliseconds)` starts an interval that will execute `callback` every `durationInMilliseconds` milliseconds.\n\nThe same as `setInterval`, but allows you to pass a `float` instead of an `int` for the duration.\n\nSee [`setInterval`](https://developer.mozilla.org/en-US/docs/Web/API/setInterval) on MDN.\n\n## Examples\n```rescript\n// Log to the console ever 2 seconds (2000 milliseconds).\nlet intervalId = setIntervalFloat(() => {\n  Console.log(\"This prints every 2 seconds.\")\n}, 2000.)\n```"]
  }, 
  {
    "id": "RescriptCore.clearInterval",
    "kind": "value",
    "name": "clearInterval",
    "signature": "let clearInterval: intervalId => unit",
    "docstrings": ["`clearInterval(intervalId)` clears a scheduled interval.\n\nSee [`clearInterval`](https://developer.mozilla.org/en-US/docs/Web/API/clearInterval) on MDN.\n\n## Examples\n```rescript\nlet intervalId = setInterval(() => {\n  Console.log(\"This prints in 2 seconds.\")\n}, 2000)\n\n// Stop the interval after 10 seconds\nlet timeoutId = setTimeout(() => {\n  clearInterval(intervalId)\n}, 10000)\n```"]
  }, 
  {
    "id": "RescriptCore.encodeURI",
    "kind": "value",
    "name": "encodeURI",
    "signature": "let encodeURI: string => string",
    "docstrings": ["Encodes a URI by replacing characters in the provided string that aren't valid in a URL.\n\nThis is intended to operate on full URIs, so it encodes fewer characters than what `encodeURIComponent` does.\nIf you're looking to encode just parts of a URI, like a query parameter, prefer `encodeURIComponent`.\n\nSee [`encodeURI`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI) on MDN.\n\n## Examples\n```rescript\nConsole.log(encodeURI(\"https://rescript-lang.org?array=[someValue]\"))\n// Logs \"https://rescript-lang.org?array=%5BsomeValue%5D\" to the console.\n```"]
  }, 
  {
    "id": "RescriptCore.decodeURI",
    "kind": "value",
    "name": "decodeURI",
    "signature": "let decodeURI: string => string",
    "docstrings": ["Decodes a previously encoded URI back to a regular string.\n\nThis is intended to operate on full URIs, so it decodes fewer characters than what `decodeURIComponent` does.\nIf you're looking to decode just parts of a URI, like a query parameter, prefer `decodeURIComponent`.\n\nSee [`decodeURI`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURI) on MDN.\n\n## Examples\n```rescript\nConsole.log(decodeURI(\"https://rescript-lang.org?array=%5BsomeValue%5D\"))\n// Logs \"https://rescript-lang.org?array=[someValue]\" to the console.\n```"]
  }, 
  {
    "id": "RescriptCore.encodeURIComponent",
    "kind": "value",
    "name": "encodeURIComponent",
    "signature": "let encodeURIComponent: string => string",
    "docstrings": ["Encodes a string so it can be used as part of a URI.\n\nSee [`encodeURIComponent`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) on MDN.\n\n## Examples\n```rescript\nConsole.log(encodeURIComponent(\"array=[someValue]\"))\n// Logs \"array%3D%5BsomeValue%5D\" to the console.\n```"]
  }, 
  {
    "id": "RescriptCore.decodeURIComponent",
    "kind": "value",
    "name": "decodeURIComponent",
    "signature": "let decodeURIComponent: string => string",
    "docstrings": ["Decodes a previously URI encoded string back to its original form.\n\nSee [`decodeURIComponent`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent) on MDN.\n\n## Examples\n```rescript\nConsole.log(decodeURIComponent(\"array%3D%5BsomeValue%5D\"))\n// Logs \"array=[someValue]\" to the console.\n```"]
  }, 
  {
    "id": "RescriptCore.Array",
    "kind": "moduleAlias",
    "name": "Array",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Array.fromArrayLike",
      "kind": "value",
      "name": "fromArrayLike",
      "signature": "let fromArrayLike: Js.Array2.array_like<'a> => array<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Array.fromArrayLikeWithMap",
      "kind": "value",
      "name": "fromArrayLikeWithMap",
      "signature": "let fromArrayLikeWithMap: (Js.Array2.array_like<'a>, 'a => 'b) => array<'b>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Array.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: (~length: int, 'a) => array<'a>",
      "docstrings": ["`make(~length, init)`\n\n  Creates an array of length `length` initialized with the value of `init`.\n\n  ```res example\n  Array.make(~length=3, #apple) == [#apple, #apple, #apple]\n  ```"]
    }, 
    {
      "id": "RescriptCore.Array.fromInitializer",
      "kind": "value",
      "name": "fromInitializer",
      "signature": "let fromInitializer: (~length: int, int => 'a) => array<'a>",
      "docstrings": ["`fromInitializer(~length, f)`\n\n  Creates an array of length `length` initialized with the value returned from `f ` for each index.\n\n  ```res example\n  Array.make(~length=3, i => i + 3) == [3, 4, 5]\n  ```"]
    }, 
    {
      "id": "RescriptCore.Array.equal",
      "kind": "value",
      "name": "equal",
      "signature": "let equal: (array<'a>, array<'a>, ('a, 'a) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Array.compare",
      "kind": "value",
      "name": "compare",
      "signature": "let compare: (array<'a>, array<'a>, ('a, 'a) => Core__Ordering.t) => Core__Ordering.t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Array.isArray",
      "kind": "value",
      "name": "isArray",
      "signature": "let isArray: 'a => bool",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Array.length",
      "kind": "value",
      "name": "length",
      "signature": "let length: array<'a> => int",
      "docstrings": ["`length(array)` returns the length of (i.e. number of items in) the array.\n\nSee [`Array.length`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/length) on MDN.\n\n## Examples\n```rescript\nlet someArray = [\"hi\", \"hello\"]\n\nConsole.log(someArray->Array.length) // 2\n```"]
    }, 
    {
      "id": "RescriptCore.Array.copyAllWithin",
      "kind": "value",
      "name": "copyAllWithin",
      "signature": "let copyAllWithin: (array<'a>, ~target: int) => array<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Array.copyWithinToEnd",
      "kind": "value",
      "name": "copyWithinToEnd",
      "signature": "let copyWithinToEnd: (array<'a>, ~target: int, ~start: int) => array<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Array.copyWithin",
      "kind": "value",
      "name": "copyWithin",
      "signature": "let copyWithin: (array<'a>, ~target: int, ~start: int, ~end: int) => array<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Array.fillAll",
      "kind": "value",
      "name": "fillAll",
      "signature": "let fillAll: (array<'a>, 'a) => unit",
      "docstrings": ["`fillAll(array, value)` fills the entire `array` with `value`.\n\nBeware this will *mutate* the array.\n\nSee [`Array.fill`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill) on MDN.\n\n## Examples\n```rescript\nlet myArray = [1, 2, 3, 4]\nmyArray->Array.fillAll(9)\n\nConsole.log(myArray) // [9, 9, 9, 9]\n```"]
    }, 
    {
      "id": "RescriptCore.Array.fillToEnd",
      "kind": "value",
      "name": "fillToEnd",
      "signature": "let fillToEnd: (array<'a>, 'a, ~start: int) => unit",
      "docstrings": ["`fillToEnd(array, value, ~start)` fills `array` with `value` from the `start` index.\n\nBeware this will *mutate* the array.\n\nSee [`Array.fill`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill) on MDN.\n\n## Examples\n```rescript\nlet myArray = [1, 2, 3, 4]\nmyArray->Array.fillToEnd(9, ~start=1)\n\nConsole.log(myArray) // [1, 9, 9, 9]\n```"]
    }, 
    {
      "id": "RescriptCore.Array.fill",
      "kind": "value",
      "name": "fill",
      "signature": "let fill: (array<'a>, 'a, ~start: int, ~end: int) => unit",
      "docstrings": ["`fill(array, value, ~start, ~end)` fills `array` with `value` from `start` to `end`.\n\nBeware this will *mutate* the array.\n\nSee [`Array.fill`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill) on MDN.\n\n## Examples\n```rescript\nlet myArray = [1, 2, 3, 4]\nmyArray->Array.fill(9, ~start=1, ~end=2)\n\nConsole.log(myArray) // [1, 9, 9, 4]\n```"]
    }, 
    {
      "id": "RescriptCore.Array.pop",
      "kind": "value",
      "name": "pop",
      "signature": "let pop: array<'a> => option<'a>",
      "docstrings": ["`pop(array)` removes the last item from `array` and returns it.\n\nBeware this will *mutate* the array.\n\nSee [`Array.pop`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop) on MDN.\n\n## Examples\n```rescript\nlet someArray = [\"hi\", \"hello\"]\nlet lastItem = someArray->Array.pop // \"hello\"\n\nConsole.log(someArray) // [\"hi\"]. Notice last item is gone.\n```"]
    }, 
    {
      "id": "RescriptCore.Array.push",
      "kind": "value",
      "name": "push",
      "signature": "let push: (array<'a>, 'a) => unit",
      "docstrings": ["`push(array, item)` appends `item` to the end of `array`.\n\nBeware this will *mutate* the array.\n\nSee [`Array.push`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push) on MDN.\n\n## Examples\n```rescript\nlet someArray = [\"hi\", \"hello\"]\nsomeArray->Array.push(\"yay\")\n\nConsole.log(someArray) // [\"hi\", \"hello\", \"yay\"]\n```"]
    }, 
    {
      "id": "RescriptCore.Array.pushMany",
      "kind": "value",
      "name": "pushMany",
      "signature": "let pushMany: (array<'a>, array<'a>) => unit",
      "docstrings": ["`pushMany(array, itemsArray)` appends many new items to the end of the array.\n\nBeware this will *mutate* the array.\n\nSee [`Array.push`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push) on MDN.\n\n## Examples\n```rescript\nlet someArray = [\"hi\", \"hello\"]\nsomeArray->Array.pushMany([\"yay\", \"wehoo\"])\n\nConsole.log(someArray) // [\"hi\", \"hello\", \"yay\", \"wehoo\"]\n```"]
    }, 
    {
      "id": "RescriptCore.Array.reverse",
      "kind": "value",
      "name": "reverse",
      "signature": "let reverse: array<'a> => unit",
      "docstrings": ["`reverse(array)` reverses the order of the items in `array`.\n\nBeware this will *mutate* the array.\n\nSee [`Array.reverse`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse) on MDN.\n\n## Examples\n```rescript\nlet someArray = [\"hi\", \"hello\"]\nsomeArray->Array.reverse\n\nConsole.log(someArray) // [\"hello\", \"h1\"]\n```"]
    }, 
    {
      "id": "RescriptCore.Array.shift",
      "kind": "value",
      "name": "shift",
      "signature": "let shift: array<'a> => option<'a>",
      "docstrings": ["`shift(array)` removes the first item in the array, and returns it.\n\nBeware this will *mutate* the array.\n\nSee [`Array.shift`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift) on MDN.\n\n## Examples\n```rescript\nlet someArray = [\"hi\", \"hello\"]\nlet lastItem = someArray->Array.shift // \"hi\"\n\nConsole.log(someArray) // [\"hello\"]. Notice first item is gone.\n```"]
    }, 
    {
      "id": "RescriptCore.Array.toSorted",
      "kind": "value",
      "name": "toSorted",
      "signature": "let toSorted: (array<'a>, ('a, 'a) => Core__Ordering.t) => array<'a>",
      "docstrings": ["`toSorted(array, comparator)` returns a new, sorted array from `array`, using the `comparator` function.\n\nSee [`Array.toSorted`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSorted) on MDN.\n\n## Examples\n```rescript\nlet someArray = [3, 2, 1]\nlet sorted = someArray->Array.toSorted(Int.compare)\n\nConsole.log(sorted) // [1, 2, 3]\nConsole.log(someArray) // [3, 2, 1]. Original unchanged\n```"]
    }, 
    {
      "id": "RescriptCore.Array.sort",
      "kind": "value",
      "name": "sort",
      "signature": "let sort: (array<'a>, ('a, 'a) => Core__Ordering.t) => unit",
      "docstrings": ["`sort(array, comparator)` sorts `array` in-place using the `comparator` function.\n\nBeware this will *mutate* the array.\n\nSee [`Array.sort`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) on MDN.\n\n## Examples\n```rescript\nlet someArray = [3, 2, 1]\nsomeArray->Array.sort((a, b) => float(a - b))\n\nConsole.log(someArray) // [1, 2, 3]\n```"]
    }, 
    {
      "id": "RescriptCore.Array.splice",
      "kind": "value",
      "name": "splice",
      "signature": "let splice: (array<'a>, ~start: int, ~remove: int, ~insert: array<'a>) => unit",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Array.toSpliced",
      "kind": "value",
      "name": "toSpliced",
      "signature": "let toSpliced: (array<'a>, ~start: int, ~remove: int, ~insert: array<'a>) => array<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Array.with",
      "kind": "value",
      "name": "with",
      "signature": "let with: (array<'a>, int, 'a) => array<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Array.unshift",
      "kind": "value",
      "name": "unshift",
      "signature": "let unshift: (array<'a>, 'a) => unit",
      "docstrings": ["`unshift(array, item)` inserts a new item at the start of the array.\n\nBeware this will *mutate* the array.\n\nSee [`Array.unshift`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift) on MDN.\n\n## Examples\n```rescript\nlet someArray = [\"hi\", \"hello\"]\nsomeArray->Array.unshift(\"yay\")\n\nConsole.log(someArray) // [\"yay\", \"hi\", \"hello\"]\n```"]
    }, 
    {
      "id": "RescriptCore.Array.unshiftMany",
      "kind": "value",
      "name": "unshiftMany",
      "signature": "let unshiftMany: (array<'a>, array<'a>) => unit",
      "docstrings": ["`unshiftMany(array, itemsArray)` inserts many new items to the start of the array.\n\nBeware this will *mutate* the array.\n\nSee [`Array.push`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift) on MDN.\n\n## Examples\n```rescript\nlet someArray = [\"hi\", \"hello\"]\nsomeArray->Array.unshiftMany([\"yay\", \"wehoo\"])\n\nConsole.log(someArray) // [\"yay\", \"wehoo\", \"hi\", \"hello\"]\n```"]
    }, 
    {
      "id": "RescriptCore.Array.concat",
      "kind": "value",
      "name": "concat",
      "signature": "let concat: (array<'a>, array<'a>) => array<'a>",
      "docstrings": ["`concat(array1, array2)` concatenates the two arrays, creating a new array.\n\nSee [`Array.concat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat) on MDN.\n\n## Examples\n```rescript\nlet array1 = [\"hi\", \"hello\"]\nlet array2 = [\"yay\", \"wehoo\"]\n\nlet someArray = array1->Array.concat(array2)\n\nConsole.log(someArray) // [\"hi\", \"hello\", \"yay\", \"wehoo\"]\n```"]
    }, 
    {
      "id": "RescriptCore.Array.concatMany",
      "kind": "value",
      "name": "concatMany",
      "signature": "let concatMany: (array<'a>, array<array<'a>>) => array<'a>",
      "docstrings": ["`concatMany(array1, arrays)` concatenates array1 with several other arrays, creating a new array.\n\nSee [`Array.concat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat) on MDN.\n\n## Examples\n```rescript\nlet array1 = [\"hi\", \"hello\"]\nlet array2 = [\"yay\"]\nlet array3 = [\"wehoo\"]\n\nlet someArray = array1->Array.concatMany([array2, array3])\n\nConsole.log(someArray) // [\"hi\", \"hello\", \"yay\", \"wehoo\"]\n```"]
    }, 
    {
      "id": "RescriptCore.Array.flat",
      "kind": "value",
      "name": "flat",
      "signature": "let flat: array<array<'a>> => array<'a>",
      "docstrings": ["`flat(arrays)` concatenates an array of arrays into a single array.\n\nSee [`Array.flat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat) on MDN.\n\n## Examples\n```rescript\nConsole.log([[1], [2], [3, 4]]->Array.flat) // [1, 2, 3, 4]\n```"]
    }, 
    {
      "id": "RescriptCore.Array.includes",
      "kind": "value",
      "name": "includes",
      "signature": "let includes: (array<'a>, 'a) => bool",
      "docstrings": ["`includes(array, item)` checks whether `array` includes `item`, by doing a [strict check for equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality).\n\nSee [`Array.includes`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes) on MDN.\n\n## Examples\n```rescript\nConsole.log([1, 2]->Array.includes(1)) // true\nConsole.log([1, 2]->Array.includes(3)) // false\nConsole.log([{\"language\": \"ReScript\"}]->Array.includes({\"language\": \"ReScript\"})) // false, because of strict equality\n```"]
    }, 
    {
      "id": "RescriptCore.Array.indexOf",
      "kind": "value",
      "name": "indexOf",
      "signature": "let indexOf: (array<'a>, 'a) => int",
      "docstrings": ["`indexOf(array, item)` returns the index of the provided `item` in `array`. Uses [strict check for equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality) when comparing items.\n\nReturns `-1` if the item doesn not exist. Check out `Array.indexOfOpt` for a version that returns `None` instead of `-1` if the item does not exist.\n\nSee [`Array.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) on MDN.\n\n## Examples\n```rescript\nConsole.log([1, 2]->Array.indexOf(2)) // 1\nConsole.log([1, 2]->Array.indexOf(3)) // -1\nConsole.log([{\"language\": \"ReScript\"}]->Array.indexOf({\"language\": \"ReScript\"})) // -1, because of strict equality\n```"]
    }, 
    {
      "id": "RescriptCore.Array.indexOfOpt",
      "kind": "value",
      "name": "indexOfOpt",
      "signature": "let indexOfOpt: (array<'a>, 'a) => option<int>",
      "docstrings": ["`indexOfOpt(array, item)` returns an option of the index of the provided `item` in `array`. Uses [strict check for equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality) when comparing items.\n\nSee [`Array.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) on MDN.\n\n## Examples\n```rescript\nConsole.log([1, 2]->Array.indexOfOpt(2)) // Some(1)\nConsole.log([1, 2]->Array.indexOfOpt(3)) // None\nConsole.log([{\"language\": \"ReScript\"}]->Array.indexOfOpt({\"language\": \"ReScript\"})) // None, because of strict equality\n```"]
    }, 
    {
      "id": "RescriptCore.Array.indexOfFrom",
      "kind": "value",
      "name": "indexOfFrom",
      "signature": "let indexOfFrom: (array<'a>, 'a, int) => int",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Array.joinWith",
      "kind": "value",
      "name": "joinWith",
      "signature": "let joinWith: (array<'a>, string) => string",
      "docstrings": ["`joinWith(array, separator)` produces a string where all items of `array` are printed, separated by `separator`. Under the hood this will run JavaScript's `toString` on all the array items.\n\n## Examples\n```rescript\nlet array = [1, 2, 3]\n\nConsole.log(array->Array.joinWith(\" -- \")) // 1 -- 2 -- 3\n```"]
    }, 
    {
      "id": "RescriptCore.Array.lastIndexOf",
      "kind": "value",
      "name": "lastIndexOf",
      "signature": "let lastIndexOf: (array<'a>, 'a) => int",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Array.lastIndexOfOpt",
      "kind": "value",
      "name": "lastIndexOfOpt",
      "signature": "let lastIndexOfOpt: (array<'a>, 'a) => option<int>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Array.lastIndexOfFrom",
      "kind": "value",
      "name": "lastIndexOfFrom",
      "signature": "let lastIndexOfFrom: (array<'a>, 'a, int) => int",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Array.slice",
      "kind": "value",
      "name": "slice",
      "signature": "let slice: (array<'a>, ~start: int, ~end: int) => array<'a>",
      "docstrings": ["`slice(array, ~start, ~end)` creates a new array of items copied from `array` from `start` until (but not including) `end`.\n\nSee [`Array.slice`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice) on MDN.\n\n## Examples\n```rescript\nlet myArray = [1, 2, 3, 4]\n\nConsole.log(myArray->Array.slice(~start=1, ~end=3)) // [2, 3]\n```"]
    }, 
    {
      "id": "RescriptCore.Array.sliceToEnd",
      "kind": "value",
      "name": "sliceToEnd",
      "signature": "let sliceToEnd: (array<'a>, ~start: int) => array<'a>",
      "docstrings": ["`sliceToEnd(array, start)` creates a new array from `array`, with all items from `array` starting from `start`.\n\nSee [`Array.slice`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice) on MDN.\n\n## Examples\n```rescript\nlet myArray = [1, 2, 3, 4]\n\nConsole.log(myArray->Array.sliceToEnd(~start=1)) // [2, 3, 4]\n```"]
    }, 
    {
      "id": "RescriptCore.Array.copy",
      "kind": "value",
      "name": "copy",
      "signature": "let copy: array<'a> => array<'a>",
      "docstrings": ["`copy(array)` makes a copy of the array with the items in it, but does not make copies of the items themselves.\n\n## Examples\n```rescript\nlet myArray = [1, 2, 3]\nlet copyOfMyArray = myArray->Array.copy\n\nConsole.log(copyOfMyArray) // [1, 2, 3]\nConsole.log(myArray === copyOfMyArray) // false\n```"]
    }, 
    {
      "id": "RescriptCore.Array.toString",
      "kind": "value",
      "name": "toString",
      "signature": "let toString: array<'a> => string",
      "docstrings": ["`toString(array)` stringifies `array` by running `toString` on all of the array elements and joining them with \",\".\n\nSee [`Array.toString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString) on MDN.\n\n## Examples\n```rescript\nlet array = [1, 2, 3, 4]\n\nConsole.log(array->Array.toString) // \"1,2,3,4\"\n```"]
    }, 
    {
      "id": "RescriptCore.Array.toLocaleString",
      "kind": "value",
      "name": "toLocaleString",
      "signature": "let toLocaleString: array<'a> => string",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Array.every",
      "kind": "value",
      "name": "every",
      "signature": "let every: (array<'a>, 'a => bool) => bool",
      "docstrings": ["`every(array, predicate)` returns true if `predicate` returns true for all items in `array`.\n\nSee [`Array.every`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every) on MDN.\n\n## Examples\n```rescript\nlet array = [1, 2, 3, 4]\n\nConsole.log(array->Array.every(num => num > 4)) // true\nConsole.log(array->Array.every(num => num === 1)) // false\n```"]
    }, 
    {
      "id": "RescriptCore.Array.everyWithIndex",
      "kind": "value",
      "name": "everyWithIndex",
      "signature": "let everyWithIndex: (array<'a>, ('a, int) => bool) => bool",
      "docstrings": ["`everyWithIndex(array, checker)` returns true if all items in `array` returns true when running the provided `checker` function.\n\nSee [`Array.every`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every) on MDN.\n\n## Examples\n```rescript\nlet array = [1, 2, 3, 4]\n\nConsole.log(array->Array.everyWithIndex((num, index) => index < 2 && num <= 2)) // true\nConsole.log(array->Array.everyWithIndex((num, index) => index < 2 && num >= 2)) // false\n```"]
    }, 
    {
      "id": "RescriptCore.Array.filter",
      "kind": "value",
      "name": "filter",
      "signature": "let filter: (array<'a>, 'a => bool) => array<'a>",
      "docstrings": ["`filter(array, checker)` returns a new array containing all elements from `array` for which the provided `checker` function returns true.\n\nSee [`Array.filter`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) on MDN.\n\n## Examples\n```rescript\nlet array = [1, 2, 3, 4]\n\nConsole.log(array->Array.filter(num => num > 2)) // [3, 4]\n```"]
    }, 
    {
      "id": "RescriptCore.Array.filterWithIndex",
      "kind": "value",
      "name": "filterWithIndex",
      "signature": "let filterWithIndex: (array<'a>, ('a, int) => bool) => array<'a>",
      "docstrings": ["`filterWithIndex(array, checker)` returns a new array containing all elements from `array` for which the provided `checker` function returns true.\n\nSee [`Array.filter`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) on MDN.\n\n## Examples\n```rescript\nlet array = [1, 2, 3, 4]\n\nConsole.log(array->Array.filterWithIndex((num, index) => index === 0 || num === 2)) // [1, 2]\n```"]
    }, 
    {
      "id": "RescriptCore.Array.find",
      "kind": "value",
      "name": "find",
      "signature": "let find: (array<'a>, 'a => bool) => option<'a>",
      "docstrings": ["`find(array, checker)` returns the first element of `array` where the provided `checker` function returns true.\n\nSee [`Array.find`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find) on MDN.\n\n## Examples\n```rescript\ntype languages = ReScript | TypeScript | JavaScript\n\nlet array = [ReScript, TypeScript, JavaScript]\n\nswitch array->Array.find(item => item == ReScript) {\n| None => Console.log(\"No item...\")\n| Some(_) => Console.log(\"Yay, ReScript!\")\n}\n```"]
    }, 
    {
      "id": "RescriptCore.Array.findWithIndex",
      "kind": "value",
      "name": "findWithIndex",
      "signature": "let findWithIndex: (array<'a>, ('a, int) => bool) => option<'a>",
      "docstrings": ["`findWithIndex(array, checker)` returns the first element of `array` where the provided `checker` function returns true.\n\nSee [`Array.find`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find) on MDN.\n\n## Examples\n```rescript\ntype languages = ReScript | TypeScript | JavaScript\n\nlet array = [TypeScript, JavaScript, ReScript]\n\nswitch array->Array.findWithIndex((item, index) => index > 1 && item == ReScript) {\n| None => Console.log(\"No item...\")\n| Some(_) => Console.log(\"Yay, ReScript exists in a later position!\")\n}\n```"]
    }, 
    {
      "id": "RescriptCore.Array.findIndex",
      "kind": "value",
      "name": "findIndex",
      "signature": "let findIndex: (array<'a>, 'a => bool) => int",
      "docstrings": ["`findIndex(array, checker)` returns the index of the first element of `array` where the provided `checker` function returns true.\n\nReturns `-1` if the item does not exist. Consider using `Array.findIndexOpt` if you want an option instead (where `-1` would be `None`).\n\nSee [`Array.findIndex`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex) on MDN.\n\n## Examples\n```rescript\ntype languages = ReScript | TypeScript | JavaScript\n\nlet array = [ReScript, JavaScript]\n\nConsole.log(array->Array.findIndex(item => item == ReScript)) // 0\nConsole.log(array->Array.findIndex(item => item == TypeScript)) // -1\n```"]
    }, 
    {
      "id": "RescriptCore.Array.findIndexWithIndex",
      "kind": "value",
      "name": "findIndexWithIndex",
      "signature": "let findIndexWithIndex: (array<'a>, ('a, int) => bool) => int",
      "docstrings": ["`findIndexWithIndex(array, checker)` returns the index of the first element of `array` where the provided `checker` function returns true.\n\nReturns `-1` if the item does not exist. Consider using `Array.findIndexOpt` if you want an option instead (where `-1` would be `None`).\n\nSee [`Array.findIndex`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex) on MDN.\n\n## Examples\n```rescript\ntype languages = ReScript | TypeScript | JavaScript\n\nlet array = [ReScript, JavaScript]\n\nConsole.log(array->Array.findIndexWithIndex((item, index) => index === 0 && item == ReScript)) // 0\nConsole.log(array->Array.findIndex((item, index) => index === 0 && item == TypeScript)) // -1\n```"]
    }, 
    {
      "id": "RescriptCore.Array.forEach",
      "kind": "value",
      "name": "forEach",
      "signature": "let forEach: (array<'a>, 'a => unit) => unit",
      "docstrings": ["`forEach(array, fn)` runs the provided `fn` on every element of `array`.\n\nSee [`Array.forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) on MDN.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\n\narray->Array.forEach(item => {\n  Console.log(item)\n})\n```"]
    }, 
    {
      "id": "RescriptCore.Array.forEachWithIndex",
      "kind": "value",
      "name": "forEachWithIndex",
      "signature": "let forEachWithIndex: (array<'a>, ('a, int) => unit) => unit",
      "docstrings": ["`forEachWithIndex(array, fn)` runs the provided `fn` on every element of `array`.\n\nSee [`Array.forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) on MDN.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\n\narray->Array.forEachWithIndex((item, index) => {\n  Console.log(\"At item \" ++ Int.toString(index) ++ \": \" ++ item)\n})\n```"]
    }, 
    {
      "id": "RescriptCore.Array.map",
      "kind": "value",
      "name": "map",
      "signature": "let map: (array<'a>, 'a => 'b) => array<'b>",
      "docstrings": ["`map(array, fn)` returns a new array with all elements from `array`, each element transformed using the provided `fn`.\n\nSee [`Array.map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) on MDN.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\nlet mappedArray = array->Array.map(greeting => greeting ++ \" to you\")\n\nConsole.log(mappedArray) // [\"Hello to you\", \"Hi to you\", \"Good bye to you\"]\n```"]
    }, 
    {
      "id": "RescriptCore.Array.mapWithIndex",
      "kind": "value",
      "name": "mapWithIndex",
      "signature": "let mapWithIndex: (array<'a>, ('a, int) => 'b) => array<'b>",
      "docstrings": ["`mapWithIndex(array, fn)` returns a new array with all elements from `array`, each element transformed using the provided `fn`.\n\nSee [`Array.map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) on MDN.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\nlet mappedArray =\n  array->Array.mapWithIndex((greeting, index) =>\n    greeting ++ \" at position \" ++ Int.toString(index)\n  )\n\nConsole.log(mappedArray) // [\"Hello at position 0\", \"Hi at position 1\", \"Good bye at position 2\"]\n```"]
    }, 
    {
      "id": "RescriptCore.Array.reduce",
      "kind": "value",
      "name": "reduce",
      "signature": "let reduce: (array<'a>, 'b, ('b, 'a) => 'b) => 'b",
      "docstrings": ["`reduce(xs, f, init)`\n\n  Applies `f` to each element of `xs` from beginning to end. Function `f` has two parameters: the item from the list and an “accumulator”; which starts with a value of `init`. `reduce` returns the final value of the accumulator.\n\n  ```res example\n  Array.reduce([2, 3, 4], (a, b) => a + b, 1) == 10\n\n  Array.reduce([\"a\", \"b\", \"c\", \"d\"], (a, b) => a ++ b, \"\") == \"abcd\"\n  ```"]
    }, 
    {
      "id": "RescriptCore.Array.reduceWithIndex",
      "kind": "value",
      "name": "reduceWithIndex",
      "signature": "let reduceWithIndex: (array<'a>, 'b, ('b, 'a, int) => 'b) => 'b",
      "docstrings": ["`reduceWithIndex(xs, f, init)`\n\n  Applies `f` to each element of `xs` from beginning to end. Function `f` has three parameters: the item from the array and an “accumulator”, which starts with a value of `init` and the index of each element. `reduceWithIndex` returns the final value of the accumulator.\n\n  ```res example\n  Array.reduceWithIndex([1, 2, 3, 4], (acc, x, i) => acc + x + i, 0) == 16\n  ```"]
    }, 
    {
      "id": "RescriptCore.Array.reduceRight",
      "kind": "value",
      "name": "reduceRight",
      "signature": "let reduceRight: (array<'a>, 'b, ('b, 'a) => 'b) => 'b",
      "docstrings": ["`reduceRight(xs, f, init)`\n\n  Works like `Array.reduce`; except that function `f` is applied to each item of `xs` from the last back to the first.\n\n  ```res example\n  Array.reduceRight([\"a\", \"b\", \"c\", \"d\"], (a, b) => a ++ b, \"\") == \"dcba\"\n  ```"]
    }, 
    {
      "id": "RescriptCore.Array.reduceRightWithIndex",
      "kind": "value",
      "name": "reduceRightWithIndex",
      "signature": "let reduceRightWithIndex: (array<'a>, 'b, ('b, 'a, int) => 'b) => 'b",
      "docstrings": ["`reduceRightWithIndex(xs, f, init)`\n\n  Like `reduceRight`, but with an additional index argument on the callback function.\n\n  ```res example\n  Array.reduceRightWithIndex([1, 2, 3, 4], (acc, x, i) => acc + x + i, 0) == 16\n  ```"]
    }, 
    {
      "id": "RescriptCore.Array.some",
      "kind": "value",
      "name": "some",
      "signature": "let some: (array<'a>, 'a => bool) => bool",
      "docstrings": ["`some(array, predicate)` returns true if `predicate` returns true for any element in `array`.\n\nSee [`Array.some`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some) on MDN.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\n\nConsole.log(array->Array.some(greeting => greeting === \"Hello\")) // true\n```"]
    }, 
    {
      "id": "RescriptCore.Array.someWithIndex",
      "kind": "value",
      "name": "someWithIndex",
      "signature": "let someWithIndex: (array<'a>, ('a, int) => bool) => bool",
      "docstrings": ["`someWithIndex(array, checker)` returns true if running the provided `checker` function on any element in `array` returns true.\n\nSee [`Array.some`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some) on MDN.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\n\nConsole.log(array->Array.someWithIndex((greeting, index) => greeting === \"Hello\" && index === 0)) // true\n```"]
    }, 
    {
      "id": "RescriptCore.Array.get",
      "kind": "value",
      "name": "get",
      "signature": "let get: (array<'a>, int) => option<'a>",
      "docstrings": ["`get(array, index)` returns the element at `index` of `array`.\n\nReturns `None` if the index does not exist in the array. Equivalent to doing `array[index]` in JavaScript.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\n\narray->Array.get(0) == Some(\"Hello\") // true\n```"]
    }, 
    {
      "id": "RescriptCore.Array.set",
      "kind": "value",
      "name": "set",
      "signature": "let set: (array<'a>, int, 'a) => unit",
      "docstrings": ["`set(array, index, item)` sets the provided `item` at `index` of `array`.\n\nBeware this will *mutate* the array.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\narray->Array.set(1, \"Hello\")\n\nConsole.log(array[1]) // \"Hello\"\n```"]
    }, 
    {
      "id": "RescriptCore.Array.getSymbol",
      "kind": "value",
      "name": "getSymbol",
      "signature": "let getSymbol: (array<'a>, Core__Symbol.t) => option<'b>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Array.getSymbolUnsafe",
      "kind": "value",
      "name": "getSymbolUnsafe",
      "signature": "let getSymbolUnsafe: (array<'a>, Core__Symbol.t) => 'b",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Array.setSymbol",
      "kind": "value",
      "name": "setSymbol",
      "signature": "let setSymbol: (array<'a>, Core__Symbol.t, 'b) => unit",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Array.getUnsafe",
      "kind": "value",
      "name": "getUnsafe",
      "signature": "let getUnsafe: (array<'a>, int) => 'a",
      "docstrings": ["`getUnsafe(array, index)` returns the element at `index` of `array`.\n\nThis is _unsafe_, meaning it will fail with an exception if `index` does not exist in `array`.\n\n## Exceptions\n\n- `Not_found`: If the provided `index` does not exist in `array`.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\n\nConsole.log(array->Array.getUnsafe(0)) // \"Hello\"\nConsole.log(array->Array.getUnsafe(3)) // Fails and raises exception\n```"]
    }, 
    {
      "id": "RescriptCore.Array.setUnsafe",
      "kind": "value",
      "name": "setUnsafe",
      "signature": "let setUnsafe: (array<'a>, int, 'a) => unit",
      "docstrings": ["`setUnsafe(array, index, item)` sets the provided `item` at `index` of `array`.\n\nBeware this will *mutate* the array, and is *unsafe*.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\narray->Array.setUnsafe(1, \"Hello\")\n\nConsole.log(array[1]) // \"Hello\"\n```"]
    }, 
    {
      "id": "RescriptCore.Array.findIndexOpt",
      "kind": "value",
      "name": "findIndexOpt",
      "signature": "let findIndexOpt: (array<'a>, 'a => bool) => option<int>",
      "docstrings": ["`findIndexOpt(array, checker)` returns the index of the first element of `array` where the provided `checker` function returns true.\n\nReturns `None` if no item matches.\n\nSee [`Array.findIndex`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex) on MDN.\n\n## Examples\n```rescript\ntype languages = ReScript | TypeScript | JavaScript\n\nlet array = [ReScript, TypeScript, JavaScript]\n\nswitch array->Array.findIndexOpt(item => item == ReScript) {\n| None => Console.log(\"Ahh, no ReScript...\")\n| Some(index) => Console.log(\"Yay, ReScript at index \" ++ Int.toString(index))\n}\n```"]
    }, 
    {
      "id": "RescriptCore.Array.toReversed",
      "kind": "value",
      "name": "toReversed",
      "signature": "let toReversed: array<'a> => array<'a>",
      "docstrings": ["`toReversed(array)` creates a new array with all items from `array` in reversed order.\n\nSee [`Array.toReversed`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toReversed) on MDN.\n\n## Examples\n```rescript\nlet someArray = [\"hi\", \"hello\"]\nlet reversed = someArray->Array.toReversed\n\nConsole.log(reversed) // [\"hello\", \"h1\"]\nConsole.log(someArray) // [\"h1\", \"hello\"]. Original unchanged\n```"]
    }, 
    {
      "id": "RescriptCore.Array.filterMap",
      "kind": "value",
      "name": "filterMap",
      "signature": "let filterMap: (array<'a>, 'a => option<'b>) => array<'b>",
      "docstrings": ["`get(array, index)` returns the element at `index` of `array`.\n\nReturns `None` if the index does not exist in the array. Equivalent to doing `array[index]` in JavaScript.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\n\nConsole.log(\n  array->Array.filterMap(item =>\n    switch item {\n    | \"Hello\" => Some(item->String.length)\n    | _ => None\n    }\n  ),\n)\n// [5]\n```"]
    }, 
    {
      "id": "RescriptCore.Array.keepSome",
      "kind": "value",
      "name": "keepSome",
      "signature": "let keepSome: array<option<'a>> => array<'a>",
      "docstrings": ["`keepSome(arr)`\n\n  Returns a new array containing `value` for all elements that are `Some(value)`\n  and ignoring every value that is `None`\n\n  ```res example\n  Array.keepSome([Some(1), None, Some(3)]) == [1, 3]\n  ```"]
    }, 
    {
      "id": "RescriptCore.Array.toShuffled",
      "kind": "value",
      "name": "toShuffled",
      "signature": "let toShuffled: array<'a> => array<'a>",
      "docstrings": ["`toShuffled(array)` returns a new array with all items in `array` in a random order.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\nlet shuffledArray = array->Array.toShuffled\n\nConsole.log(shuffledArray)\n```"]
    }, 
    {
      "id": "RescriptCore.Array.shuffle",
      "kind": "value",
      "name": "shuffle",
      "signature": "let shuffle: array<'a> => unit",
      "docstrings": ["`shuffle(array)` randomizes the position of all items in `array`.\n\nBeware this will *mutate* the array.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\narray->Array.shuffle\n\nConsole.log(array)\n```"]
    }, 
    {
      "id": "RescriptCore.Array.flatMap",
      "kind": "value",
      "name": "flatMap",
      "signature": "let flatMap: (array<'a>, 'a => array<'b>) => array<'b>",
      "docstrings": ["`flatMap(array, mapper)` returns a new array concatenating the arrays returned from running `mapper` on all items in `array`.\n\n## Examples\n```rescript\ntype language = ReScript | TypeScript | JavaScript\n\nlet array = [ReScript, TypeScript, JavaScript]\n\nConsole.log(\n  array->Array.flatMap(item =>\n    switch item {\n    | ReScript => [1, 2, 3]\n    | TypeScript => [4, 5, 6]\n    | JavaScript => [7, 8, 9]\n    }\n  ),\n)\n// [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```"]
    }, 
    {
      "id": "RescriptCore.Array.findMap",
      "kind": "value",
      "name": "findMap",
      "signature": "let findMap: (array<'a>, 'a => option<'b>) => option<'b>",
      "docstrings": ["`findMap(arr, f)`\n\n  Calls `f` for each element and returns the first value from `f` that is `Some(_)`.\n  Otherwise returns `None`\n\n  ```res example\n  Array.findMap([1, 2, 3], n => mod(n, 2) ? Some(n - 2) : None) == 0\n  ```"]
    }, 
    {
      "id": "RescriptCore.Array.at",
      "kind": "value",
      "name": "at",
      "signature": "let at: (array<'a>, int) => option<'a>",
      "docstrings": ["`at(array, index)`\n\n  Get an element by its index. Negative indices count backwards from the last item.\n\n  ## Examples\n  ```rescript\n  [\"a\", \"b\", \"c\"]->Array.at(0) // Some(\"a\")\n  [\"a\", \"b\", \"c\"]->Array.at(2) // Some(\"c\")\n  [\"a\", \"b\", \"c\"]->Array.at(3) // None\n  [\"a\", \"b\", \"c\"]->Array.at(-1) // Some(\"c\")\n  [\"a\", \"b\", \"c\"]->Array.at(-3) // Some(\"a\")\n  [\"a\", \"b\", \"c\"]->Array.at(-4) // None\n  ```"]
    }]
  }, 
  {
    "id": "RescriptCore.Console",
    "kind": "moduleAlias",
    "name": "Console",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Console.assert_",
      "kind": "value",
      "name": "assert_",
      "signature": "let assert_: (bool, 'a) => unit",
      "docstrings": ["`assert_(assertion, value)` print a message to console if `assertion` evaluates `false`. Does nothing if it's `true`.\n\nSee [`console.assert`](https://developer.mozilla.org/en-US/docs/Web/API/console/assert)\non MDN.\n\n## Examples\n\n```rescript\nConsole.assert_(false, \"Hello World!\")\nConsole.assert_(n == 42, \"The answer\")\n```"]
    }, 
    {
      "id": "RescriptCore.Console.assert2",
      "kind": "value",
      "name": "assert2",
      "signature": "let assert2: (bool, 'a, 'b) => unit",
      "docstrings": ["`assert2(v1, v2)`. Like `assert_`, but with two arguments.\n\n## Examples\n\n```rescript\nConsole.assert2(false, \"Hello\", \"World\")\nConsole.assert2(n == 42, [1, 2, 3], '4')\n```"]
    }, 
    {
      "id": "RescriptCore.Console.assert3",
      "kind": "value",
      "name": "assert3",
      "signature": "let assert3: (bool, 'a, 'b, 'c) => unit",
      "docstrings": ["`assert3(v1, v2, v3)`. Like `assert_`, but with three arguments.\n\n## Examples\n\n```rescript\nConsole.assert3(false, \"Hello\", \"World\", \"ReScript\")\nConsole.assert3(n == 42, \"One\", 2, #3)\n```"]
    }, 
    {
      "id": "RescriptCore.Console.assert4",
      "kind": "value",
      "name": "assert4",
      "signature": "let assert4: (bool, 'a, 'b, 'c, 'd) => unit",
      "docstrings": ["`assert4(v1, v2, v3, v4)`. Like `assert_`, but with four arguments.\n\n## Examples\n\n```rescript\nConsole.assert4(false, \"Hello\", \"World\", \"ReScript\", \"!!!\")\nConsole.assert4(m == 42, [1, 2], (3, 4), [#5, #6], #\"polyvar\")\n```"]
    }, 
    {
      "id": "RescriptCore.Console.assert5",
      "kind": "value",
      "name": "assert5",
      "signature": "let assert5: (bool, 'a, 'b, 'c, 'd, 'e) => unit",
      "docstrings": ["`assert5(v1, v2, v3, v4, v5)`. Like `assert_`, but with five arguments.\n\n## Examples\n\n```rescript\nConsole.assert5(false, \"Hello\", \"World\", \"JS\", '!', '!')\nConsole.assert5(n == 42, [1, 2], (3, 4), [#5, #6], #\"polyvar\", {\"name\": \"ReScript\"})\n```"]
    }, 
    {
      "id": "RescriptCore.Console.assert6",
      "kind": "value",
      "name": "assert6",
      "signature": "let assert6: (bool, 'a, 'b, 'c, 'd, 'e, 'f) => unit",
      "docstrings": ["`assert6(v1, v2)`. Like `assert_`, but with six arguments.\n\n## Examples\n\n```rescript\nConsole.assert6(false, \"Hello\", \"World\", \"JS\", '!', '!', '?')\nConsole.assert6(n == 42, [1, 2], (3, 4), [#5, #6], #\"polyvar\", {\"name\": \"ReScript\"}, 42)\n```"]
    }, 
    {
      "id": "RescriptCore.Console.assertMany",
      "kind": "value",
      "name": "assertMany",
      "signature": "let assertMany: (bool, array<'a>) => unit",
      "docstrings": ["`assertMany(assertion, arr)`. Like `assert_`, but variadic.\n\n## Examples\n\n```rescript\nConsole.assertMany(false, [\"Hello\", \"World\"])\nConsole.assertMany(n == 42, [1, 2, 3])\n```"]
    }, 
    {
      "id": "RescriptCore.Console.clear",
      "kind": "value",
      "name": "clear",
      "signature": "let clear: unit => unit",
      "docstrings": ["`clear()` clears the console, if allowed.\n\nSee [`console.clear`](https://developer.mozilla.org/en-US/docs/Web/API/console/clear)\non MDN.\n\n## Examples\n\n```rescript\nConsole.clear()\n```"]
    }, 
    {
      "id": "RescriptCore.Console.count",
      "kind": "value",
      "name": "count",
      "signature": "let count: string => unit",
      "docstrings": ["`count(label)` prints to the console the number of times it's been called with the given label.\n\nSee [`console.count`](https://developer.mozilla.org/en-US/docs/Web/API/console/count)\non MDN.\n\n## Examples\n\n```rescript\nConsole.count(\"rescript\")\n```"]
    }, 
    {
      "id": "RescriptCore.Console.countReset",
      "kind": "value",
      "name": "countReset",
      "signature": "let countReset: string => unit",
      "docstrings": ["`countReset(label)` resets the count for the given label to 0.\n\nSee [`console.countReset`](https://developer.mozilla.org/en-US/docs/Web/API/console/countReset)\non MDN.\n\n## Examples\n\n```rescript\nConsole.countReset(\"rescript\")\n```"]
    }, 
    {
      "id": "RescriptCore.Console.debug",
      "kind": "value",
      "name": "debug",
      "signature": "let debug: 'a => unit",
      "docstrings": ["`debug(value)` print a debug message to console.\n\nSee [`console.debug`](https://developer.mozilla.org/en-US/docs/Web/API/console/debug)\non MDN.\n\n## Examples\n\n```rescript\nConsole.debug(\"Hello\")\nlet obj = {\"name\": \"ReScript\", \"version\": 10}\nConsole.debug(obj)\n```"]
    }, 
    {
      "id": "RescriptCore.Console.debug2",
      "kind": "value",
      "name": "debug2",
      "signature": "let debug2: ('a, 'b) => unit",
      "docstrings": ["`debug2(v1, v2)`. Like `debug`, but with two arguments.\n\n## Examples\n\n```rescript\nConsole.debug2(\"Hello\", \"World\")\nConsole.debug2([1, 2, 3], '4')\n```"]
    }, 
    {
      "id": "RescriptCore.Console.debug3",
      "kind": "value",
      "name": "debug3",
      "signature": "let debug3: ('a, 'b, 'c) => unit",
      "docstrings": ["`debug3(v1, v2, v3)`. Like `debug`, but with three arguments.\n\n## Examples\n\n```rescript\nConsole.debug3(\"Hello\", \"World\", \"ReScript\")\nConsole.debug3(\"One\", 2, #3)\n```"]
    }, 
    {
      "id": "RescriptCore.Console.debug4",
      "kind": "value",
      "name": "debug4",
      "signature": "let debug4: ('a, 'b, 'c, 'd) => unit",
      "docstrings": ["`debug4(v1, v2, v3, v4)`. Like `debug`, but with four arguments.\n\n## Examples\n\n```rescript\nConsole.debug4(\"Hello\", \"World\", \"ReScript\", \"!!!\")\nConsole.debug4([1, 2], (3, 4), [#5, #6], #\"polyvar\")\n```"]
    }, 
    {
      "id": "RescriptCore.Console.debug5",
      "kind": "value",
      "name": "debug5",
      "signature": "let debug5: ('a, 'b, 'c, 'd, 'e) => unit",
      "docstrings": ["`debug5(v1, v2, v3, v4, v5)`. Like `debug`, but with five arguments.\n\n## Examples\n\n```rescript\nConsole.debug5(\"Hello\", \"World\", \"JS\", '!', '!')\nConsole.debug5([1, 2], (3, 4), [#5, #6], #\"polyvar\", {\"name\": \"ReScript\"})\n```"]
    }, 
    {
      "id": "RescriptCore.Console.debug6",
      "kind": "value",
      "name": "debug6",
      "signature": "let debug6: ('a, 'b, 'c, 'd, 'e, 'f) => unit",
      "docstrings": ["`debug6(v1, v2, v3, v4, v5, v6)`. Like `debug`, but with six arguments.\n\n## Examples\n\n```rescript\nConsole.debug6(\"Hello\", \"World\", \"JS\", '!', '!', '?')\nConsole.debug6([1, 2], (3, 4), [#5, #6], #\"polyvar\", {\"name\": \"ReScript\"}, 42)\n```"]
    }, 
    {
      "id": "RescriptCore.Console.debugMany",
      "kind": "value",
      "name": "debugMany",
      "signature": "let debugMany: array<'a> => unit",
      "docstrings": ["`debugMany(arr)`. Like `debug`, but variadic.\n\n## Examples\n\n```rescript\nConsole.debugMany([\"Hello\", \"World\"])\nConsole.debugMany([1, 2, 3])\n```"]
    }, 
    {
      "id": "RescriptCore.Console.dir",
      "kind": "value",
      "name": "dir",
      "signature": "let dir: 'a => unit",
      "docstrings": ["`dir(object)` displays an interactive view of the object in the console.\n\nSee [`console.dir`](https://developer.mozilla.org/en-US/docs/Web/API/console/dir)\non MDN.\n\n## Examples\n\n```rescript\nConsole.dir({\"language\": \"rescript\", \"version\": 10.1.2})\n```"]
    }, 
    {
      "id": "RescriptCore.Console.dirxml",
      "kind": "value",
      "name": "dirxml",
      "signature": "let dirxml: 'a => unit",
      "docstrings": ["`dirxml(object)` displays an interactive tree view of an XML/HTML element in the console.\n\nSee [`console.dirxml`](https://developer.mozilla.org/en-US/docs/Web/API/console/dirxml)\non MDN."]
    }, 
    {
      "id": "RescriptCore.Console.error",
      "kind": "value",
      "name": "error",
      "signature": "let error: 'a => unit",
      "docstrings": ["`error(value)` prints an error message to console.\n\nSee [`console.error`](https://developer.mozilla.org/en-US/docs/Web/API/console/error)\non MDN.\n\n## Examples\n\n```rescript\nConsole.error(\"error message\")\nConsole.error((\"error\", \"invalid value\"))\n```"]
    }, 
    {
      "id": "RescriptCore.Console.error2",
      "kind": "value",
      "name": "error2",
      "signature": "let error2: ('a, 'b) => unit",
      "docstrings": ["`error(v1, v2)`. Like `error`, but two arguments.\n\n## Examples\n\n```rescript\nConsole.error2(\"Error\", \"here\")\nConsole.error2((\"log\", \"error\"), \"message\")\n```"]
    }, 
    {
      "id": "RescriptCore.Console.error3",
      "kind": "value",
      "name": "error3",
      "signature": "let error3: ('a, 'b, 'c) => unit",
      "docstrings": ["`error3(v1, v2, v3)`. Like `error`, but three arguments.\n\n## Examples\n\n```rescript\nConsole.error3(\"Hello\", \"World\", \"!!!\")\nConsole.error3(#first, #second, #third)\n```"]
    }, 
    {
      "id": "RescriptCore.Console.error4",
      "kind": "value",
      "name": "error4",
      "signature": "let error4: ('a, 'b, 'c, 'd) => unit",
      "docstrings": ["`error4(v1, v2, v3, v4)`. Like `error`, but with four arguments.\n\n## Examples\n\n```rescript\nConsole.error4(\"Hello\", \"World\", \"ReScript\", '!')\nConsole.error4(#first, #second, #third, (\"fourth\"))\n```"]
    }, 
    {
      "id": "RescriptCore.Console.error5",
      "kind": "value",
      "name": "error5",
      "signature": "let error5: ('a, 'b, 'c, 'd, 'e) => unit",
      "docstrings": ["`error5(v1, v2, v3, v4, v5)`. Like `error`, but with five arguments.\n\n## Examples\n\n```rescript\nConsole.error5('e', 'r, 'r', 'o', 'r')\nConsole.error5(1, #second, #third, (\"fourth\"), 'c')\n```"]
    }, 
    {
      "id": "RescriptCore.Console.error6",
      "kind": "value",
      "name": "error6",
      "signature": "let error6: ('a, 'b, 'c, 'd, 'e, 'f) => unit",
      "docstrings": ["`error6(v1, v2, v3, v4, v5, v6)`. Like `error`, but with six arguments.\n\n## Examples\n\n```rescript\nConsole.error6(\"Hello\", \"World\", \"from\", \"JS\", \"!!!\", '!')\nConsole.error6([1, 2], (3, 4), [#5, #6], #\"polyvar\", {\"name\": \"ReScript\"}, 42)\n```"]
    }, 
    {
      "id": "RescriptCore.Console.group",
      "kind": "value",
      "name": "group",
      "signature": "let group: string => unit",
      "docstrings": ["`group(label)` creates a new \"group\" level with the given label.\n\nSee [`console.group`](https://developer.mozilla.org/en-US/docs/Web/API/console/group)\non MDN.\n\n## Example\n\n```rescript\nConsole.group(\"first group\")\nConsole.group(\"second group\")\nConsole.log(\"a message on the second level\")\nConsole.groupEnd()\nConsole.log(\"a message message on the first level\")\nConsole.groupEnd()\n```"]
    }, 
    {
      "id": "RescriptCore.Console.groupCollapsed",
      "kind": "value",
      "name": "groupCollapsed",
      "signature": "let groupCollapsed: string => unit",
      "docstrings": ["`groupCollapsed(label)`. Like `group` but collapses the group initially.\n\nSee [`console.groupCollapsed`](https://developer.mozilla.org/en-US/docs/Web/API/console/groupCollapsed)\non MDN."]
    }, 
    {
      "id": "RescriptCore.Console.groupEnd",
      "kind": "value",
      "name": "groupEnd",
      "signature": "let groupEnd: unit => unit",
      "docstrings": ["`groupEnd()` ends the current group.\n\nSee [`console.groupEnd`](https://developer.mozilla.org/en-US/docs/Web/API/console/groupEnd)\non MDN."]
    }, 
    {
      "id": "RescriptCore.Console.errorMany",
      "kind": "value",
      "name": "errorMany",
      "signature": "let errorMany: array<'a> => unit",
      "docstrings": ["`errorMany(arr)`. Like `error`, but variadic.\n\n## Examples\n\n```rescript\nConsole.errorMany([\"Hello\", \"World\"])\nConsole.errorMany([1, 2, 3])\n```"]
    }, 
    {
      "id": "RescriptCore.Console.info",
      "kind": "value",
      "name": "info",
      "signature": "let info: 'a => unit",
      "docstrings": ["`info(value)` print an informational message to console.\n\nSee [`console.info`](https://developer.mozilla.org/en-US/docs/Web/API/console/info)\non MDN.\n\n## Examples\n\n```rescript\nConsole.info(\"Information\")\nConsole.info((\"Hello\", \"JS\"))\n```"]
    }, 
    {
      "id": "RescriptCore.Console.info2",
      "kind": "value",
      "name": "info2",
      "signature": "let info2: ('a, 'b) => unit",
      "docstrings": ["`info2(v1, v2)`. Like `info`, but with two arguments.\n\n## Examples\n\n```rescript\nConsole.info2(\"Info\", \"failed to download\")\nConsole.info2(#info, {\"name\": \"ReScript\"})\n```"]
    }, 
    {
      "id": "RescriptCore.Console.info3",
      "kind": "value",
      "name": "info3",
      "signature": "let info3: ('a, 'b, 'c) => unit",
      "docstrings": ["`info3(v1, v2, v3)`. Like `info`, but with three arguments.\n\n## Examples\n\n```rescript\nConsole.info3(\"Hello\", \"World\", \"ReScript\")\nConsole.info3([1, 2, 3], #4, #5)\n```"]
    }, 
    {
      "id": "RescriptCore.Console.info4",
      "kind": "value",
      "name": "info4",
      "signature": "let info4: ('a, 'b, 'c, 'd) => unit",
      "docstrings": ["`info4(v1, v2, v3, v4)`. Like `info`, but with four arguments.\n\n## Examples\n\n```rescript\nConsole.info4(\"Hello\", \"World\", \"ReScript\", '!')\nConsole.info4([1, 2, 3], #4, #5, #lastinfo)\n```"]
    }, 
    {
      "id": "RescriptCore.Console.info5",
      "kind": "value",
      "name": "info5",
      "signature": "let info5: ('a, 'b, 'c, 'd, 'e) => unit",
      "docstrings": ["`info5(v1, v2, v3, v4, v5)`. Like `info`, but with five arguments.\n\n## Examples\n\n```rescript\nConsole.info5(\"Hello\", \"World\", \"from\", \"JS\", \"!!!\")\nConsole.info5([1, 2], (3, 4), [#5, #6], #\"polyvar\", {\"name\": \"ReScript\"})\n```"]
    }, 
    {
      "id": "RescriptCore.Console.info6",
      "kind": "value",
      "name": "info6",
      "signature": "let info6: ('a, 'b, 'c, 'd, 'e, 'f) => unit",
      "docstrings": ["`info6(v1, v2, v3, v4, v5, v6)`. Like `info`, but with six arguments.\n\n## Examples\n\n```rescript\nConsole.info6(\"Hello\", \"World\", \"from\", \"JS\", \"!!!\", '!')\nConsole.info6([1, 2], (3, 4), [#5, #6], #\"polyvar\", {\"name\": \"ReScript\"}, 42)\n```"]
    }, 
    {
      "id": "RescriptCore.Console.infoMany",
      "kind": "value",
      "name": "infoMany",
      "signature": "let infoMany: array<'a> => unit",
      "docstrings": ["`infoMany(arr)`. Like `info`, but variadic.\n\n## Examples\n\n```rescript\nConsole.infoMany([\"Hello\", \"World\"])\nConsole.infoMany([1, 2, 3])\n```"]
    }, 
    {
      "id": "RescriptCore.Console.log",
      "kind": "value",
      "name": "log",
      "signature": "let log: 'a => unit",
      "docstrings": ["`log(value)` print a message to console.\n\nSee [`console.log`](https://developer.mozilla.org/en-US/docs/Web/API/console/log)\non MDN.\n\n## Examples\n\n```rescript\nConsole.log(\"Hello\")\nlet obj = {\"name\": \"ReScript\", \"version\": 10}\nConsole.log(obj)\n```"]
    }, 
    {
      "id": "RescriptCore.Console.log2",
      "kind": "value",
      "name": "log2",
      "signature": "let log2: ('a, 'b) => unit",
      "docstrings": ["`log2(v1, v2)`. Like `log`, but with two arguments.\n\n## Examples\n\n```rescript\nConsole.log2(\"Hello\", \"World\")\nConsole.log2([1, 2, 3], '4')\n```"]
    }, 
    {
      "id": "RescriptCore.Console.log3",
      "kind": "value",
      "name": "log3",
      "signature": "let log3: ('a, 'b, 'c) => unit",
      "docstrings": ["`log3(v1, v2, v3)`. Like `log`, but with three arguments.\n\n## Examples\n\n```rescript\nConsole.log3(\"Hello\", \"World\", \"ReScript\")\nConsole.log3(\"One\", 2, #3)\n```"]
    }, 
    {
      "id": "RescriptCore.Console.log4",
      "kind": "value",
      "name": "log4",
      "signature": "let log4: ('a, 'b, 'c, 'd) => unit",
      "docstrings": ["`log4(v1, v2, v3, v4)`. Like `log`, but with four arguments.\n\n## Examples\n\n```rescript\nConsole.log4(\"Hello\", \"World\", \"ReScript\", \"!!!\")\nConsole.log4([1, 2], (3, 4), [#5, #6], #\"polyvar\")\n```"]
    }, 
    {
      "id": "RescriptCore.Console.log5",
      "kind": "value",
      "name": "log5",
      "signature": "let log5: ('a, 'b, 'c, 'd, 'e) => unit",
      "docstrings": ["`log5(v1, v2, v3, v4, v5)`. Like `log`, but with five arguments.\n\n## Examples\n\n```rescript\nConsole.log5(\"Hello\", \"World\", \"JS\", '!', '!')\nConsole.log5([1, 2], (3, 4), [#5, #6], #\"polyvar\", {\"name\": \"ReScript\"})\n```"]
    }, 
    {
      "id": "RescriptCore.Console.log6",
      "kind": "value",
      "name": "log6",
      "signature": "let log6: ('a, 'b, 'c, 'd, 'e, 'f) => unit",
      "docstrings": ["`log6(v1, v2, v3, v4, v5, v6)`. Like `log`, but with six arguments.\n\n## Examples\n\n```rescript\nConsole.log6(\"Hello\", \"World\", \"JS\", '!', '!', '?')\nConsole.log6([1, 2], (3, 4), [#5, #6], #\"polyvar\", {\"name\": \"ReScript\"}, 42)\n```"]
    }, 
    {
      "id": "RescriptCore.Console.logMany",
      "kind": "value",
      "name": "logMany",
      "signature": "let logMany: array<'a> => unit",
      "docstrings": ["`logMany(arr)`. Like `log`, but variadic.\n\n## Examples\n\n```rescript\nConsole.logMany([\"Hello\", \"World\"])\nConsole.logMany([1, 2, 3])\n```"]
    }, 
    {
      "id": "RescriptCore.Console.table",
      "kind": "value",
      "name": "table",
      "signature": "let table: 'a => unit",
      "docstrings": ["`table(object)` displays an tabular view of the object in the console.\n\nSee [`console.table`](https://developer.mozilla.org/en-US/docs/Web/API/console/table)\non MDN.\n\n## Examples\n\n```rescript\nConsole.table({\"language\": \"rescript\", \"version\": 10.1.2})\n```"]
    }, 
    {
      "id": "RescriptCore.Console.time",
      "kind": "value",
      "name": "time",
      "signature": "let time: string => unit",
      "docstrings": ["`time(label)` creates a timer to measure how long an operation takes. `label`\nmust be a unique name. Call `console.timeEnd` with the same `label` to print\noutput time.\n\nSee [`console.time`](https://developer.mozilla.org/en-US/docs/Web/API/console/time)\non MDN.\n\n## Examples\n\n```rescript\nConsole.time(\"for_time\")\nfor x in 3 downto 1 {\n  Console.log(x)\n  Console.timeLog(\"for_time\")\n}\nConsole.timeEnd(\"for_time\")\n```"]
    }, 
    {
      "id": "RescriptCore.Console.timeEnd",
      "kind": "value",
      "name": "timeEnd",
      "signature": "let timeEnd: string => unit",
      "docstrings": ["`timeEnd(label)` stops a timer created by `time`.\n\nSee [`console.timeEnd`](https://developer.mozilla.org/en-US/docs/Web/API/console/timeEnd)\non MDN.\n\n## Examples\n\n```rescript\nConsole.time(\"for_time\")\nfor x in 3 downto 1 {\n  Console.log(x)\n  Console.timeLog(\"for_time\")\n}\nConsole.timeEnd(\"for_time\")\n```"]
    }, 
    {
      "id": "RescriptCore.Console.timeLog",
      "kind": "value",
      "name": "timeLog",
      "signature": "let timeLog: string => unit",
      "docstrings": ["`timeLog(label)` prints the current elapsed time of the given timer to the console.\n\nSee [`console.timeLog`](https://developer.mozilla.org/en-US/docs/Web/API/console/timeLog)\non MDN.\n\n## Examples\n\n```rescript\nConsole.time(\"for_time\")\nfor x in 3 downto 1 {\n  Console.log(x)\n  Console.timeLog(\"for_time\")\n}\nConsole.timeEnd(\"for_time\")\n```"]
    }, 
    {
      "id": "RescriptCore.Console.trace",
      "kind": "value",
      "name": "trace",
      "signature": "let trace: unit => unit",
      "docstrings": ["`trace()` print a stack trace to console.\n\nSee [`console.trace`](https://developer.mozilla.org/en-US/docs/Web/API/console/trace)\non MDN.\n\n## Examples\n\n```rescript\nlet main = () => {\n  Console.trace()\n}\nmain()\n// In the console, the following trace will be displayed:\n// main\n// <anonymous>\n```"]
    }, 
    {
      "id": "RescriptCore.Console.warn",
      "kind": "value",
      "name": "warn",
      "signature": "let warn: 'a => unit",
      "docstrings": ["`warn(value)` print a warning message to console.\n\nSee [`console.warn`](https://developer.mozilla.org/en-US/docs/Web/API/console/warn)\non MDN.\n\n## Examples\n\n```rescript\nConsole.warn(\"Warning\")\nConsole.warn((\"Warning\", \"invalid number\"))\n```"]
    }, 
    {
      "id": "RescriptCore.Console.warn2",
      "kind": "value",
      "name": "warn2",
      "signature": "let warn2: ('a, 'b) => unit",
      "docstrings": ["`warn2(v1, v2)`. Like `warn`, but two arguments.\n\n## Examples\n\n```rescript\nConsole.warn2(\"Hello\", \"World\")\nConsole.warn2([1, 2, 3], 4)\n```"]
    }, 
    {
      "id": "RescriptCore.Console.warn3",
      "kind": "value",
      "name": "warn3",
      "signature": "let warn3: ('a, 'b, 'c) => unit",
      "docstrings": ["`warn3(v1, v2, v3)`. Like `warn`, but three arguments.\n\n## Examples\n\n```rescript\nConsole.warn3(\"Hello\", \"World\", \"ReScript\")\nConsole.warn3([1, 2, 3], #4, #5)\n```"]
    }, 
    {
      "id": "RescriptCore.Console.warn4",
      "kind": "value",
      "name": "warn4",
      "signature": "let warn4: ('a, 'b, 'c, 'd) => unit",
      "docstrings": ["`warn4(v1, v2, v3, v4)`. Like `warn`, but with four arguments.\n\n## Examples\n\n```rescript\nConsole.warn4(\"Hello\", \"World\", \"ReScript\", \"!!!\")\nConsole.warn4(#first, #second, #third, (\"fourth\"))\n```"]
    }, 
    {
      "id": "RescriptCore.Console.warn5",
      "kind": "value",
      "name": "warn5",
      "signature": "let warn5: ('a, 'b, 'c, 'd, 'e) => unit",
      "docstrings": ["`warn5(v1, v2, v3, v4, v5)`. Like `warn`, but with five arguments.\n\n## Examples\n\n```rescript\nConsole.warn5(\"Hello\", \"World\", \"from\", \"JS\", \"!!!\")\nConsole.warn5([1, 2], (3, 4), [#5, #6], #\"polyvar\", {\"name\": \"ReScript\"})\n```"]
    }, 
    {
      "id": "RescriptCore.Console.warn6",
      "kind": "value",
      "name": "warn6",
      "signature": "let warn6: ('a, 'b, 'c, 'd, 'e, 'f) => unit",
      "docstrings": ["`warn6(v1, v2, v3, v4, v5, v6)`. Like `warn`, but with six arguments.\n\n## Examples\n\n```rescript\nConsole.warn6(\"Hello\", \"World\", \"from\", \"JS\", \"!!!\", '!')\nConsole.warn6([1, 2], (3, 4), [#5, #6], #\"polyvar\", {\"name\": \"ReScript\"}, 42)\n```"]
    }, 
    {
      "id": "RescriptCore.Console.warnMany",
      "kind": "value",
      "name": "warnMany",
      "signature": "let warnMany: array<'a> => unit",
      "docstrings": ["`warnMany(arr)`. Like `warn`, but variadic.\n\n## Examples\n\n```rescript\nConsole.warnMany([\"Hello\", \"World\"])\nConsole.warnMany([1, 2, 3])\n```"]
    }]
  }, 
  {
    "id": "RescriptCore.DataView",
    "kind": "moduleAlias",
    "name": "DataView",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.DataView.t",
      "kind": "type",
      "name": "t",
      "signature": "type t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.fromBuffer",
      "kind": "value",
      "name": "fromBuffer",
      "signature": "let fromBuffer: Core__ArrayBuffer.t => t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.fromBufferToEnd",
      "kind": "value",
      "name": "fromBufferToEnd",
      "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.fromBufferWithRange",
      "kind": "value",
      "name": "fromBufferWithRange",
      "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.buffer",
      "kind": "value",
      "name": "buffer",
      "signature": "let buffer: t => Core__ArrayBuffer.t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.byteLength",
      "kind": "value",
      "name": "byteLength",
      "signature": "let byteLength: t => int",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.byteOffset",
      "kind": "value",
      "name": "byteOffset",
      "signature": "let byteOffset: t => int",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.getInt8",
      "kind": "value",
      "name": "getInt8",
      "signature": "let getInt8: t => int",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.getUint8",
      "kind": "value",
      "name": "getUint8",
      "signature": "let getUint8: t => int",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.getInt16",
      "kind": "value",
      "name": "getInt16",
      "signature": "let getInt16: t => int",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.getUint16",
      "kind": "value",
      "name": "getUint16",
      "signature": "let getUint16: t => int",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.getInt32",
      "kind": "value",
      "name": "getInt32",
      "signature": "let getInt32: t => int",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.getUint32",
      "kind": "value",
      "name": "getUint32",
      "signature": "let getUint32: t => int",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.getFloat32",
      "kind": "value",
      "name": "getFloat32",
      "signature": "let getFloat32: t => float",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.getFloat64",
      "kind": "value",
      "name": "getFloat64",
      "signature": "let getFloat64: t => float",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.getBigInt64",
      "kind": "value",
      "name": "getBigInt64",
      "signature": "let getBigInt64: t => Core__BigInt.t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.getBigUint64",
      "kind": "value",
      "name": "getBigUint64",
      "signature": "let getBigUint64: t => Core__BigInt.t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.setInt8",
      "kind": "value",
      "name": "setInt8",
      "signature": "let setInt8: (t, int) => unit",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.setUint8",
      "kind": "value",
      "name": "setUint8",
      "signature": "let setUint8: (t, int) => unit",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.setInt16",
      "kind": "value",
      "name": "setInt16",
      "signature": "let setInt16: (t, int) => unit",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.setUint16",
      "kind": "value",
      "name": "setUint16",
      "signature": "let setUint16: (t, int) => unit",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.setInt32",
      "kind": "value",
      "name": "setInt32",
      "signature": "let setInt32: (t, int) => unit",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.setUint32",
      "kind": "value",
      "name": "setUint32",
      "signature": "let setUint32: (t, int) => unit",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.setFloat32",
      "kind": "value",
      "name": "setFloat32",
      "signature": "let setFloat32: (t, float) => unit",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.setFloat64",
      "kind": "value",
      "name": "setFloat64",
      "signature": "let setFloat64: (t, float) => unit",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.setBigInt64",
      "kind": "value",
      "name": "setBigInt64",
      "signature": "let setBigInt64: (t, Core__BigInt.t) => unit",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.DataView.setBigUint64",
      "kind": "value",
      "name": "setBigUint64",
      "signature": "let setBigUint64: (t, Core__BigInt.t) => unit",
      "docstrings": []
    }]
  }, 
  {
    "id": "RescriptCore.Date",
    "kind": "moduleAlias",
    "name": "Date",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Date.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = Js.Date.t",
      "docstrings": ["A type representing a JavaScript date."]
    }, 
    {
      "id": "RescriptCore.Date.msSinceEpoch",
      "kind": "type",
      "name": "msSinceEpoch",
      "signature": "type msSinceEpoch = float",
      "docstrings": ["Time, in milliseconds, since / until the UNIX epoch (January 1, 1970 00:00:00 UTC).\nPositive numbers represent dates after, negative numbers dates before epoch."]
    }, 
    {
      "id": "RescriptCore.Date.localeOptions",
      "kind": "type",
      "name": "localeOptions",
      "signature": "type localeOptions = {\\n  dateStyle?: [#full | #long | #medium | #short],\\n  timeStyle?: [#full | #long | #medium | #short],\\n  weekday?: [#long | #narrow | #short],\\n  era?: [#long | #narrow | #short],\\n  year?: [#\\\"2-digit\\\" | #numeric],\\n  month?: [\\n    | #\\\"2-digit\\\"\\n    | #long\\n    | #narrow\\n    | #numeric\\n    | #short\\n  ],\\n  day?: [#\\\"2-digit\\\" | #numeric],\\n  hour?: [#\\\"2-digit\\\" | #numeric],\\n  minute?: [#\\\"2-digit\\\" | #numeric],\\n  second?: [#\\\"2-digit\\\" | #numeric],\\n  timeZoneName?: [#long | #short],\\n}",
      "docstrings": ["A type representing date time format options.\n\nNote: There are some properties missing:\n- fractionalSecondDigits\n- dayPeriod\n- calendar\n- numberingSystem\n- localeMatcher\n- timeZone\n- hour12\n- hourCycle\n- formatMatcher\n\nSee full spec at https://tc39.es/ecma402/#datetimeformat-objects"],
      "detail": 
      {
        "kind": "record",
        "items": [{
          "name": "dateStyle",
          "optional": true,
          "docstrings": [],
          "signature": "option<[#full | #long | #medium | #short]>"
        }, {
          "name": "timeStyle",
          "optional": true,
          "docstrings": [],
          "signature": "option<[#full | #long | #medium | #short]>"
        }, {
          "name": "weekday",
          "optional": true,
          "docstrings": [],
          "signature": "option<[#narrow | #long | #short]>"
        }, {
          "name": "era",
          "optional": true,
          "docstrings": [],
          "signature": "option<[#narrow | #long | #short]>"
        }, {
          "name": "year",
          "optional": true,
          "docstrings": [],
          "signature": "option<[#numeric | #\"2-digit\"]>"
        }, {
          "name": "month",
          "optional": true,
          "docstrings": [],
          "signature": "option<[#numeric | #narrow | #\"2-digit\" | #long | #short]>"
        }, {
          "name": "day",
          "optional": true,
          "docstrings": [],
          "signature": "option<[#numeric | #\"2-digit\"]>"
        }, {
          "name": "hour",
          "optional": true,
          "docstrings": [],
          "signature": "option<[#numeric | #\"2-digit\"]>"
        }, {
          "name": "minute",
          "optional": true,
          "docstrings": [],
          "signature": "option<[#numeric | #\"2-digit\"]>"
        }, {
          "name": "second",
          "optional": true,
          "docstrings": [],
          "signature": "option<[#numeric | #\"2-digit\"]>"
        }, {
          "name": "timeZoneName",
          "optional": true,
          "docstrings": [],
          "signature": "option<[#long | #short]>"
        }]
      }
    }, 
    {
      "id": "RescriptCore.Date.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: unit => t",
      "docstrings": ["`make()`\n\nCreates a date object with the current date time as value.\n\n## Examples\n```rescript\nDate.make()\n```"]
    }, 
    {
      "id": "RescriptCore.Date.fromString",
      "kind": "value",
      "name": "fromString",
      "signature": "let fromString: string => t",
      "docstrings": ["`fromString(dateTimeString)`\n\nCreates a date object from given date time string.\nThe string has to be in the ISO 8601 format YYYY-MM-DDTHH:mm:ss.sssZ (https://tc39.es/ecma262/#sec-date-time-string-format).\n\nInvalid date time strings will create invalid dates.\nYou can use the result like any valid date, but many functions like `toString` will return \"Invalid Date\" or functions like `Date.getTime` will return NaN.\n\n## Examples\n```rescript\nDate.fromString(\"2023\")\n// 2023-01-01T00:00:00.000Z\n\nDate.fromString(\"2023-02-20\")\n// 2023-02-20T00:00:00.000Z\n\nDate.fromString(\"2023-02-20T16:40:00.00Z\")\n// 2023-02-20T16:40:00.000Z\n\nDate.fromString(\"\")\n// Invalid Date\n\nDate.fromString(\"\")->getTime\n// NaN\n```"]
    }, 
    {
      "id": "RescriptCore.Date.fromTime",
      "kind": "value",
      "name": "fromTime",
      "signature": "let fromTime: msSinceEpoch => t",
      "docstrings": ["`fromTime(msSinceEpoch)`\n\nCreates a date object from the given time in milliseconds since / until UNIX epoch (January 1, 1970 00:00:00 UTC).\nPositive numbers create dates after epoch, negative numbers create dates before epoch.\n\n## Examples\n```rescript\nDate.fromTime(0.0)\n// 1970-01-01T00:00:00.000Z\n\nDate.fromTime(-86_400_000.0)\n// 1969-12-31T00:00:00.000Z\n\nDate.fromTime(86_400_000.0)\n// 1970-01-02T00:00:00.000Z\n```"]
    }, 
    {
      "id": "RescriptCore.Date.makeWithYM",
      "kind": "value",
      "name": "makeWithYM",
      "signature": "let makeWithYM: (~year: int, ~month: int) => t",
      "docstrings": ["Creates a date object with the given year and month.\nBe aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\nMonths are 0-indexed (0 = January, 11 = December).\nValues, which are out of range, will be carried over to the next bigger unit (s. example).\n\n## Examples\n```rescript\nDate.makeWithYM(~year=2023, ~month=0)\n// 2023-01-01T00:00:00.000Z\n\nDate.makeWithYM(~year=2023, ~month=11)\n// 2023-12-01T00:00:00.000Z\n\nDate.makeWithYM(~year=2023, ~month=12)\n// 2024-01-01T00:00:00.000Z\n\nDate.makeWithYM(~year=2023, ~month=-1)\n// 2022-12-01T00:00:00.000Z\n\n// Note: The output depends on your local time zone.\n// In nodejs you can change it by using the TZ env (`export TZ='Europe/London' && node index.bs.js`)\n\n```"]
    }, 
    {
      "id": "RescriptCore.Date.makeWithYMD",
      "kind": "value",
      "name": "makeWithYMD",
      "signature": "let makeWithYMD: (~year: int, ~month: int, ~date: int) => t",
      "docstrings": ["Creates a date object with the given year, month and date (day of month).\nBe aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\nMonths are 0-indexed (0 = January, 11 = December).\nValues, which are out of range, will be carried over to the next bigger unit (s. example).\n\n## Examples\n```rescript\nDate.makeWithYMD(~year=2023, ~month=1, ~date=20)\n// 2023-02-20T00:00:00.000Z\n\nDate.makeWithYMD(~year=2023, ~month=1, ~date=-1)\n// 2022-11-29T00:00:00.000Z\n\nDate.makeWithYMD(~year=2023, ~month=1, ~date=29)\n// 2023-03-01T00:00:00.000Z\n```"]
    }, 
    {
      "id": "RescriptCore.Date.makeWithYMDH",
      "kind": "value",
      "name": "makeWithYMDH",
      "signature": "let makeWithYMDH: (~year: int, ~month: int, ~date: int, ~hours: int) => t",
      "docstrings": ["Creates a date object with the given year, month, date (day of month) and hours.\nBe aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\nMonths are 0-indexed (0 = January, 11 = December).\nValues, which are out of range, will be carried over to the next bigger unit (s. example).\n\n## Examples\n```rescript\nDate.makeWithYMDH(~year=2023, ~month=1, ~date=20, ~hours=16)\n// 2023-02-20T16:00:00.000Z\n\nDate.makeWithYMDH(~year=2023, ~month=1, ~date=20, ~hours=24)\n// 2023-02-21T00:00:00.000Z\n\nDate.makeWithYMDH(~year=2023, ~month=1, ~date=20, ~hours=-1)\n// 2023-02-19T23:00:00.000Z\n\n// Note: The output depends on your local time zone.\n// In nodejs you can change it by using the TZ env (`export TZ='Europe/London' && node index.bs.js`)\n\n```"]
    }, 
    {
      "id": "RescriptCore.Date.makeWithYMDHM",
      "kind": "value",
      "name": "makeWithYMDHM",
      "signature": "let makeWithYMDHM: (~year: int, ~month: int, ~date: int, ~hours: int, ~minutes: int) => t",
      "docstrings": ["Creates a date object with the given year, month, date (day of month), hours and minutes.\nBe aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\nMonths are 0-indexed (0 = January, 11 = December).\nValues, which are out of range, will be carried over to the next bigger unit (s. example).\n\n## Examples\n```rescript\nDate.makeWithYMDHM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40)\n// 2023-02-20T16:40:00.000Z\n\nDate.makeWithYMDHM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=60)\n// 2023-02-20T17:00:00.000Z\n\nDate.makeWithYMDHM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=-1)\n// 2023-02-20T15:59:00.000Z\n\n// Note: The output depends on your local time zone.\n// In nodejs you can change it by using the TZ env (`export TZ='Europe/London' && node index.bs.js`)\n\n```"]
    }, 
    {
      "id": "RescriptCore.Date.makeWithYMDHMS",
      "kind": "value",
      "name": "makeWithYMDHMS",
      "signature": "let makeWithYMDHMS: (\\n  ~year: int,\\n  ~month: int,\\n  ~date: int,\\n  ~hours: int,\\n  ~minutes: int,\\n  ~seconds: int,\\n) => t",
      "docstrings": ["Creates a date object with the given year, month, date (day of month), hours, minutes and seconds.\nBe aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\nMonths are 0-indexed (0 = January, 11 = December).\nValues, which are out of range, will be carried over to the next bigger unit (s. example).\n\n## Examples\n```rescript\nDate.makeWithYMDHMS(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=0)\n// 2023-02-20T16:40:00.000Z\n\nDate.makeWithYMDHMS(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=60)\n// 2023-02-20T16:41:00.000Z\n\nDate.makeWithYMDHMS(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=-1)\n// 2023-02-20T16:39:59.000Z\n\n// Note: The output depends on your local time zone.\n// In nodejs you can change it by using the TZ env (`export TZ='Europe/London' && node index.bs.js`)\n\n```"]
    }, 
    {
      "id": "RescriptCore.Date.makeWithYMDHMSM",
      "kind": "value",
      "name": "makeWithYMDHMSM",
      "signature": "let makeWithYMDHMSM: (\\n  ~year: int,\\n  ~month: int,\\n  ~date: int,\\n  ~hours: int,\\n  ~minutes: int,\\n  ~seconds: int,\\n  ~milliseconds: int,\\n) => t",
      "docstrings": ["Creates a date object with the given year, month, date (day of month), hours, minutes, seconds and milliseconds.\nBe aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\nMonths are 0-indexed (0 = January, 11 = December).\nValues, which are out of range, will be carried over to the next bigger unit (s. example).\n\n## Examples\n```rescript\nDate.makeWithYMDHMSM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=0, ~milliseconds=0)\n// 2023-02-20T16:40:00.000Z\n\nDate.makeWithYMDHMSM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=0, ~milliseconds=1000)\n// 2023-02-20T16:40:01.000Z\n\nDate.makeWithYMDHMSM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=0, ~milliseconds=-1)\n// 2023-02-20T16:39:59.999Z\n\n// Note: The output depends on your local time zone.\n// In nodejs you can change it by using the TZ env (`export TZ='Europe/London' && node index.bs.js`)\n\n```"]
    }, 
    {
      "id": "RescriptCore.Date.UTC",
      "name": "UTC",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.Date.UTC.makeWithYM",
        "kind": "value",
        "name": "makeWithYM",
        "signature": "let makeWithYM: (~year: int, ~month: int) => msSinceEpoch",
        "docstrings": ["Returns the time, in milliseconds, since UNIX epoch (January 1, 1970 00:00:00 UTC).\n  Be aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\n  Months are 0-indexed (0 = January, 11 = December).\n  Values, which are out of range, will be carried over to the next bigger unit (s. example).\n\n  ## Examples\n  ```rescript\n  Date.UTC.makeWithYM(~year=2023, ~month=0)\n  // 1672531200000\n\n  Date.UTC.makeWithYM(~year=2023, ~month=11)\n  // 1701388800000\n\n  Date.UTC.makeWithYM(~year=2023, ~month=12)\n  // 1704067200000\n\n  Date.UTC.makeWithYM(~year=2023, ~month=-1)\n  // 1669852800000\n  ```"]
      }, 
      {
        "id": "RescriptCore.Date.UTC.makeWithYMD",
        "kind": "value",
        "name": "makeWithYMD",
        "signature": "let makeWithYMD: (~year: int, ~month: int, ~date: int) => msSinceEpoch",
        "docstrings": ["Returns the time, in milliseconds, since UNIX epoch (January 1, 1970 00:00:00 UTC).\n  Be aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\n  Months are 0-indexed (0 = January, 11 = December).\n  Values, which are out of range, will be carried over to the next bigger unit (s. example).\n\n  ## Examples\n  ```rescript\n  Date.UTC.makeWithYMD(~year=2023, ~month=1, ~date=20)\n  // 1676851200000\n\n  Date.UTC.makeWithYMD(~year=2023, ~month=1, ~date=-1)\n  // 1675036800000\n\n  Date.UTC.makeWithYMD(~year=2023, ~month=1, ~date=29)\n  // 1677628800000\n  ```"]
      }, 
      {
        "id": "RescriptCore.Date.UTC.makeWithYMDH",
        "kind": "value",
        "name": "makeWithYMDH",
        "signature": "let makeWithYMDH: (~year: int, ~month: int, ~date: int, ~hours: int) => msSinceEpoch",
        "docstrings": ["Returns the time, in milliseconds, since UNIX epoch (January 1, 1970 00:00:00 UTC).\n  Be aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\n  Months are 0-indexed (0 = January, 11 = December).\n  Values, which are out of range, will be carried over to the next bigger unit (s. example).\n\n  ## Examples\n  ```rescript\n  Date.UTC.makeWithYMDH(~year=2023, ~month=1, ~date=20, ~hours=16)\n  // 1676908800000\n\n  Date.UTC.makeWithYMDH(~year=2023, ~month=1, ~date=20, ~hours=24)\n  // 1676937600000\n\n  Date.UTC.makeWithYMDH(~year=2023, ~month=1, ~date=20, ~hours=-1)\n  // 1676847600000\n  ```"]
      }, 
      {
        "id": "RescriptCore.Date.UTC.makeWithYMDHM",
        "kind": "value",
        "name": "makeWithYMDHM",
        "signature": "let makeWithYMDHM: (~year: int, ~month: int, ~date: int, ~hours: int, ~minutes: int) => msSinceEpoch",
        "docstrings": ["Returns the time, in milliseconds, since UNIX epoch (January 1, 1970 00:00:00 UTC).\n  Be aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\n  Months are 0-indexed (0 = January, 11 = December).\n  Values, which are out of range, will be carried over to the next bigger unit (s. example).\n\n  ## Examples\n  ```rescript\n  Date.UTC.makeWithYMDHM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40)\n  // 1676911200000\n\n  Date.UTC.makeWithYMDHM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=60)\n  // 1676912400000\n\n  Date.UTC.makeWithYMDHM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=-1)\n  // 1676908740000\n  ```"]
      }, 
      {
        "id": "RescriptCore.Date.UTC.makeWithYMDHMS",
        "kind": "value",
        "name": "makeWithYMDHMS",
        "signature": "let makeWithYMDHMS: (\\n  ~year: int,\\n  ~month: int,\\n  ~date: int,\\n  ~hours: int,\\n  ~minutes: int,\\n  ~seconds: int,\\n) => msSinceEpoch",
        "docstrings": ["Returns the time, in milliseconds, since UNIX epoch (January 1, 1970 00:00:00 UTC).\n  Be aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\n  Months are 0-indexed (0 = January, 11 = December).\n  Values, which are out of range, will be carried over to the next bigger unit (s. example).\n\n  ## Examples\n  ```rescript\n  Date.UTC.makeWithYMDHMS(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=0)\n  // 1676911200000\n\n  Date.UTC.makeWithYMDHMS(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=60)\n  // 1676911260000\n\n  Date.UTC.makeWithYMDHMS(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=-1)\n  // 1676911199000\n  ```"]
      }, 
      {
        "id": "RescriptCore.Date.UTC.makeWithYMDHMSM",
        "kind": "value",
        "name": "makeWithYMDHMSM",
        "signature": "let makeWithYMDHMSM: (\\n  ~year: int,\\n  ~month: int,\\n  ~date: int,\\n  ~hours: int,\\n  ~minutes: int,\\n  ~seconds: int,\\n  ~milliseconds: int,\\n) => msSinceEpoch",
        "docstrings": ["Returns the time, in milliseconds, since UNIX epoch (January 1, 1970 00:00:00 UTC).\n  Be aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\n  Months are 0-indexed (0 = January, 11 = December).\n  Values, which are out of range, will be carried over to the next bigger unit (s. example).\n\n  ## Examples\n  ```rescript\n  ```\n  Date.UTC.makeWithYMDHMSM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=0, ~milliseconds=0)->Console.log\n  // 1676911200000\n\n  Date.UTC.makeWithYMDHMSM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=0, ~milliseconds=1000)->Console.log\n  // 1676911201000\n\n  Date.UTC.makeWithYMDHMSM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=0, ~milliseconds=-1)->Console.log\n  // 1676911199999"]
      }]
    }, 
    {
      "id": "RescriptCore.Date.now",
      "kind": "value",
      "name": "now",
      "signature": "let now: unit => msSinceEpoch",
      "docstrings": ["`now()`\n\nReturns the time, in milliseconds, between UNIX epoch (January 1, 1970 00:00:00 UTC) and the current date time."]
    }, 
    {
      "id": "RescriptCore.Date.equal",
      "kind": "value",
      "name": "equal",
      "signature": "let equal: (t, t) => bool",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Date.compare",
      "kind": "value",
      "name": "compare",
      "signature": "let compare: (t, t) => Core__Ordering.t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Date.getTime",
      "kind": "value",
      "name": "getTime",
      "signature": "let getTime: t => msSinceEpoch",
      "docstrings": ["`getTime(date)`\n\nReturns the time, in milliseconds, between UNIX epoch (January 1, 1970 00:00:00 UTC) and the current date time.\nInvalid dates will return NaN.\nDates before epoch will return negative numbers.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20\")->Date.getTime\n// 1676851200000\n```"]
    }, 
    {
      "id": "RescriptCore.Date.getTimezoneOffset",
      "kind": "value",
      "name": "getTimezoneOffset",
      "signature": "let getTimezoneOffset: t => int",
      "docstrings": ["`getTimezoneOffset(date)`\n\nReturns the time in minutes between the UTC time and the locale time.\nThe timezone of the given date doesn't matter.\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01\")->Date.getTimezoneOffset\n// -60 with local time zone = Europe/Berlin\n\nDate.fromString(\"2023-06-01\")->Date.getTimezoneOffset\n// -120 with local time zone = Europe/Berlin\n```"]
    }, 
    {
      "id": "RescriptCore.Date.getFullYear",
      "kind": "value",
      "name": "getFullYear",
      "signature": "let getFullYear: t => int",
      "docstrings": ["`getFullYear(date)`\n\nReturns the year of a given date (according to local time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20\")->Date.getFullYear\n// 2023\n```"]
    }, 
    {
      "id": "RescriptCore.Date.getMonth",
      "kind": "value",
      "name": "getMonth",
      "signature": "let getMonth: t => int",
      "docstrings": ["`getMonth(date)`\n\nReturns the month (0-indexed) of a given date (according to local time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01\")->Date.getMonth\n// 0\n```"]
    }, 
    {
      "id": "RescriptCore.Date.getDate",
      "kind": "value",
      "name": "getDate",
      "signature": "let getDate: t => int",
      "docstrings": ["`getDate(date)`\n\nReturns the date (day of month) of a given date (according to local time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.getDate\n// 20\n```"]
    }, 
    {
      "id": "RescriptCore.Date.getHours",
      "kind": "value",
      "name": "getHours",
      "signature": "let getHours: t => int",
      "docstrings": ["`getHours(date)`\n\nReturns the hours of a given date (according to local time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.getHours\n// 16\n```"]
    }, 
    {
      "id": "RescriptCore.Date.getMinutes",
      "kind": "value",
      "name": "getMinutes",
      "signature": "let getMinutes: t => int",
      "docstrings": ["`getMinutes(date)`\n\nReturns the minutes of a given date (according to local time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.getMinutes\n// 40\n```"]
    }, 
    {
      "id": "RescriptCore.Date.getSeconds",
      "kind": "value",
      "name": "getSeconds",
      "signature": "let getSeconds: t => int",
      "docstrings": ["`getSeconds(date)`\n\nReturns the seconds of a given date (according to local time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.getSeconds\n// 0\n```"]
    }, 
    {
      "id": "RescriptCore.Date.getMilliseconds",
      "kind": "value",
      "name": "getMilliseconds",
      "signature": "let getMilliseconds: t => int",
      "docstrings": ["`getMilliseconds(date)`\n\nReturns the milliseconds of a given date (according to local time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.getMilliseconds\n// 0\n```"]
    }, 
    {
      "id": "RescriptCore.Date.getDay",
      "kind": "value",
      "name": "getDay",
      "signature": "let getDay: t => int",
      "docstrings": ["`getDay(date)`\n\nReturns the day of week of a given date (according to local time).\n0 = Sunday, 1 = Monday, ... 6 = Saturday\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.getDay\n// 1\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setFullYear",
      "kind": "value",
      "name": "setFullYear",
      "signature": "let setFullYear: (t, int) => unit",
      "docstrings": ["`setFullYear(date, year)`\n\nSets the year of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setFullYear(2024)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setFullYearM",
      "kind": "value",
      "name": "setFullYearM",
      "signature": "let setFullYearM: (t, ~year: int, ~month: int) => unit",
      "docstrings": ["`setFullYearM(date, ~year, ~month)`\n\nSets the year and month of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setFullYearM(~year=2024, ~month=0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setFullYearMD",
      "kind": "value",
      "name": "setFullYearMD",
      "signature": "let setFullYearMD: (t, ~year: int, ~month: int, ~date: int) => unit",
      "docstrings": ["`setFullYearMD(date, ~year, ~month, ~date)`\n\nSets the year, month and date (day of month) of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setFullYearMD(~year=2024, ~month=0, ~date=1)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setMonth",
      "kind": "value",
      "name": "setMonth",
      "signature": "let setMonth: (t, int) => unit",
      "docstrings": ["`setMonth(date, month)`\n\nSets the month of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setMonth(0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setDate",
      "kind": "value",
      "name": "setDate",
      "signature": "let setDate: (t, int) => unit",
      "docstrings": ["`setDate(date, day)`\n\nSets the date (day of month) of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setDate(1)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setHours",
      "kind": "value",
      "name": "setHours",
      "signature": "let setHours: (t, int) => unit",
      "docstrings": ["`setHours(date, hours)`\n\nSets the hours of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setHours(0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setHoursM",
      "kind": "value",
      "name": "setHoursM",
      "signature": "let setHoursM: (t, ~hours: int, ~minutes: int) => unit",
      "docstrings": ["`setHoursM(date, ~hours, ~minutes)`\n\nSets the hours and minutes of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setHoursM(~hours=0, ~minutes=0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setHoursMS",
      "kind": "value",
      "name": "setHoursMS",
      "signature": "let setHoursMS: (t, ~hours: int, ~minutes: int, ~seconds: int) => unit",
      "docstrings": ["`setHoursMS(date, ~hours, ~minutes, ~seconds)`\n\nSets the hours, minutes and seconds of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setHoursMS(~hours=0, ~minutes=0, ~seconds=0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setHoursMSMs",
      "kind": "value",
      "name": "setHoursMSMs",
      "signature": "let setHoursMSMs: (t, ~hours: int, ~minutes: int, ~seconds: int, ~milliseconds: int) => unit",
      "docstrings": ["`setHoursMSMs(date, ~hours, ~minutes, ~seconds, ~milliseconds)`\n\nSets the hours, minutes, seconds and milliseconds of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setHoursMSMs(~hours=0, ~minutes=0, ~seconds=0, ~milliseconds=0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setMinutes",
      "kind": "value",
      "name": "setMinutes",
      "signature": "let setMinutes: (t, int) => unit",
      "docstrings": ["`setMinutes(date, minutes)`\n\nSets the minutes of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setMinutes(0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setMinutesS",
      "kind": "value",
      "name": "setMinutesS",
      "signature": "let setMinutesS: (t, ~minutes: int, ~seconds: int) => unit",
      "docstrings": ["`setMinutesS(date, ~minutes, ~seconds)`\n\nSets the minutes and seconds of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setMinutesS(~minutes=0, ~seconds=0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setMinutesSMs",
      "kind": "value",
      "name": "setMinutesSMs",
      "signature": "let setMinutesSMs: (t, ~minutes: int, ~seconds: int, ~milliseconds: int) => unit",
      "docstrings": ["`setMinutesSMs(date, ~minutes, ~seconds, ~milliseconds)`\n\nSets the minutes, seconds and milliseconds of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setMinutesSMs(~minutes=0, ~seconds=0, ~milliseconds=0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setSeconds",
      "kind": "value",
      "name": "setSeconds",
      "signature": "let setSeconds: (t, int) => unit",
      "docstrings": ["`setSeconds(date, seconds)`\n\nSets the seconds of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setSeconds(0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setSecondsMs",
      "kind": "value",
      "name": "setSecondsMs",
      "signature": "let setSecondsMs: (t, ~seconds: int, ~milliseconds: int) => unit",
      "docstrings": ["`setSecondsMs(date, ~seconds, ~milliseconds)`\n\nSets the seconds and milliseconds of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setSecondsMs(~seconds=0, ~milliseconds=0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setMilliseconds",
      "kind": "value",
      "name": "setMilliseconds",
      "signature": "let setMilliseconds: (t, int) => unit",
      "docstrings": ["`setMilliseconds(date, milliseconds)`\n\nSets the milliseconds of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setMilliseconds(0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.getUTCFullYear",
      "kind": "value",
      "name": "getUTCFullYear",
      "signature": "let getUTCFullYear: t => int",
      "docstrings": ["`getUTCFullYear(date)`\n\nReturns the year of a given date (according to UTC time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+01:00\").getUTCFullYear\n// 2022\n```"]
    }, 
    {
      "id": "RescriptCore.Date.getUTCMonth",
      "kind": "value",
      "name": "getUTCMonth",
      "signature": "let getUTCMonth: t => int",
      "docstrings": ["`getUTCMonth(date)`\n\nReturns the month of a given date (according to UTC time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+01:00\").getUTCMonth\n// 11\n```"]
    }, 
    {
      "id": "RescriptCore.Date.getUTCDate",
      "kind": "value",
      "name": "getUTCDate",
      "signature": "let getUTCDate: t => int",
      "docstrings": ["`getUTCDate(date)`\n\nReturns the date (day of month) of a given date (according to UTC time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+01:00\").getUTCDate\n// 31\n```"]
    }, 
    {
      "id": "RescriptCore.Date.getUTCHours",
      "kind": "value",
      "name": "getUTCHours",
      "signature": "let getUTCHours: t => int",
      "docstrings": ["`getUTCHours(date)`\n\nReturns the hours of a given date (according to UTC time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+01:00\").getUTCHours\n// 23\n```"]
    }, 
    {
      "id": "RescriptCore.Date.getUTCMinutes",
      "kind": "value",
      "name": "getUTCMinutes",
      "signature": "let getUTCMinutes: t => int",
      "docstrings": ["`getUTCMinutes(date)`\n\nReturns the minutes of a given date (according to UTC time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+01:00\").getUTCMinutes\n// 0\n```"]
    }, 
    {
      "id": "RescriptCore.Date.getUTCSeconds",
      "kind": "value",
      "name": "getUTCSeconds",
      "signature": "let getUTCSeconds: t => int",
      "docstrings": ["`getUTCSeconds(date)`\n\nReturns the seconds of a given date (according to UTC time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+01:00\").getUTCSeconds\n// 0\n```"]
    }, 
    {
      "id": "RescriptCore.Date.getUTCMilliseconds",
      "kind": "value",
      "name": "getUTCMilliseconds",
      "signature": "let getUTCMilliseconds: t => int",
      "docstrings": ["`getUTCMilliseconds(date)`\n\nReturns the milliseconds of a given date (according to UTC time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+01:00\").getUTCMilliseconds\n// 0\n```"]
    }, 
    {
      "id": "RescriptCore.Date.getUTCDay",
      "kind": "value",
      "name": "getUTCDay",
      "signature": "let getUTCDay: t => int",
      "docstrings": ["`getUTCDay(date)`\n\nReturns the day (day of week) of a given date (according to UTC time).\n0 = Sunday, 1 = Monday, ... 6 = Saturday\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+01:00\").getUTCDay\n// 6\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setUTCFullYear",
      "kind": "value",
      "name": "setUTCFullYear",
      "signature": "let setUTCFullYear: (t, int) => unit",
      "docstrings": ["`setUTCFullYear(date, year)`\n\nSets the year of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCFullYear(2024)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setUTCFullYearM",
      "kind": "value",
      "name": "setUTCFullYearM",
      "signature": "let setUTCFullYearM: (t, ~year: int, ~month: int) => unit",
      "docstrings": ["`setUTCFullYearM(date, ~year, ~month)`\n\nSets the year and month of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCFullYearM(~year=2024, ~month=0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setUTCFullYearMD",
      "kind": "value",
      "name": "setUTCFullYearMD",
      "signature": "let setUTCFullYearMD: (t, ~year: int, ~month: int, ~date: int) => unit",
      "docstrings": ["`setUTCFullYearMD(date, ~year, ~month, ~date)`\n\nSets the year, month and date (day of month) of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCFullYearMD(~year=2024, ~month=0, ~date=1)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setUTCMonth",
      "kind": "value",
      "name": "setUTCMonth",
      "signature": "let setUTCMonth: (t, int) => unit",
      "docstrings": ["`setUTCMonth(date, month)`\n\nSets the month of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCMonth(0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setUTCDate",
      "kind": "value",
      "name": "setUTCDate",
      "signature": "let setUTCDate: (t, int) => unit",
      "docstrings": ["`setDate(date, day)`\n\nSets the date (day of month) of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCDate(1)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setUTCHours",
      "kind": "value",
      "name": "setUTCHours",
      "signature": "let setUTCHours: (t, int) => unit",
      "docstrings": ["`setUTCHours(date, hours)`\n\nSets the hours of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCHours(0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setUTCHoursM",
      "kind": "value",
      "name": "setUTCHoursM",
      "signature": "let setUTCHoursM: (t, ~hours: int, ~minutes: int) => unit",
      "docstrings": ["`setHoursM(date, ~hours, ~minutes)`\n\nSets the hours and minutes of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCHoursM(~hours=0, ~minutes=0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setUTCHoursMS",
      "kind": "value",
      "name": "setUTCHoursMS",
      "signature": "let setUTCHoursMS: (t, ~hours: int, ~minutes: int, ~seconds: int) => unit",
      "docstrings": ["`setUTCHoursMS(date, ~hours, ~minutes, ~seconds)`\n\nSets the hours, minutes and seconds of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCHoursMS(~hours=0, ~minutes=0, ~seconds=0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setUTCHoursMSMs",
      "kind": "value",
      "name": "setUTCHoursMSMs",
      "signature": "let setUTCHoursMSMs: (t, ~hours: int, ~minutes: int, ~seconds: int, ~milliseconds: int) => unit",
      "docstrings": ["`setUTCHoursMSMs(date, ~hours, ~minutes, ~seconds, ~milliseconds)`\n\nSets the hours, minutes, seconds and milliseconds of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCHoursMSMs(~hours=0, ~minutes=0, ~seconds=0, ~milliseconds=0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setUTCMinutes",
      "kind": "value",
      "name": "setUTCMinutes",
      "signature": "let setUTCMinutes: (t, int) => unit",
      "docstrings": ["`setUTCMinutes(date, minutes)`\n\nSets the minutes of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCMinutes(0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setUTCMinutesS",
      "kind": "value",
      "name": "setUTCMinutesS",
      "signature": "let setUTCMinutesS: (t, ~minutes: int, ~seconds: int) => unit",
      "docstrings": ["`setUTCMinutesS(date, ~minutes, ~seconds)`\n\nSets the minutes and seconds of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCMinutesS(~minutes=0, ~seconds=0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setUTCMinutesSMs",
      "kind": "value",
      "name": "setUTCMinutesSMs",
      "signature": "let setUTCMinutesSMs: (t, ~minutes: int, ~seconds: int, ~milliseconds: int) => unit",
      "docstrings": ["`setUTCMinutesSMs(date, ~minutes, ~seconds, ~milliseconds)`\n\nSets the minutes, seconds and milliseconds of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCMinutesSMs(~minutes=0, ~seconds=0, ~milliseconds=0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setUTCSeconds",
      "kind": "value",
      "name": "setUTCSeconds",
      "signature": "let setUTCSeconds: (t, int) => unit",
      "docstrings": ["`setUTCSeconds(date, seconds)`\n\nSets the seconds of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCSeconds(0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setUTCSecondsMs",
      "kind": "value",
      "name": "setUTCSecondsMs",
      "signature": "let setUTCSecondsMs: (t, ~seconds: int, ~milliseconds: int) => unit",
      "docstrings": ["`setUTCSecondsMs(date, ~seconds, ~milliseconds)`\n\nSets the seconds and milliseconds of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCSecondsMs(~seconds=0, ~milliseconds=0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.setUTCMilliseconds",
      "kind": "value",
      "name": "setUTCMilliseconds",
      "signature": "let setUTCMilliseconds: (t, int) => unit",
      "docstrings": ["`setUTCMilliseconds(date, milliseconds)`\n\nSets the milliseconds of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCMilliseconds(0)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.toDateString",
      "kind": "value",
      "name": "toDateString",
      "signature": "let toDateString: t => string",
      "docstrings": ["`toDateString(date)`\n\nConverts a JavaScript date to a standard date string. The date will be mapped to the current time zone.\nIf you want to convert it to a localized string, use `Date.toLocaleDateString` instead.\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+01:00\")->Date.toDateString->Console.log\n// Sun Jan 01 2023\n\nDate.fromString(\"2023-01-01T00:00:00.00+08:00\")->Date.toDateString->Console.log\n// Sat Dec 31 2022\n```"]
    }, 
    {
      "id": "RescriptCore.Date.toString",
      "kind": "value",
      "name": "toString",
      "signature": "let toString: t => string",
      "docstrings": ["`toString(date)`\n\nConverts a JavaScript date to a standard date time string. The date will be mapped to the current time zone.\nIf you want to convert it to a localized string, use `Date.toLocaleString` instead.\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+01:00\")->Date.toString->Console.log\n// Sun Jan 01 2023 00:00:00 GMT+0100 (Central European Standard Time)\n\nDate.fromString(\"2023-06-01T00:00:00.00+01:00\")->Date.toString->Console.log\n// Thu Jun 01 2023 01:00:00 GMT+0200 (Central European Summer Time)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.toTimeString",
      "kind": "value",
      "name": "toTimeString",
      "signature": "let toTimeString: t => string",
      "docstrings": ["`toTimeString(date)`\n\nConverts a JavaScript date to a standard time string. The date will be mapped to the current time zone.\nIf you want to convert it to a localized string, use `Date.toLocaleStimeString` instead.\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+01:00\")->Date.toTimeString->Console.log\n// 00:00:00 GMT+0100 (Central European Standard Time)\n\nDate.fromString(\"2023-01-01T00:00:00.00+08:00\")->Date.toTimeString->Console.log\n// 17:00:00 GMT+0100 (Central European Standard Time)\n```"]
    }, 
    {
      "id": "RescriptCore.Date.toLocaleDateString",
      "kind": "value",
      "name": "toLocaleDateString",
      "signature": "let toLocaleDateString: t => string",
      "docstrings": ["`toLocaleDateString(date)`\n\nConverts a JavaScript date to a localized date string. It will use the current locale.\n\n## Examples\n```rescript\nDate.make()->Date.toLocaleDateString->Console.log\n// 2/19/2023\n```"]
    }, 
    {
      "id": "RescriptCore.Date.toLocaleDateStringWithLocale",
      "kind": "value",
      "name": "toLocaleDateStringWithLocale",
      "signature": "let toLocaleDateStringWithLocale: (t, string) => string",
      "docstrings": ["`toLocaleDateStringWithLocale(date, locale)`\n\nConverts a JavaScript date to a localized date string. It will use the specified locale.\n\n## Examples\n```rescript\nDate.make()->Date.toLocaleDateStringWithLocale(\"en-US\")->Console.log\n// 2/19/2023\n```"]
    }, 
    {
      "id": "RescriptCore.Date.toLocaleDateStringWithLocaleAndOptions",
      "kind": "value",
      "name": "toLocaleDateStringWithLocaleAndOptions",
      "signature": "let toLocaleDateStringWithLocaleAndOptions: (t, string, localeOptions) => string",
      "docstrings": ["`toLocaleDateStringWithLocaleAndOptions(date, locale, options)`\n\nConverts a JavaScript date to a localized date string. It will use the specified locale and formatting options.\n\n## Examples\n```rescript\nDate.make()->Date.toLocaleDateStringWithLocaleAndOptions(\"en-US\", { dateStyle: #long })->Console.log\n// February 19, 2023\n\nDate.make()->Date.toLocaleDateStringWithLocaleAndOptions(\"de\", { hour: #\"2-digit\", minute: #\"2-digit\" })->Console.log\n// 19.2.2023, 15:40\n\nDate.make()->Date.toLocaleDateStringWithLocaleAndOptions(\"de\", { year: #numeric })->Console.log\n// 2023\n```"]
    }, 
    {
      "id": "RescriptCore.Date.toLocaleString",
      "kind": "value",
      "name": "toLocaleString",
      "signature": "let toLocaleString: t => string",
      "docstrings": ["`toLocaleString(date)`\n\nConverts a JavaScript date to a localized date-time string. It will use the current locale.\n\n## Examples\n```rescript\nDate.make()->Date.toLocaleString->Console.log\n// 2/19/2023, 3:40:00 PM\n```"]
    }, 
    {
      "id": "RescriptCore.Date.toLocaleStringWithLocale",
      "kind": "value",
      "name": "toLocaleStringWithLocale",
      "signature": "let toLocaleStringWithLocale: (t, string) => string",
      "docstrings": ["`toLocaleStringWithLocale(date, locale)`\n\nConverts a JavaScript date to a localized date-time string. It will use the specified locale.\n\n## Examples\n```rescript\nDate.make()->Date.toLocaleStringWithLocale(\"en-US\")->Console.log\n// 2/19/2023, 3:40:00 PM\n```"]
    }, 
    {
      "id": "RescriptCore.Date.toLocaleStringWithLocaleAndOptions",
      "kind": "value",
      "name": "toLocaleStringWithLocaleAndOptions",
      "signature": "let toLocaleStringWithLocaleAndOptions: (t, string, localeOptions) => string",
      "docstrings": ["`toLocaleStringWithLocaleAndOptions(date, locale, options)`\n\nConverts a JavaScript date to a localized date-time string. It will use the specified locale and formatting options.\n\n## Examples\n```rescript\nDate.make()->Date.toLocaleStringWithLocaleAndOptions(\"en\", { dateStyle: #short, timeStyle: #short })->Console.log\n// 2/19/23, 3:40 PM\n\nDate.make()->Date.toLocaleStringWithLocaleAndOptions(\"en\", { era: #long, year: #numeric, month: #\"2-digit\", day: #\"2-digit\", hour: #numeric, timeZoneName: #short })->Console.log\n// 02/19/2023 Anno Domini, 3 PM GMT+1\n```"]
    }, 
    {
      "id": "RescriptCore.Date.toLocaleTimeString",
      "kind": "value",
      "name": "toLocaleTimeString",
      "signature": "let toLocaleTimeString: t => string",
      "docstrings": ["`toLocaleTimeString(date)`\n\nConverts a JavaScript date to a localized time string. It will use the current locale.\n\n## Examples\n```rescript\nDate.make()->Date.toLocaleTimeString->Console.log\n// 3:40:00 PM\n```"]
    }, 
    {
      "id": "RescriptCore.Date.toLocaleTimeStringWithLocale",
      "kind": "value",
      "name": "toLocaleTimeStringWithLocale",
      "signature": "let toLocaleTimeStringWithLocale: (t, string) => string",
      "docstrings": ["`toLocaleTimeStringWithLocale(date, locale)`\n\nConverts a JavaScript date to a localized time string. It will use the specified locale.\n\n## Examples\n```rescript\nDate.make()->Date.toLocaleTimeStringWithLocale(\"en-US\")->Console.log\n// 3:40:00 PM\n```"]
    }, 
    {
      "id": "RescriptCore.Date.toLocaleTimeStringWithLocaleAndOptions",
      "kind": "value",
      "name": "toLocaleTimeStringWithLocaleAndOptions",
      "signature": "let toLocaleTimeStringWithLocaleAndOptions: (t, string, localeOptions) => string",
      "docstrings": ["`toLocaleTimeStringWithLocaleAndOptions(date, locale, options)`\n\nConverts a JavaScript date to a localized time string. It will use the specified locale and formatting options.\n\n## Examples\n```rescript\nDate.make()->Date.toLocaleTimeStringWithLocaleAndOptions(\"en-US\", { timeStyle: #long })->Console.log\n// 3:40:00 PM GMT+1\n\nDate.make()->Date.toLocaleTimeStringWithLocaleAndOptions(\"de\", { hour: #\"2-digit\", minute: #\"2-digit\" })->Console.log\n// 15:40\n```"]
    }, 
    {
      "id": "RescriptCore.Date.toISOString",
      "kind": "value",
      "name": "toISOString",
      "signature": "let toISOString: t => string",
      "docstrings": ["`toISOString(date)`\n\nConverts a JavaScript date to a ISO 8601 string (YYYY-MM-DDTHH:mm:ss.sssZ). The date will be mapped to the UTC time.\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+00:00\")->Date.toISOString->Console.log\n// 2023-01-01T00:00:00.000Z\n\nDate.fromString(\"2023-01-01T00:00:00.00+08:00\")->Date.toISOString->Console.log\n// 2022-12-31T16:00:00.000Z\n```"]
    }, 
    {
      "id": "RescriptCore.Date.toUTCString",
      "kind": "value",
      "name": "toUTCString",
      "signature": "let toUTCString: t => string",
      "docstrings": ["`toUTCString(date)`\n\nConverts a JavaScript date to date time string. The date will be mapped to the UTC time.\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+00:00\")->Date.toUTCString->Console.log\n// Sun, 01 Jan 2023 00:00:00 GMT\n\nDate.fromString(\"2023-01-01T00:00:00.00+08:00\")->Date.toUTCString->Console.log\n// Sat, 31 Dec 2022 16:00:00 GMT\n```"]
    }, 
    {
      "id": "RescriptCore.Date.toJSON",
      "kind": "value",
      "name": "toJSON",
      "signature": "let toJSON: t => option<string>",
      "docstrings": ["`toJSON(date)`\n\nConverts a JavaScript date to a string.\nIf the date is valid, the function will return the same result as `Date.toISOString`.\nInvalid dates will return `None`.\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+00:00\")->Date.toJSON\n// Some(\"2023-01-01T00:00:00.000Z\")\n\nDate.fromString(\"\")->Date.toJSON\n// None\n```"]
    }]
  }, 
  {
    "id": "RescriptCore.Dict",
    "kind": "moduleAlias",
    "name": "Dict",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Dict.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'a> = Js.Dict.t<'a>",
      "docstrings": ["Type representing a dictionary of value `'a`."]
    }, 
    {
      "id": "RescriptCore.Dict.get",
      "kind": "value",
      "name": "get",
      "signature": "let get: (t<'a>, string) => option<'a>",
      "docstrings": ["Returns the value at the provided key, if it exists. Returns an option.\n\n## Examples\n```rescript\nlet dict = Dict.fromArray([(\"someKey\", \"someValue\")])\n\nswitch dict->Dict.get(\"someKey\") {\n| None => Console.log(\"Nope, didn't have the key.\")\n| Some(value) => Console.log(value)\n}\n```"]
    }, 
    {
      "id": "RescriptCore.Dict.set",
      "kind": "value",
      "name": "set",
      "signature": "let set: (t<'a>, string, 'a) => unit",
      "docstrings": ["`set(dictionary, key, value)` sets the value at the provided key to the provided value.\n\n## Examples\n```rescript\nlet dict = Dict.make()\n\ndict->Dict.set(\"someKey\", \"someValue\")\n```"]
    }, 
    {
      "id": "RescriptCore.Dict.delete",
      "kind": "value",
      "name": "delete",
      "signature": "let delete: (t<'a>, string) => unit",
      "docstrings": ["`delete(dictionary, key)` deletes the value at `key`, if it exists.\n\n## Examples\n```rescript\nlet dict = Dict.fromArray([(\"someKey\", \"someValue\")])\n\ndict->Dict.delete(\"someKey\")\n```"]
    }, 
    {
      "id": "RescriptCore.Dict.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: unit => t<'a>",
      "docstrings": ["`make()` creates a new, empty dictionary.\n\n## Examples\n```rescript\nlet dict1: Dict.t<int> = Dict.make() // You can annotate the type of the values of your dict yourself if you want\n\nlet dict2 = Dict.make() // Or you can let ReScript infer it via usage.\ndict2->Dict.set(\"someKey\", 12)\n```"]
    }, 
    {
      "id": "RescriptCore.Dict.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: array<(string, 'a)> => t<'a>",
      "docstrings": ["`fromArray(entries)` creates a new dictionary from the provided array of key/value pairs.\n\n## Examples\n```rescript\nlet dict = Dict.fromArray([(\"key1\", \"value1\"), (\"key2\", \"value2\")])\n```"]
    }, 
    {
      "id": "RescriptCore.Dict.fromIterator",
      "kind": "value",
      "name": "fromIterator",
      "signature": "let fromIterator: Core__Iterator.t<(string, 'a)> => t<'a>",
      "docstrings": ["`fromIterator(entries)` creates a new dictionary from the provided iterator of key/value pairs.\n\n## Examples\n```rescript\n// Pretend we have an iterator of the correct shape\n@val external someIterator: Iterator.t<(string, int)> = \"someIterator\"\n\nlet dict = Dict.fromIterator(someIterator) // Dict.t<int>\n```"]
    }, 
    {
      "id": "RescriptCore.Dict.toArray",
      "kind": "value",
      "name": "toArray",
      "signature": "let toArray: t<'a> => array<(string, 'a)>",
      "docstrings": ["`toArray(dictionary)` returns an array of all the key/value pairs of the dictionary.\n\n## Examples\n```rescript\nlet dict = Dict.make()\ndict->Dict.set(\"someKey\", 1)\ndict->Dict.set(\"someKey2\", 2)\nlet asArray = dict->Dict.toArray\nConsole.log(asArray) // Logs `[[\"someKey\", 1], [\"someKey2\", 2]]` to the console\n```"]
    }, 
    {
      "id": "RescriptCore.Dict.keysToArray",
      "kind": "value",
      "name": "keysToArray",
      "signature": "let keysToArray: t<'a> => array<string>",
      "docstrings": ["`keysToArray(dictionary)` returns an array of all the keys of the dictionary.\n\n## Examples\n```rescript\nlet dict = Dict.make()\ndict->Dict.set(\"someKey\", 1)\ndict->Dict.set(\"someKey2\", 2)\nlet keys = dict->Dict.keysToArray\nConsole.log(keys) // Logs `[\"someKey\", \"someKey2\"]` to the console\n```"]
    }, 
    {
      "id": "RescriptCore.Dict.valuesToArray",
      "kind": "value",
      "name": "valuesToArray",
      "signature": "let valuesToArray: t<'a> => array<'a>",
      "docstrings": ["`valuesToArray(dictionary)` returns an array of all the values of the dictionary.\n\n## Examples\n```rescript\nlet dict = Dict.make()\ndict->Dict.set(\"someKey\", 1)\ndict->Dict.set(\"someKey2\", 2)\nlet values = dict->Dict.valuesToArray\nConsole.log(values) // Logs `[1, 2]` to the console\n```"]
    }, 
    {
      "id": "RescriptCore.Dict.assign",
      "kind": "value",
      "name": "assign",
      "signature": "let assign: (t<'a>, t<'a>) => t<'a>",
      "docstrings": ["`assign(dictionary1, dictionary2)` [shallowly](https://developer.mozilla.org/en-US/docs/Glossary/Shallow_copy) merges dictionary2 into dictionary1, and returns dictionary1.\n\nBeware this will *mutate* dictionary1. If you're looking for a way to copy a dictionary, check out `Dict.copy`.\n\n## Examples\n```rescript\nlet dict1 = Dict.make()\ndict1->Dict.set(\"firstKey\", 1)\nConsole.log(dict1->Dict.keysToArray) // Logs `[\"firstKey\"]`\n\nlet dict2 = Dict.make()\ndict2->Dict.set(\"someKey\", 2)\ndict2->Dict.set(\"someKey2\", 3)\n\nlet dict1 = dict1->Dict.assign(dict2)\n\nConsole.log(dict1->Dict.keysToArray) // Logs `[\"firstKey\", \"someKey\", \"someKey2\"]`\n\n```"]
    }, 
    {
      "id": "RescriptCore.Dict.copy",
      "kind": "value",
      "name": "copy",
      "signature": "let copy: t<'a> => t<'a>",
      "docstrings": ["`copy(dictionary)` [shallowly copies](https://developer.mozilla.org/en-US/docs/Glossary/Shallow_copy) the provided dictionary to a new dictionary.\n\n## Examples\n```rescript\nlet dict = Dict.fromArray([(\"key1\", \"value1\"), (\"key2\", \"value2\")])\nlet dict2 = dict->Dict.copy\n\n// Both log `[\"key1\", \"key2\"]` here.\nConsole.log2(dict->Dict.keysToArray, dict2->Dict.keysToArray)\n```"]
    }]
  }, 
  {
    "id": "RescriptCore.Error",
    "kind": "moduleAlias",
    "name": "Error",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Error.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = Js.Exn.t",
      "docstrings": ["Represents a JavaScript exception."]
    }, 
    {
      "id": "RescriptCore.Error.fromException",
      "kind": "value",
      "name": "fromException",
      "signature": "let fromException: exn => option<t>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Error.toException",
      "kind": "value",
      "name": "toException",
      "signature": "let toException: t => exn",
      "docstrings": ["Turns an `Error.t` into an `exn`.\n\n## Examples\n```rescript\nlet error = Error.make(\"Something went wrong.\")\n\nlet asExn = error->Error.toException // `asExn` is now type `exn`\n```"]
    }, 
    {
      "id": "RescriptCore.Error.stack",
      "kind": "value",
      "name": "stack",
      "signature": "let stack: t => option<string>",
      "docstrings": ["`stack(error)` retrieves the `stack` property of the error, if it exists. The stack is a list of what functions were called, and what files they are defined in, prior to the error happening.\n\nSee [`Error.prototype.stack`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/Stack) on MDN.\n\n## Example\n```rescript\nConsole.log(someError->Error.stack) // Logs `stack` if it exists on `someError`\n```"]
    }, 
    {
      "id": "RescriptCore.Error.message",
      "kind": "value",
      "name": "message",
      "signature": "let message: t => option<string>",
      "docstrings": ["`message(error)` retrieves the `message` property of the error, if it exists.\n\nSee [`Error.prototype.message`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/message) on MDN.\n\n## Example\n```rescript\nlet error = Error.SyntaxError.make(\"Some message here\")\nConsole.log(error->Error.message) // Logs \"Some message here\" to the console\n```"]
    }, 
    {
      "id": "RescriptCore.Error.name",
      "kind": "value",
      "name": "name",
      "signature": "let name: t => option<string>",
      "docstrings": ["`name(error)` retrieves the `name` property of the error, if it exists.\n\nSee [`Error.prototype.name`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/name) on MDN.\n\n## Example\n```rescript\nlet error = Error.SyntaxError.make(\"Some message here\")\nConsole.log(error->Error.name) // Logs \"SyntaxError\" to the console\n```"]
    }, 
    {
      "id": "RescriptCore.Error.fileName",
      "kind": "value",
      "name": "fileName",
      "signature": "let fileName: t => option<string>",
      "docstrings": ["`fileName(error)` retrieves the `fileName` property of the error, if it exists.\n\nSee [`Error.prototype.fileName`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/fileName) on MDN."]
    }, 
    {
      "id": "RescriptCore.Error.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: string => t",
      "docstrings": ["`make(message)` creates a new error, setting its `message` to the provided value.\n\nSee [`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/Error) on MDN.\n\n## Example\n```rescript\nlet error = Error.make(\"Some message here\")\nConsole.log(error->Error.message) // Logs \"Some message here\" to the console\nConsole.log(error->Error.name) // Logs \"Error\" to the console, because this is a regular error\n```"]
    }, 
    {
      "id": "RescriptCore.Error.EvalError",
      "name": "EvalError",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.Error.EvalError.make",
        "kind": "value",
        "name": "make",
        "signature": "let make: string => t",
        "docstrings": ["Creates a new `EvalError` with the provided `message`.\n\n  See [`EvalError`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError) on MDN."]
      }]
    }, 
    {
      "id": "RescriptCore.Error.RangeError",
      "name": "RangeError",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.Error.RangeError.make",
        "kind": "value",
        "name": "make",
        "signature": "let make: string => t",
        "docstrings": ["Creates a new `RangeError` with the provided `message`.\n\n  See [`RangeError`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError) on MDN."]
      }]
    }, 
    {
      "id": "RescriptCore.Error.ReferenceError",
      "name": "ReferenceError",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.Error.ReferenceError.make",
        "kind": "value",
        "name": "make",
        "signature": "let make: string => t",
        "docstrings": ["Creates a new `ReferenceError` with the provided `message`.\n\n  See [`ReferenceError`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError) on MDN."]
      }]
    }, 
    {
      "id": "RescriptCore.Error.SyntaxError",
      "name": "SyntaxError",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.Error.SyntaxError.make",
        "kind": "value",
        "name": "make",
        "signature": "let make: string => t",
        "docstrings": ["Creates a new `SyntaxError` with the provided `message`.\n\n  See [`SyntaxError`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError) on MDN."]
      }]
    }, 
    {
      "id": "RescriptCore.Error.TypeError",
      "name": "TypeError",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.Error.TypeError.make",
        "kind": "value",
        "name": "make",
        "signature": "let make: string => t",
        "docstrings": ["Creates a new `TypeError` with the provided `message`.\n\n  See [`TypeError`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError) on MDN."]
      }]
    }, 
    {
      "id": "RescriptCore.Error.URIError",
      "name": "URIError",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.Error.URIError.make",
        "kind": "value",
        "name": "make",
        "signature": "let make: string => t",
        "docstrings": ["Creates a new `URIError` with the provided `message`.\n\n  See [`URIError`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError) on MDN."]
      }]
    }, 
    {
      "id": "RescriptCore.Error.raise",
      "kind": "value",
      "name": "raise",
      "signature": "let raise: t => 'a",
      "docstrings": ["Raises (throws in JavaScript language) the provided `Error.t`, which will stop execution.\n\n## Examples\n```rescript\nlet error = Error.make(\"Everything is upside down.\")\n\nif 5 > 10 {\n  error->Error.raise\n} else {\n  Console.log(\"Phew, sanity still rules.\")\n}\n```"]
    }, 
    {
      "id": "RescriptCore.Error.panic",
      "kind": "value",
      "name": "panic",
      "signature": "let panic: string => 'a",
      "docstrings": ["Raises a panic exception with the given message.\n\nA panic exception is a native JavaScript exception that is not intended to be caught and\nhandled. Compared to a ReScript exception this will give a better stack trace and\ndebugging experience.\n\n## Examples\n```rescript\nError.panic(\"Uh oh. This was unexpected!\")\n```"]
    }]
  }, 
  {
    "id": "RescriptCore.Float",
    "kind": "moduleAlias",
    "name": "Float",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Float.Constants",
      "name": "Constants",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.Float.Constants.nan",
        "kind": "value",
        "name": "nan",
        "signature": "let nan: float",
        "docstrings": ["The special value \"Not a Number\"\n  See [`NaN`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Float.Constants.nan\n  ```"]
      }, 
      {
        "id": "RescriptCore.Float.Constants.epsilon",
        "kind": "value",
        "name": "epsilon",
        "signature": "let epsilon: float",
        "docstrings": ["Represents the difference between 1 and the smallest floating point number greater than 1.\n  See [`Number.EPSILON`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Float.Constants.epsilon\n  ```"]
      }, 
      {
        "id": "RescriptCore.Float.Constants.positiveInfinity",
        "kind": "value",
        "name": "positiveInfinity",
        "signature": "let positiveInfinity: float",
        "docstrings": ["The positive Infinity value\n  See [`Number.POSITIVE_INFINITY`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/POSITIVE_INFINITY) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Float.Constants.positiveInfinity\n  ```"]
      }, 
      {
        "id": "RescriptCore.Float.Constants.negativeInfinity",
        "kind": "value",
        "name": "negativeInfinity",
        "signature": "let negativeInfinity: float",
        "docstrings": ["The negative Infinity value\n  See [`Number.NEGATIVE_INFINITY`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NEGATIVE_INFINITY) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Float.Constants.negativeInfinity\n  ```"]
      }, 
      {
        "id": "RescriptCore.Float.Constants.minValue",
        "kind": "value",
        "name": "minValue",
        "signature": "let minValue: float",
        "docstrings": ["The smallest positive numeric value representable in JavaScript.\n  See [`Number.MIN_VALUE`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_VALUE) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Float.Constants.minValue\n  ```"]
      }, 
      {
        "id": "RescriptCore.Float.Constants.maxValue",
        "kind": "value",
        "name": "maxValue",
        "signature": "let maxValue: float",
        "docstrings": ["The maximum positive numeric value representable in JavaScript.\n  See [`Number.MAX_VALUE`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_VALUE) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Float.Constants.minValue\n  ```"]
      }]
    }, 
    {
      "id": "RescriptCore.Float.equal",
      "kind": "value",
      "name": "equal",
      "signature": "let equal: (float, float) => bool",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Float.compare",
      "kind": "value",
      "name": "compare",
      "signature": "let compare: (float, float) => Core__Ordering.t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Float.isNaN",
      "kind": "value",
      "name": "isNaN",
      "signature": "let isNaN: float => bool",
      "docstrings": ["`isNaN(v)` tests if the given `v` is `NaN`.\nSee [`NaN`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN) on MDN.\n\n## Examples\n\n```rescript\nFloat.isNaN(3.0) // false\nFloat.isNaN(Float.Constants.nan) // true\n```"]
    }, 
    {
      "id": "RescriptCore.Float.isFinite",
      "kind": "value",
      "name": "isFinite",
      "signature": "let isFinite: float => bool",
      "docstrings": ["`isFinite(v)` tests if the given `v` is finite.\nSee [`isFinite`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isFinite) on MDN.\n\n## Examples\n\n```rescript\nFloat.isFinite(1.0) // true\nFloat.isFinite(Float.Constants.nan) // false\nFloat.isFinite(Float.Constants.positiveInfinity) // false\n```"]
    }, 
    {
      "id": "RescriptCore.Float.parseFloat",
      "kind": "value",
      "name": "parseFloat",
      "signature": "let parseFloat: string => float",
      "docstrings": ["`parseFloat(v)` parse the given `v` and returns a float. Leading whitespace in\n`v` is ignored. Returns `NaN` if `v` can't be parsed. Use [`fromString`] to\nensure it returns a valid float and not `NaN`.\nSee [`parseFloat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseFloat) on MDN.\n\n## Examples\n\n```rescript\nFloat.parseFloat(\"1.0\") // 1.0\nFloat.parseFloat(\"  3.14   \") // 3.14\nFloat.parseFloat(3.0) // 3.0\nFloat.parseFloat(\"3.14some non-digit characters\") // 3.14\nFloat.parseFloat(\"error\")->Float.isNaN // true\n```"]
    }, 
    {
      "id": "RescriptCore.Float.parseInt",
      "kind": "value",
      "name": "parseInt",
      "signature": "let parseInt: 'a => float",
      "docstrings": ["`parseInt(v)` parse the given `v` and returns a float. Leading whitespace in\n`v` is ignored. Returns `NaN` if `v` can't be parsed.\nSee [`parseInt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt) on MDN.\n\n## Examples\n\n```rescript\nFloat.parseInt(\"1.0\") // 1.0\nFloat.parseInt(\"  3.14   \") // 3.0\nFloat.parseInt(3) // 3.0\nFloat.parseInt(\"3.14some non-digit characters\") // 3.0\nFloat.parseInt(\"error\")->Float.isNaN // true\n```"]
    }, 
    {
      "id": "RescriptCore.Float.parseIntWithRadix",
      "kind": "value",
      "name": "parseIntWithRadix",
      "signature": "let parseIntWithRadix: ('a, ~radix: int) => float",
      "docstrings": ["`parseIntWithRadix(v, ~radix)` parse the given `v` and returns a float. Leading\nwhitespace in this argument `v`is ignored. `radix` specifies the radix base to\nuse for the formatted number. The value must be in the range [2, 36] (inclusive).\nReturns `NaN` if `v` can't be parsed and `radix` is smaller than 2 or bigger\nthan 36.\nSee [`parseInt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt) on MDN.\n\n## Examples\n\n```rescript\nFloat.parseInt(\"10.0\", ~radix=2) // 2.0\nFloat.parseInt(\"15 * 3\", ~radix=10) // 15.0\nFloat.parseInt(\"12\", ~radix=13) // 15.0\nFloat.parseInt(\"17\", ~radix=40)->Float.isNaN // true\n```"]
    }, 
    {
      "id": "RescriptCore.Float.toExponential",
      "kind": "value",
      "name": "toExponential",
      "signature": "let toExponential: float => string",
      "docstrings": ["`toExponential(v)` return a `string` representing the given value in exponential\nnotation.\nSee [`Number.toExponential`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential) on MDN.\n\n## Examples\n\n```rescript\nFloat.toExponential(1000.0) // \"1e+3\"\nFloat.toExponential(-1000.0) // \"-1e+3\"\n```"]
    }, 
    {
      "id": "RescriptCore.Float.toExponentialWithPrecision",
      "kind": "value",
      "name": "toExponentialWithPrecision",
      "signature": "let toExponentialWithPrecision: (float, ~digits: int) => string",
      "docstrings": ["`toExponential(v, ~digits)` return a `string` representing the given value in\nexponential notation. `digits` specifies how many digits should appear after\nthe decimal point.\nSee [`Number.toExponential`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential) on MDN.\n\n## Examples\n\n```rescript\nFloat.toExponentialWithPrecision(77.0, ~digits=2) // \"7.70e+1\"\nFloat.toExponentialWithPrecision(5678.0, ~digits=2) // \"5.68e+3\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` less than 0 or greater than 10."]
    }, 
    {
      "id": "RescriptCore.Float.toFixed",
      "kind": "value",
      "name": "toFixed",
      "signature": "let toFixed: float => string",
      "docstrings": ["`toFixed(v)` return a `string` representing the given value using fixed-point\nnotation.\nSee [`Number.toFixed`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) on MDN.\n\n## Examples\n\n```rescript\nFloat.toFixed(123456.0) // \"123456.00\"\nFloat.toFixed(10.0) // \"10.00\"\n```"]
    }, 
    {
      "id": "RescriptCore.Float.toFixedWithPrecision",
      "kind": "value",
      "name": "toFixedWithPrecision",
      "signature": "let toFixedWithPrecision: (float, ~digits: int) => string",
      "docstrings": ["`toFixedWithPrecision(v, ~digits)` return a `string` representing the given\nvalue using fixed-point notation. `digits` specifies how many digits should\nappear after the decimal point.\nSee [`Number.toFixed`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) on MDN.\n\n## Examples\n\n```rescript\nFloat.toFixed(300.0, ~digits=4) // \"300.0000\"\nFloat.toFixed(300.0, ~digits=1) // \"300.0\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` is less than 0 or larger than 100."]
    }, 
    {
      "id": "RescriptCore.Float.toPrecision",
      "kind": "value",
      "name": "toPrecision",
      "signature": "let toPrecision: float => string",
      "docstrings": ["`toPrecision(v)` return a `string` representing the giver value with precision.\nThis function omits the argument that controls precision, so it behaves like\n`toString`. See `toPrecisionWithPrecision` to control precision.\nSee [`Number.toPrecision`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision) on MDN.\n\n## Examples\n\n```rescript\nFloat.toPrecision(100.0) // \"100\"\nFloat.toPrecision(1.0) // \"1\"\n```"]
    }, 
    {
      "id": "RescriptCore.Float.toPrecisionWithPrecision",
      "kind": "value",
      "name": "toPrecisionWithPrecision",
      "signature": "let toPrecisionWithPrecision: (float, ~digits: int) => string",
      "docstrings": ["`toPrecision(v, ~digits)` return a `string` representing the giver value with\nprecision. `digits` specifies the number of significant digits.\nSee [`Number.toPrecision`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision) on MDN.\n\n## Examples\n\n```rescript\nFloat.toPrecision(100.0, ~digits=2) // \"1.0e+2\"\nFloat.toPrecision(1.0) // \"1.0\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` is not between 1 and 100 (inclusive).\nImplementations are allowed to support larger and smaller values as well.\nECMA-262 only requires a precision of up to 21 significant digits."]
    }, 
    {
      "id": "RescriptCore.Float.toString",
      "kind": "value",
      "name": "toString",
      "signature": "let toString: float => string",
      "docstrings": ["`toString(v)` return a `string` representing the given value.\nSee [`Number.toString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString) on MDN.\n\n## Examples\n\n```rescript\nFloat.toString(1000.0) // \"1000\"\nFloat.toString(-1000.0) // \"-1000\"\n```"]
    }, 
    {
      "id": "RescriptCore.Float.toStringWithRadix",
      "kind": "value",
      "name": "toStringWithRadix",
      "signature": "let toStringWithRadix: (float, ~radix: int) => string",
      "docstrings": ["`toStringWithRadix(v, ~radix)` return a `string` representing the given value.\n`~radix` specifies the radix base to use for the formatted number.\nSee [`Number.toString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString) on MDN.\n\n## Examples\n\n```rescript\nFloat.toString(6.0, ~radix=2) // \"110\"\nFloat.toString(3735928559.0, ~radix=16) // \"deadbeef\"\nFloat.toStringWithRadix(123456.0, ~radix=36) // \"2n9c\"\n```\n\n## Exceptions\n\n`RangeError`: if `radix` is less than 2 or greater than 36."]
    }, 
    {
      "id": "RescriptCore.Float.toLocaleString",
      "kind": "value",
      "name": "toLocaleString",
      "signature": "let toLocaleString: float => string",
      "docstrings": ["`toLocaleString(v)` return a `string` with language-sensitive representing the\ngiven value.\nSee [`Number.toLocaleString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString) on MDN.\n\n## Examples\n\n```rescript\n// If the application uses English as the default language\nInt.toLocaleString(1000.0) // \"1,000\"\n\n// If the application uses Portuguese Brazil as the default language\nInt.toLocaleString(1000.0) // \"1.000\"\n```"]
    }, 
    {
      "id": "RescriptCore.Float.fromString",
      "kind": "value",
      "name": "fromString",
      "signature": "let fromString: string => option<float>",
      "docstrings": ["`fromString(str)` return an `option<int>` representing the given value `str`.\n\n## Examples\n\n```rescript\nFloat.fromString(\"0\") == Some(0.0)\nFloat.fromString(\"NaN\") == None\nFloat.fromString(\"6\") == Some(6.0)\n```"]
    }, 
    {
      "id": "RescriptCore.Float.toInt",
      "kind": "value",
      "name": "toInt",
      "signature": "let toInt: float => int",
      "docstrings": ["`toInt(v)` returns an int to given float `v`.\n\n## Examples\n\n```rescript\nFloat.toInt(2.0) == 2\nFloat.toInt(1.0) == 1\nFloat.toInt(1.1) == 1\nFloat.toInt(1.6) == 1\n```"]
    }, 
    {
      "id": "RescriptCore.Float.fromInt",
      "kind": "value",
      "name": "fromInt",
      "signature": "let fromInt: int => float",
      "docstrings": ["`fromInt(v)` returns a float to given int `v`.\n\n## Examples\n\n```rescript\nFloat.fromInt(2) == 2.0\nFloat.fromInt(1) == 1.0\n```"]
    }, 
    {
      "id": "RescriptCore.Float.mod",
      "kind": "value",
      "name": "mod",
      "signature": "let mod: (float, float) => float",
      "docstrings": ["`mod(n1, n2)` calculates the modulo (remainder after division) of two floats.\n\n## Examples\n\n```rescript\nInt.mod(7.0, 4.0) == 3\n```"]
    }, 
    {
      "id": "RescriptCore.Float.clamp",
      "kind": "value",
      "name": "clamp",
      "signature": "let clamp: (~min: float=?, ~max: float=?, float) => float",
      "docstrings": ["`clamp(~min=?, ~max=?, value)` returns `value`, optionally bounded by `min` and `max`.\n\nif `max` < `min` returns `min`.\n\n## Examples\n\n```rescript\nInt.clamp(4.2) == 4.2\nInt.clamp(4.2, ~min=4.3) == 4.3\nInt.clamp(4.2, ~max=4.1) == 4.1\nInt.clamp(4.2, ~min=4.3, ~max=4.1) == 4.3\n```"]
    }]
  }, 
  {
    "id": "RescriptCore.Int",
    "kind": "moduleAlias",
    "name": "Int",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Int.Constants",
      "name": "Constants",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.Int.Constants.minValue",
        "kind": "value",
        "name": "minValue",
        "signature": "let minValue: int",
        "docstrings": ["The smallest positive number represented in JavaScript.\n  See [`Number.MIN_VALUE`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_VALUE)\n  on MDN.\n\n  ## Examples\n\n  ```rescript\n  Console.log(Int.Constants.minValue)\n  ```"]
      }, 
      {
        "id": "RescriptCore.Int.Constants.maxValue",
        "kind": "value",
        "name": "maxValue",
        "signature": "let maxValue: int",
        "docstrings": ["The largest positive number represented in JavaScript.\n  See [`Number.MAX_VALUE`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_VALUE)\n  on MDN.\n\n  ## Examples\n\n  ```rescript\n  Console.log(Int.Constants.maxValue)\n  ```"]
      }]
    }, 
    {
      "id": "RescriptCore.Int.equal",
      "kind": "value",
      "name": "equal",
      "signature": "let equal: (int, int) => bool",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Int.compare",
      "kind": "value",
      "name": "compare",
      "signature": "let compare: (int, int) => Core__Ordering.t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Int.toExponential",
      "kind": "value",
      "name": "toExponential",
      "signature": "let toExponential: int => string",
      "docstrings": ["`toExponential(n)` return a `string` representing the given value in exponential\nnotation.\nSee [`Number.toExponential`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential)\non MDN.\n\n## Examples\n\n```rescript\nInt.toExponential(1000) // \"1e+3\"\nInt.toExponential(-1000) // \"-1e+3\"\n```"]
    }, 
    {
      "id": "RescriptCore.Int.toExponentialWithPrecision",
      "kind": "value",
      "name": "toExponentialWithPrecision",
      "signature": "let toExponentialWithPrecision: (int, ~digits: int) => string",
      "docstrings": ["`toExponential(n, ~digits)` return a `string` representing the given value in\nexponential notation. `digits` specifies how many digits should appear after\nthe decimal point. See [`Number.toExponential`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential)\non MDN.\n\n## Examples\n\n```rescript\nInt.toExponentialWithPrecision(77, ~digits=2) // \"7.70e+1\"\nInt.toExponentialWithPrecision(5678, ~digits=2) // \"5.68e+3\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` less than 0 or greater than 10."]
    }, 
    {
      "id": "RescriptCore.Int.toFixed",
      "kind": "value",
      "name": "toFixed",
      "signature": "let toFixed: int => string",
      "docstrings": ["`toFixed(n)` return a `string` representing the given value using fixed-point\nnotation. See [`Number.toFixed`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)\non MDN.\n\n\n## Examples\n\n```rescript\nInt.toFixed(123456) // \"123456.00\"\nInt.toFixed(10) // \"10.00\"\n```"]
    }, 
    {
      "id": "RescriptCore.Int.toFixedWithPrecision",
      "kind": "value",
      "name": "toFixedWithPrecision",
      "signature": "let toFixedWithPrecision: (int, ~digits: int) => string",
      "docstrings": ["`toFixedWithPrecision(n, ~digits)` return a `string` representing the given\nvalue using fixed-point notation. `digits` specifies how many digits should\nappear after the decimal point. See [`Number.toFixed`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)\non MDN.\n\n## Examples\n\n```rescript\nInt.toFixed(300, ~digits=4) // \"300.0000\"\nInt.toFixed(300, ~digits=1) // \"300.0\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` is less than 0 or larger than 100."]
    }, 
    {
      "id": "RescriptCore.Int.toPrecision",
      "kind": "value",
      "name": "toPrecision",
      "signature": "let toPrecision: int => string",
      "docstrings": ["`toPrecision(n)` return a `string` representing the giver value with precision.\nThis function omits the argument that controls precision, so it behaves like\n`toString`. See `toPrecisionWithPrecision` to control precision. See [`Number.toPrecision`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision) on MDN.\n\n## Examples\n\n```rescript\nInt.toPrecision(100) // \"100\"\nInt.toPrecision(1) // \"1\"\n```"]
    }, 
    {
      "id": "RescriptCore.Int.toPrecisionWithPrecision",
      "kind": "value",
      "name": "toPrecisionWithPrecision",
      "signature": "let toPrecisionWithPrecision: (int, ~digits: int) => string",
      "docstrings": ["`toPrecision(n, ~digits)` return a `string` representing the giver value with\nprecision. `digits` specifies the number of significant digits. See [`Number.toPrecision`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision) on MDN.\n\n## Examples\n\n```rescript\nInt.toPrecision(100, ~digits=2) // \"1.0e+2\"\nInt.toPrecision(1) // \"1.0\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` is not between 1 and 100 (inclusive).\nImplementations are allowed to support larger and smaller values as well.\nECMA-262 only requires a precision of up to 21 significant digits."]
    }, 
    {
      "id": "RescriptCore.Int.toString",
      "kind": "value",
      "name": "toString",
      "signature": "let toString: int => string",
      "docstrings": ["`toString(n)` return a `string` representing the given value.\nSee [`Number.toString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString)\non MDN.\n\n## Examples\n\n```rescript\nInt.toString(1000) // \"1000\"\nInt.toString(-1000) // \"-1000\"\n```"]
    }, 
    {
      "id": "RescriptCore.Int.toStringWithRadix",
      "kind": "value",
      "name": "toStringWithRadix",
      "signature": "let toStringWithRadix: (int, ~radix: int) => string",
      "docstrings": ["`toStringWithRadix(n, ~radix)` return a `string` representing the given value.\n`~radix` specifies the radix base to use for the formatted number.\nSee [`Number.toString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString)\non MDN.\n\n## Examples\n\n```rescript\nInt.toString(6, ~radix=2) // \"110\"\nInt.toString(3735928559, ~radix=16) // \"deadbeef\"\nInt.toStringWithRadix(123456, ~radix=36) // \"2n9c\"\n```\n\n## Exceptions\n\n`RangeError`: if `radix` is less than 2 or greater than 36."]
    }, 
    {
      "id": "RescriptCore.Int.toLocaleString",
      "kind": "value",
      "name": "toLocaleString",
      "signature": "let toLocaleString: int => string",
      "docstrings": ["`toLocaleString(n)` return a `string` with language-sensitive representing the\ngiven value. See [`Number.toLocaleString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString) on MDN.\n\n## Examples\n\n```rescript\n// If the application uses English as the default language\nInt.toLocaleString(1000) // \"1,000\"\n\n// If the application uses Portuguese Brazil as the default language\nInt.toLocaleString(1000) // \"1.000\"\n```"]
    }, 
    {
      "id": "RescriptCore.Int.toFloat",
      "kind": "value",
      "name": "toFloat",
      "signature": "let toFloat: int => float",
      "docstrings": ["`toFloat(n)` return a `float` representing the given value.\n\n## Examples\n\n```rescript\nInt.toFloat(100) == 100.0\nInt.toFloat(2) == 2.0\n```"]
    }, 
    {
      "id": "RescriptCore.Int.fromFloat",
      "kind": "value",
      "name": "fromFloat",
      "signature": "let fromFloat: float => int",
      "docstrings": ["`fromFloat(n)` return an `int` representing the given value. The conversion is\ndone by truncating the decimal part.\n\n## Examples\n\n```rescript\nInt.fromFloat(2.0) == 2\nInt.fromFloat(1.999) == 1\nInt.fromFloat(1.5) == 1\nInt.fromFloat(0.9999) == 0\n```"]
    }, 
    {
      "id": "RescriptCore.Int.fromString",
      "kind": "value",
      "name": "fromString",
      "signature": "let fromString: (~radix: int=?, string) => option<int>",
      "docstrings": ["`fromString(~radix?, str)` return an `option<int>` representing the given value\n`str`. `~radix` specifies the radix base to use for the formatted number.\n\n## Examples\n\n```rescript\nInt.fromString(\"0\") == Some(0)\nInt.fromString(\"NaN\") == None\nInt.fromString(~radix=2, \"6\") == None\n```"]
    }, 
    {
      "id": "RescriptCore.Int.mod",
      "kind": "value",
      "name": "mod",
      "signature": "let mod: (int, int) => int",
      "docstrings": ["`mod(n1, n2)` calculates the modulo (remainder after division) of two integers.\n\n## Examples\n\n```rescript\nInt.mod(7, 4) == 3\n```"]
    }, 
    {
      "id": "RescriptCore.Int.range",
      "kind": "value",
      "name": "range",
      "signature": "let range: (int, int) => array<int>",
      "docstrings": ["`range(start, end)` returns an int array of the sequence of integers in the\nrange `[start, end)`. That is, including `start` but excluding `end`.\n\nIf `start < end` the sequence will be increasing in steps of 1.\n\nIf `start > end` the sequence will be decreasing in steps of -1.\n\nThis is equivalent to `rangeWithOptions` with `inclusive` set to `false` and\n`step` set to `1` if `start < end` and `-1` otherwise.\n\n## Examples\n\n```rescript\nInt.range(3, 6) == [3, 4, 5]\nInt.range(-3, -1) == [-3, -2]\nInt.range(3, 1) == [3, 2]\n```"]
    }, 
    {
      "id": "RescriptCore.Int.rangeOptions",
      "kind": "type",
      "name": "rangeOptions",
      "signature": "type rangeOptions = {step?: int, inclusive?: bool}",
      "docstrings": ["The options for `rangeWithOptions`."],
      "detail": 
      {
        "kind": "record",
        "items": [{
          "name": "step",
          "optional": true,
          "docstrings": [],
          "signature": "option<int>"
        }, {
          "name": "inclusive",
          "optional": true,
          "docstrings": [],
          "signature": "option<bool>"
        }]
      }
    }, 
    {
      "id": "RescriptCore.Int.rangeWithOptions",
      "kind": "value",
      "name": "rangeWithOptions",
      "signature": "let rangeWithOptions: (int, int, rangeOptions) => array<int>",
      "docstrings": ["`rangeWithOptions(start, end, options)` is like `range`, but with `step` and\n`inclusive` options configurable.\n\nIf `step` is set, the sequence will increase or decrease by that amount for each\nstep. If `start < end` and `step` is negative, or vice versa, an empty array is\nreturned since the sequence would otherwise never reach or exceed the end value\nand hence be infinite. If `step` is `0` and `start !=` end, a `RangeError` is\nraised as the sequence would never reach or exceed the end value and hence be\ninfinite.\n\nIf `inclusive` is set to `true`, the sequence will include `end` if `step` is\nset such that the sequence includes it.\n\n## Examples\n\n```rescript\nInt.rangeWithOptions(3, 7, {step: 2}) == [3, 5]\nInt.rangeWithOptions(3, 7, {step: 2, inclusive: true}) == [3, 5, 7]\nInt.rangeWithOptions(3, 6, {step: -2}) // RangeError\n```\n\n## Exceptions\n\n- Raises `RangeError` if `step == 0 && start != end`."]
    }, 
    {
      "id": "RescriptCore.Int.clamp",
      "kind": "value",
      "name": "clamp",
      "signature": "let clamp: (~min: int=?, ~max: int=?, int) => int",
      "docstrings": ["`clamp(~min=?, ~max=?, value)` returns `value`, optionally bounded by `min` and `max`.\n\nif `max` < `min` returns `min`.\n\n## Examples\n\n```rescript\nInt.clamp(42) == 42\nInt.clamp(42, ~min=50) == 50\nInt.clamp(42, ~max=40) == 40\nInt.clamp(42, ~min=50, ~max=40) == 50\n```"]
    }]
  }, 
  {
    "id": "RescriptCore.BigInt",
    "kind": "moduleAlias",
    "name": "BigInt",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.BigInt.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = Js.Types.bigint_val",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.asIntN",
      "kind": "value",
      "name": "asIntN",
      "signature": "let asIntN: (~width: int, t) => t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.asUintN",
      "kind": "value",
      "name": "asUintN",
      "signature": "let asUintN: (~width: int, t) => t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.fromString",
      "kind": "value",
      "name": "fromString",
      "signature": "let fromString: string => t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.fromInt",
      "kind": "value",
      "name": "fromInt",
      "signature": "let fromInt: int => t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.fromFloat",
      "kind": "value",
      "name": "fromFloat",
      "signature": "let fromFloat: float => t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.toString",
      "kind": "value",
      "name": "toString",
      "signature": "let toString: t => string",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.toStringWithRadix",
      "kind": "value",
      "name": "toStringWithRadix",
      "signature": "let toStringWithRadix: (t, ~radix: int) => string",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.toLocaleString",
      "kind": "value",
      "name": "toLocaleString",
      "signature": "let toLocaleString: t => string",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.toFloat",
      "kind": "value",
      "name": "toFloat",
      "signature": "let toFloat: t => float",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.toInt",
      "kind": "value",
      "name": "toInt",
      "signature": "let toInt: t => int",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.+",
      "kind": "value",
      "name": "+",
      "signature": "let _: %rescript.typehole",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.-",
      "kind": "value",
      "name": "-",
      "signature": "let _: %rescript.typehole",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.*",
      "kind": "value",
      "name": "*",
      "signature": "let _: %rescript.typehole",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt./",
      "kind": "value",
      "name": "/",
      "signature": "let _: %rescript.typehole",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.add",
      "kind": "value",
      "name": "add",
      "signature": "let add: (t, t) => t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.sub",
      "kind": "value",
      "name": "sub",
      "signature": "let sub: (t, t) => t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.mul",
      "kind": "value",
      "name": "mul",
      "signature": "let mul: (t, t) => t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.div",
      "kind": "value",
      "name": "div",
      "signature": "let div: (t, t) => t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.mod",
      "kind": "value",
      "name": "mod",
      "signature": "let mod: (t, t) => t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.land",
      "kind": "value",
      "name": "land",
      "signature": "let land: (t, t) => t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.lor",
      "kind": "value",
      "name": "lor",
      "signature": "let lor: (t, t) => t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.lxor",
      "kind": "value",
      "name": "lxor",
      "signature": "let lxor: (t, t) => t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.lsl",
      "kind": "value",
      "name": "lsl",
      "signature": "let lsl: (t, t) => t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.asr",
      "kind": "value",
      "name": "asr",
      "signature": "let asr: (t, t) => t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.BigInt.exp",
      "kind": "value",
      "name": "exp",
      "signature": "let exp: (t, t) => 'a",
      "docstrings": []
    }]
  }, 
  {
    "id": "RescriptCore.Math",
    "kind": "moduleAlias",
    "name": "Math",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Math.Constants",
      "name": "Constants",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.Math.Constants.e",
        "kind": "value",
        "name": "e",
        "signature": "let e: float",
        "docstrings": ["`Math.Constants.e` returns Euler's number, ≈ 2.718281828459045.\n  See [`Math.E`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/E) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Constants.e\n  ```"]
      }, 
      {
        "id": "RescriptCore.Math.Constants.ln2",
        "kind": "value",
        "name": "ln2",
        "signature": "let ln2: float",
        "docstrings": ["`Math.Constants.ln2` returns Natural logarithm of 2, ≈ 0.6931471805599453.\n  See [`Math.LN2`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/LN2) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Constants.LN2\n  ```"]
      }, 
      {
        "id": "RescriptCore.Math.Constants.ln10",
        "kind": "value",
        "name": "ln10",
        "signature": "let ln10: float",
        "docstrings": ["`Math.Constants.ln10` returns Natural logarithm of 10, ≈ 2.302585092994046.\n  See [`Math.LN10`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/LN10) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Constants.ln10\n  ```"]
      }, 
      {
        "id": "RescriptCore.Math.Constants.log2e",
        "kind": "value",
        "name": "log2e",
        "signature": "let log2e: float",
        "docstrings": ["`Math.Constants.log2e` returns Base 2 logarithm of E, ≈ 1.4426950408889634.\n  See [`Math.LOG2E`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/LOG2E) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Constants.log2e\n  ```"]
      }, 
      {
        "id": "RescriptCore.Math.Constants.log10e",
        "kind": "value",
        "name": "log10e",
        "signature": "let log10e: float",
        "docstrings": ["`Math.Constants.log10e` returns Base 10 logarithm of E, ≈ 0.4342944819032518.\n  See [`Math.LOG10E`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/LOG10E) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Constants.log10e\n  ```"]
      }, 
      {
        "id": "RescriptCore.Math.Constants.pi",
        "kind": "value",
        "name": "pi",
        "signature": "let pi: float",
        "docstrings": ["`Math.Constants.pi` returns Pi - ratio of the circumference to the diameter\n  of a circle, ≈ 3.141592653589793.\n  See [`Math.PI`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/PI) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Constants.pi\n  ```"]
      }, 
      {
        "id": "RescriptCore.Math.Constants.sqrt1_2",
        "kind": "value",
        "name": "sqrt1_2",
        "signature": "let sqrt1_2: float",
        "docstrings": ["`Math.Constants.sqrt1_2` returns Square root of 1/2, ≈ 0.7071067811865476.\n  See [`Math.SQRT1_2`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/SQRT1_2) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Constants.sqrt1_2\n  ```"]
      }, 
      {
        "id": "RescriptCore.Math.Constants.sqrt2",
        "kind": "value",
        "name": "sqrt2",
        "signature": "let sqrt2: float",
        "docstrings": ["`Math.Constants.e` returns Absolute value for integer argument.\n  See [`Math.abs`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/abs) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Constants.sqrt2\n  ```"]
      }]
    }, 
    {
      "id": "RescriptCore.Math.Int",
      "name": "Int",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.Math.Int.abs",
        "kind": "value",
        "name": "abs",
        "signature": "let abs: int => int",
        "docstrings": ["`abs(v)` returns absolute value of `v`.\n  See [`Math.abs`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/abs) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Int.abs(-2) // 2\n  Math.Int.abs(3) // 3\n  ```"]
      }, 
      {
        "id": "RescriptCore.Math.Int.clz32",
        "kind": "value",
        "name": "clz32",
        "signature": "let clz32: int => int",
        "docstrings": ["`clz32(v)` returns the number of leading zero bits of the argument's 32 bit\n  int representation.\n  See [`Math.clz32`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32) on MDN.\n\n  ## Examples\n\n  ```rescript\n  // 00000000000000000000000000000001\n  Math.Int.clz32(1) // 31\n  // 00000000000000000000000000000100\n  Math.Int.clz32(4) // 29\n  ```"]
      }, 
      {
        "id": "RescriptCore.Math.Int.imul",
        "kind": "value",
        "name": "imul",
        "signature": "let imul: (int, int) => int",
        "docstrings": ["`imul(a, b)` returns 32-bit integer multiplication. Use this only when you\n  need to optimize performance of multiplication of numbers stored as 32-bit\n  integers.\n  See [`Math.imul`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Int.imul(3, 4) // 12\n  Math.Int.imul(-5, 12) // 60\n  ```"]
      }, 
      {
        "id": "RescriptCore.Math.Int.min",
        "kind": "value",
        "name": "min",
        "signature": "let min: (int, int) => int",
        "docstrings": ["`min(a, b)` returns the minimum of its two integer arguments.\n  See [`Math.min`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/min) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Int.min(1, 2) // 1\n  Math.Int.min(-1, -2) // -2\n  ```"]
      }, 
      {
        "id": "RescriptCore.Math.Int.minMany",
        "kind": "value",
        "name": "minMany",
        "signature": "let minMany: array<int> => int",
        "docstrings": ["`minMany(arr)` returns the minimum of the integers in the given array `arr`.\n  Returns `Infinity` if `arr` is empty.\n  See [`Math.min`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/min) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Int.minMany([1, 2]) // 1\n  Math.Int.minMany([-1, -2]) // -2\n  Math.Int.minMany([])->Float.isFinite // false\n  ```"]
      }, 
      {
        "id": "RescriptCore.Math.Int.max",
        "kind": "value",
        "name": "max",
        "signature": "let max: (int, int) => int",
        "docstrings": ["`max(a, b)` returns the maximum of its two integer arguments.\n  See [`Math.max`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Int.max(1, 2) // 2\n  Math.Int.max(-1, -2) // -1\n  ```"]
      }, 
      {
        "id": "RescriptCore.Math.Int.maxMany",
        "kind": "value",
        "name": "maxMany",
        "signature": "let maxMany: array<int> => int",
        "docstrings": ["`maxMany(arr)` returns the maximum of the integers in the given array `arr`.\n  Returns `Infinity` if `arr` is empty.\n  See [`Math.max`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Int.maxMany([1, 2]) // 2\n  Math.Int.maxMany([-1, -2]) // -1\n  Math.Int.maxMany([])->Float.isFinite // false\n  ```"]
      }, 
      {
        "id": "RescriptCore.Math.Int.pow",
        "kind": "value",
        "name": "pow",
        "signature": "let pow: (int, ~exp: int) => int",
        "docstrings": ["`pow(a, ~exp)` raises the given base `a` to the given exponent `exp`.\n  See [`Math.pow`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/pow) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Int.pow(2, ~exp=4) // 16\n  Math.Int.pow(3, ~exp=4) // 81\n  ```"]
      }, 
      {
        "id": "RescriptCore.Math.Int.sign",
        "kind": "value",
        "name": "sign",
        "signature": "let sign: int => int",
        "docstrings": ["`sign(v)` returns the sign of its integer argument: `-1` if negative, `0` if\n  zero, `1` if positive.\n  See [`Math.sign`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Int.sign(3) // 1\n  Math.Int.sign(-3) // 1\n  Math.Int.sign(0) // 0\n  ```"]
      }]
    }, 
    {
      "id": "RescriptCore.Math.abs",
      "kind": "value",
      "name": "abs",
      "signature": "let abs: float => float",
      "docstrings": ["`abs(v)` returns absolute value of `v`.\nSee [`Math.abs`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/abs) on MDN.\n\n## Examples\n\n```rescript\nMath.abs(-2.0) // 2.0\nMath.abs(3.0) // 3.0\n```"]
    }, 
    {
      "id": "RescriptCore.Math.acos",
      "kind": "value",
      "name": "acos",
      "signature": "let acos: float => float",
      "docstrings": ["`acos(v)` returns arccosine (in radians) of argument `v`, returns `NaN` if the\nargument is outside the range [-1.0, 1.0].\nSee [`Math.acos`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/acos) on MDN.\n\n## Examples\n\n```rescript\nMath.acos(-1) // 3.141592653589793\nMath.acos(-3)->Float.isNaN // true\n```"]
    }, 
    {
      "id": "RescriptCore.Math.acosh",
      "kind": "value",
      "name": "acosh",
      "signature": "let acosh: float => float",
      "docstrings": ["`acosh(v)` returns the inverse hyperbolic arccosine (in radians) of argument `v`,\nreturns `NaN` if the argument is less than `1.0`.\nSee [`Math.acosh`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/acosh) on MDN.\n\n## Examples\n\n```rescript\nMath.acosh(1) // 0.0\nMath.acosh(0.5)->Float.isNaN // true\n```"]
    }, 
    {
      "id": "RescriptCore.Math.asin",
      "kind": "value",
      "name": "asin",
      "signature": "let asin: float => float",
      "docstrings": ["`asin(v)` returns the inverse sine (in radians) of argument `v`, returns `NaN`\nif the argument `v` is outside the range [-1.0, 1.0].\nSee [`Math.asin`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/asin) on MDN.\n\n## Examples\n\n```rescript\nMath.asin(-1.0) // -1.5707963267948966\nMath.asin(-2.0)->Float.isNaN // true\n```"]
    }, 
    {
      "id": "RescriptCore.Math.asinh",
      "kind": "value",
      "name": "asinh",
      "signature": "let asinh: float => float",
      "docstrings": ["`asinh(v)` returns the inverse hyperbolic sine of argument `v`.\nSee [`Math.asinh`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/asinh) on MDN.\n\n## Examples\n\n```rescript\nMath.asinh(-1) // -0.881373587019543\nMath.asinh(-0) // -0.0\n```"]
    }, 
    {
      "id": "RescriptCore.Math.atan",
      "kind": "value",
      "name": "atan",
      "signature": "let atan: float => float",
      "docstrings": ["`atan(v)` returns the inverse tangent (in radians) of argument `v`.\nSee [`Math.atan`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atan) on MDN.\n\n## Examples\n\n```rescript\nMath.atan(-0.0) // -0.0\nMath.atan(0.0) // 0.0\nMath.atan(1) // 0.7853981633974483\n```"]
    }, 
    {
      "id": "RescriptCore.Math.atanh",
      "kind": "value",
      "name": "atanh",
      "signature": "let atanh: float => float",
      "docstrings": ["`atanh(v)` returns the invert hyperbolic tangent of argument `v`. Returns `NaN`\nif the argument `v` is is outside the range [-1.0, 1.0] and `Infinity` if `v`\nis `-1.0` or `1.0`.\nSee [`Math.atanh`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atanh) on MDN.\n\n## Examples\n\n```rescript\nMath.atanh(-2.0)->Float.isNaN // true\nMath.atanh(-1.0)->Float.isFinite // false\nMath.atanh(-0.0) // -0.0\nMath.atanh(0.0) // 0.0\nMath.atanh(0.5) // 0.5493061443340548\n```"]
    }, 
    {
      "id": "RescriptCore.Math.atan2",
      "kind": "value",
      "name": "atan2",
      "signature": "let atan2: (~y: float, ~x: float) => float",
      "docstrings": ["`atan2(~y, ~x)` returns the angle (in radians) of the quotient `y /. x`. It is\nalso the angle between the *x*-axis and point (*x*, *y*).\nSee [`Math.atan2`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atan2) on MDN.\n\n## Examples\n\n```rescript\nMath.atan2(~y=0.0, ~x=10.0) == 0.0\nMath.atan2(~x=5.0, ~y=5.0) == Math.Constants.pi /. 4.0\nMath.atan2(~x=90.0, ~y=15.0) // 1.4056476493802699\nMath.atan2(~x=15.0, ~y=90.0) // 0.16514867741462683\n```"]
    }, 
    {
      "id": "RescriptCore.Math.cbrt",
      "kind": "value",
      "name": "cbrt",
      "signature": "let cbrt: float => float",
      "docstrings": ["`cbrt(v)` returns the cube root of argument `v`.\nSee [`Math.cbrt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cbrt) on MDN.\n\n## Examples\n\n```rescript\nMath.cbrt(-1.0) // -1.0\nMath.cbrt(-0.0) // -0.0\nMath.cbrt(0.0) // 0.0\n```"]
    }, 
    {
      "id": "RescriptCore.Math.ceil",
      "kind": "value",
      "name": "ceil",
      "signature": "let ceil: float => float",
      "docstrings": ["`ceil(v)` returns the smallest integral value greater than or equal to the\nargument `v`. The result is a `float` and is not restricted to the `int` data\ntype range.\nSee [`Math.ceil`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil) on MDN.\n\n## Examples\n\n```rescript\nMath.ceil(3.1) == 4.0\nMath.ceil(3.0) == 3.0\nMath.ceil(-3.1) == -3.0\nMath.ceil(2_150_000_000.3) == 2_150_000_001.0\n```"]
    }, 
    {
      "id": "RescriptCore.Math.cos",
      "kind": "value",
      "name": "cos",
      "signature": "let cos: float => float",
      "docstrings": ["`cos(v)` returns the cosine of argument `v`, which must be specified in radians.\nSee [`Math.cos`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cos) on MDN.\n\n## Examples\n\n```rescript\nMath.cos(-0.0) // 1.0\nMath.cos(0.0) // 1.0\nMath.cos(1.0) // 0.5403023058681398\n```"]
    }, 
    {
      "id": "RescriptCore.Math.cosh",
      "kind": "value",
      "name": "cosh",
      "signature": "let cosh: float => float",
      "docstrings": ["`cosh(v)` returns the hyperbolic cosine of argument `v`, which must be specified\nin radians.\nSee [`Math.cosh`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cosh) on MDN.\n\n## Examples\n\n```rescript\nMath.cosh(-1.0) // 1.5430806348152437\nMath.cosh(-0.0) // 1.0\nMath.cosh(0.0) // 1.0\n```"]
    }, 
    {
      "id": "RescriptCore.Math.exp",
      "kind": "value",
      "name": "exp",
      "signature": "let exp: float => float",
      "docstrings": ["`exp(v)` returns natural exponentional, returns *e* (the base of natural logarithms)\nto the power of the given argument `v`.\nSee [`Math.exp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/exp) on MDN.\n\n## Examples\n\n```rescript\nMath.exp(-1.0) // 0.36787944117144233\nMath.exp(0.0) // 1.0\n```"]
    }, 
    {
      "id": "RescriptCore.Math.expm1",
      "kind": "value",
      "name": "expm1",
      "signature": "let expm1: float => float",
      "docstrings": ["`expm1(v)` returns *e* (the base of natural logarithms) to the power of the given\nargument `v` minus 1.\nSee [`Math.expm1`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/expm1) on MDN.\n\n## Examples\n\n```rescript\nMath.expm1(-1.0) // -0.6321205588285577\nMath.expm1(-0.0) // -0\n```"]
    }, 
    {
      "id": "RescriptCore.Math.floor",
      "kind": "value",
      "name": "floor",
      "signature": "let floor: float => float",
      "docstrings": ["`floor(v)` returns the largest integral value less than or equal to the argument\n`v`. The result is a `float` and is not restricted to the `int` data type range.\nSee [`Math.floor`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor) on MDN.\n\n## Examples\n\n```rescript\nMath.floor(-45.95) // -46.0\nMath.floor(-45.05) // -46.0\nMath.floor(-0.0) // -0.0\n```"]
    }, 
    {
      "id": "RescriptCore.Math.fround",
      "kind": "value",
      "name": "fround",
      "signature": "let fround: float => float",
      "docstrings": ["`fround(v)` returns the nearest single precision float.\nSee [`Math.fround`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround) on MDN.\n\n## Examples\n\n```rescript\nMath.fround(5.5) == 5.5\nMath.fround(5.05) == 5.050000190734863\n```"]
    }, 
    {
      "id": "RescriptCore.Math.hypot",
      "kind": "value",
      "name": "hypot",
      "signature": "let hypot: (float, float) => float",
      "docstrings": ["`hypot(a, b)` returns the square root of the sum of squares of its two arguments\n(the Pythagorean formula).\nSee [`Math.hypot`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/hypot) on MDN.\n\n## Examples\n\n```rescript\nMath.hypot(3.0, 4.0) // 5.0\nMath.hypot(3.0, 5.0) // 5.8309518948453\n```"]
    }, 
    {
      "id": "RescriptCore.Math.hypotMany",
      "kind": "value",
      "name": "hypotMany",
      "signature": "let hypotMany: array<float> => float",
      "docstrings": ["`hypotMany(arr)` returns the square root of the sum of squares of the numbers in\nthe array argument (generalized Pythagorean equation). Using an array allows you\nto have more than two items. If `arr` is an empty array then returns `0.0`.\nSee [`Math.hypot`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/hypot) on MDN.\n\n## Examples\n\n```rescript\nMath.hypot([3.0, 4.0, 5.0]) // 7.0710678118654755\nMath.hypot([]) // 0.0\n```"]
    }, 
    {
      "id": "RescriptCore.Math.log",
      "kind": "value",
      "name": "log",
      "signature": "let log: float => float",
      "docstrings": ["`log(v)` returns the natural logarithm of argument `v`, this is the number *x*\nsuch that `e^x` equals the argument. Returns `NaN` for negative arguments and\n`Infinity` for `0.0` or `-0.0`.\nSee [`Math.log`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log) on MDN.\n\n## Examples\n\n```rescript\nMath.log(-1.0)->Float.isNaN // true\nMath.log(-0.0)->Float.isFinite // false\nMath.log(0.0)->Float.isFinite // false\nMath.log(1.0) // 0\n```"]
    }, 
    {
      "id": "RescriptCore.Math.log1p",
      "kind": "value",
      "name": "log1p",
      "signature": "let log1p: float => float",
      "docstrings": ["`log1p(v)` returns the natural logarithm of one plus the argument `v`.\nReturns `NaN` for arguments less than `-1` and `Infinity` if `v` is `-1.0`.\nSee [`Math.log1p`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log1p) on MDN.\n\n## Examples\n\n```rescript\nMath.log1p(-2.0)->Float.isNaN // true\nMath.log1p(-1.0)->Float.isFinite // false\nMath.log1p(-0.0) // -0\n```"]
    }, 
    {
      "id": "RescriptCore.Math.log10",
      "kind": "value",
      "name": "log10",
      "signature": "let log10: float => float",
      "docstrings": ["`log10(v)` returns the base 10 logarithm of argument `v`. Returns `NaN` for\nnegative `v`. If `v` is `-0.0` or `0.0` returns `Infinity`.\nSee [`Math.log10`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log10) on MDN.\n\n## Examples\n\n```rescript\nMath.log10(-2.0)->Float.isNaN // true\nMath.log10(-0.0)->Float.isFinite // false\nMath.log10(0.0)->Float.isFinite // false\nMath.log10(1.0) // 0\n```"]
    }, 
    {
      "id": "RescriptCore.Math.log2",
      "kind": "value",
      "name": "log2",
      "signature": "let log2: float => float",
      "docstrings": ["`log2(v)` returns the base 2 logarithm of argument `v`. Returns `NaN` for\nnegative `v` and `Infinity` if `v` is `-0.0` or `0.0`.\nSee [`Math.log2`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log2) on MDN.\n\n## Examples\n\n```rescript\nMath.log2(-2.0)->Float.isNaN // true\nMath.log2(-0.0)->Float.isFinite // false\nMath.log2(0.0)->Float.isFinite // false\nMath.log2(1.0) // 0.0\n```"]
    }, 
    {
      "id": "RescriptCore.Math.min",
      "kind": "value",
      "name": "min",
      "signature": "let min: (float, float) => float",
      "docstrings": ["`min(a, b)` returns the minimum of its two float arguments.\nSee [`Math.min`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/min) on MDN.\n\n## Examples\n\n```rescript\nMath.min(1.0, 2.0) // 1.0\nMath.min(-1.0, -2.0) // -2.0\n```"]
    }, 
    {
      "id": "RescriptCore.Math.minMany",
      "kind": "value",
      "name": "minMany",
      "signature": "let minMany: array<float> => float",
      "docstrings": ["`minMany(arr)` returns the minimum of the float in the given array `arr`.\nReturns `Infinity` if `arr` is empty.\nSee [`Math.min`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/min) on MDN.\n\n## Examples\n\n```rescript\nMath.minMany([1.0, 2.0]) // 1.0\nMath.minMany([-1.0, -2.0]) // -2.0\nMath.minMany([])->Float.isFinite // false\n```"]
    }, 
    {
      "id": "RescriptCore.Math.max",
      "kind": "value",
      "name": "max",
      "signature": "let max: (float, float) => float",
      "docstrings": ["`max(a, b)` returns the maximum of its two float arguments.\nSee [`Math.max`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max) on MDN.\n\n## Examples\n\n```rescript\nMath.max(1.0, 2.0) // 2.0\nMath.max(-1.0, -2.0) // -1.0\n```"]
    }, 
    {
      "id": "RescriptCore.Math.maxMany",
      "kind": "value",
      "name": "maxMany",
      "signature": "let maxMany: array<float> => float",
      "docstrings": ["`maxMany(arr)` returns the maximum of the float in the given array `arr`.\nReturns `Infinity` if `arr` is empty.\nSee [`Math.max`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max) on MDN.\n\n## Examples\n\n```rescript\nMath.maxMany([1.0, 2.0]) // 2.0\nMath.maxMany([-1.0, -2.0]) // -1.0\nMath.maxMany([])->Float.isFinite // false\n```"]
    }, 
    {
      "id": "RescriptCore.Math.pow",
      "kind": "value",
      "name": "pow",
      "signature": "let pow: (float, ~exp: float) => float",
      "docstrings": ["`pow(a, ~exp)` raises the given base `a` to the given exponent `exp`.\nSee [`Math.pow`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/pow) on MDN.\n\n## Examples\n\n```rescript\nMath.pow(2.0, ~exp=4.0) // 16.0\nMath.pow(3.0, ~exp=4.0) // 81.0\n```"]
    }, 
    {
      "id": "RescriptCore.Math.random",
      "kind": "value",
      "name": "random",
      "signature": "let random: unit => float",
      "docstrings": ["`random()` returns a random number in the half-closed interval [0,1].\nSee [`Math.random`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random) on MDN.\n\n## Examples\n\n```rescript\nMath.random()\n```"]
    }, 
    {
      "id": "RescriptCore.Math.round",
      "kind": "value",
      "name": "round",
      "signature": "let round: float => float",
      "docstrings": ["`round(v)` returns then value of `v` rounded to nearest integral value\n(expressed as a float). If the fractional portion of the argument `v` is greater\nthan `0.5`, the argument `v` is rounded to the float with the next higher\nabsolute value.\nSee [`Math.round`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round) on MDN.\n\n## Examples\n\n```rescript\nMath.round(-20.5) // -20.0\nMath.round(-0.1) // -0.0\nMath.round(0.0) // 0.0\nMath.round(-0.0) // -0.0\n```"]
    }, 
    {
      "id": "RescriptCore.Math.sign",
      "kind": "value",
      "name": "sign",
      "signature": "let sign: float => float",
      "docstrings": ["`sign(v)` returns the sign of its foat argument: `-1` if negative, `0` if\nzero, `1` if positive.\nSee [`Math.sign`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign) on MDN.\n\n## Examples\n\n```rescript\nMath.sign(3.0) // 1.0\nMath.sign(-3.0) // 1.0\nMath.sign(0.0) // 0.0\n```"]
    }, 
    {
      "id": "RescriptCore.Math.sin",
      "kind": "value",
      "name": "sin",
      "signature": "let sin: float => float",
      "docstrings": ["`sin(v)` returns the sine of argument `v`, which must be specified in radians.\nSee [`Math.sin`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sin) on MDN.\n\n## Examples\n\n```rescript\nMath.sin(-0.0) // -0.0\nMath.sin(0.0) // 0.0\nMath.sin(1.0) // 0.8414709848078965\n```"]
    }, 
    {
      "id": "RescriptCore.Math.sinh",
      "kind": "value",
      "name": "sinh",
      "signature": "let sinh: float => float",
      "docstrings": ["`sinh(v)` returns then hyperbolic sine of argument `v`, which must be specified\nin radians.\nSee [`Math.sinh`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sinh) on MDN.\n\n## Examples\n\n```rescript\nMath.sinh(-0.0) // -0.0\nMath.sinh(0.0) // 0.0\nMath.sinh(1.0) // 1.1752011936438014\n```"]
    }, 
    {
      "id": "RescriptCore.Math.sqrt",
      "kind": "value",
      "name": "sqrt",
      "signature": "let sqrt: float => float",
      "docstrings": ["`sqrt(v)` returns the square root of `v`. If `v` is negative returns `NaN`.\nSee [`Math.sqrt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sqrt) on MDN.\n\n## Examples\n\n```rescript\nMath.sqrt(-1.0)->Float.isNaN // true\nMath.sqrt(-0.0) // -0.0\nMath.sqrt(0.0) // 0.0\nMath.sqrt(1.0) // 1.0\nMath.sqrt(9.0) // 3.0\n```"]
    }, 
    {
      "id": "RescriptCore.Math.tan",
      "kind": "value",
      "name": "tan",
      "signature": "let tan: float => float",
      "docstrings": ["`tan(v)` returns the tangent of argument `v`, which must be specified in\nradians. Returns `NaN` if `v` is positive `Infinity` or negative `Infinity`.\nSee [`Math.tan`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/tan) on MDN.\n\n## Examples\n\n```rescript\nMath.tan(-0.0) // -0.0\nMath.tan(0.0) // 0.0\nMath.tan(1.0) // 1.5574077246549023\n```"]
    }, 
    {
      "id": "RescriptCore.Math.tanh",
      "kind": "value",
      "name": "tanh",
      "signature": "let tanh: float => float",
      "docstrings": ["`tanh(v)` returns the hyperbolic tangent of argument `v`, which must be\nspecified in radians.\nSee [`Math.tanh`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/tanh) on MDN.\n\n## Examples\n\n```rescript\nMath.tanh(-0.0) // -0.0\nMath.tanh(0.0) // 0.0\nMath.tanh(1.0) // 0.7615941559557649\n```"]
    }, 
    {
      "id": "RescriptCore.Math.trunc",
      "kind": "value",
      "name": "trunc",
      "signature": "let trunc: float => float",
      "docstrings": ["`trunc(v)` truncates the argument `v`, i.e., removes fractional digits.\nSee [`Math.trunc`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc) on MDN.\n\n## Examples\n\n```rescript\nMath.trunc(0.123) // 0.0\nMath.trunc(1.999) // 1.0\nMath.trunc(13.37) // 13.0\nMath.trunc(42.84) // 42.0\n```"]
    }]
  }, 
  {
    "id": "RescriptCore.Null",
    "kind": "moduleAlias",
    "name": "Null",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Null.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'a> = Js.Null.t<'a>",
      "docstrings": ["A type representing a value that can be either `'a` or `null`."]
    }, 
    {
      "id": "RescriptCore.Null.asNullable",
      "kind": "value",
      "name": "asNullable",
      "signature": "let asNullable: t<'a> => Core__Nullable.t<'a>",
      "docstrings": ["Converts a `Null.t` into a `Nullable.t`.\n\n## Examples\n```rescript\nlet nullValue = Null.make(\"Hello\")\nlet asNullable = nullValue->Null.asNullable // Nullable.t<string>\n```"]
    }, 
    {
      "id": "RescriptCore.Null.null",
      "kind": "value",
      "name": "null",
      "signature": "let null: t<'a>",
      "docstrings": ["The value `null`.\n\nSee [`null`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/null) on MDN.\n\n## Examples\n```rescript\nConsole.log(null) // Logs `null` to the console.\n```"]
    }, 
    {
      "id": "RescriptCore.Null.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: 'a => t<'a>",
      "docstrings": ["Creates a new `Null.t` from the provided value.\nThis means the compiler will enforce null checks for the new value.\n\n## Examples\n```rescript\nlet myStr = \"Hello\"\nlet asNullValue = myStr->Null.make // The compiler now thinks this can be `string` or `null`.\n```"]
    }, 
    {
      "id": "RescriptCore.Null.equal",
      "kind": "value",
      "name": "equal",
      "signature": "let equal: (t<'a>, t<'b>, ('a, 'b) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Null.compare",
      "kind": "value",
      "name": "compare",
      "signature": "let compare: (t<'a>, t<'b>, ('a, 'b) => Core__Ordering.t) => Core__Ordering.t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Null.toOption",
      "kind": "value",
      "name": "toOption",
      "signature": "let toOption: t<'a> => option<'a>",
      "docstrings": ["Converts a nullable value into an option, so it can be pattern matched on.\nWill convert `null` to `None`, and a present value to `Some(value)`.\n\n## Examples\n```rescript\nlet nullStr = Null.make(\"Hello\")\n\nswitch nullStr->Null.toOption {\n| Some(str) => Console.log2(\"Got string:\", str)\n| None => Console.log(\"Didn't have a value.\")\n}\n```"]
    }, 
    {
      "id": "RescriptCore.Null.fromOption",
      "kind": "value",
      "name": "fromOption",
      "signature": "let fromOption: option<'a> => t<'a>",
      "docstrings": ["Turns an `option` into a `Null.t`. `None` will be converted to `null`.\n\n## Examples\n```rescript\nlet optString: option<string> = None\nlet asNull = optString->Null.fromOption // Null.t<string>\nConsole.log(asNull == null) // Logs `true` to the console.\n```"]
    }, 
    {
      "id": "RescriptCore.Null.getOr",
      "kind": "value",
      "name": "getOr",
      "signature": "let getOr: (t<'a>, 'a) => 'a",
      "docstrings": ["`getOr(value, default)` returns `value` if not `null`, otherwise return\n`default`.\n\n## Examples\n\n```rescript\nNull.getOr(null, \"Banana\") // Banana\nNull.getOr(Nulalble.make(\"Apple\"), \"Banana\") // Apple\n\nlet greet = (firstName: option<string>) =>\n  \"Greetings \" ++ firstName->Null.getOr(\"Anonymous\")\n\nNull.make(\"Jane\")->greet // \"Greetings Jane\"\nnull->greet // \"Greetings Anonymous\"\n```"]
    }, 
    {
      "id": "RescriptCore.Null.getWithDefault",
      "kind": "value",
      "name": "getWithDefault",
      "deprecated": "Use getOr instead",
      "signature": "let getWithDefault: (t<'a>, 'a) => 'a",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Null.getExn",
      "kind": "value",
      "name": "getExn",
      "signature": "let getExn: t<'a> => 'a",
      "docstrings": ["`getExn(value)` raises an exception if `null`, otherwise returns the value.\n\n```rescript\nNull.getExn(Null.make(3)) // 3\nNull.getExn(null) /* Raises an Error */\n```\n\n## Exceptions\n\n- Raises `Invalid_argument` if `value` is `null`,"]
    }, 
    {
      "id": "RescriptCore.Null.getUnsafe",
      "kind": "value",
      "name": "getUnsafe",
      "signature": "let getUnsafe: t<'a> => 'a",
      "docstrings": ["`getUnsafe(value)` returns `value`.\n\n## Examples\n\n```rescript\nNull.getUnsafe(Null.make(3)) == 3\nNull.getUnsafe(null) // Raises an error\n```\n\n## Important\n\n- This is an unsafe operation, it assumes `value` is not `null`."]
    }, 
    {
      "id": "RescriptCore.Null.map",
      "kind": "value",
      "name": "map",
      "signature": "let map: (t<'a>, 'a => 'b) => t<'b>",
      "docstrings": ["`map(value, f)` returns `f(value)` if `value` is not `null`, otherwise returns\n`value` unchanged.\n\n## Examples\n\n```rescript\nNull.map(Null.make(3), x => x * x) // Null.make(9)\nNull.map(null, x => x * x) // null\n```"]
    }, 
    {
      "id": "RescriptCore.Null.mapOr",
      "kind": "value",
      "name": "mapOr",
      "signature": "let mapOr: (t<'a>, 'b, 'a => 'b) => 'b",
      "docstrings": ["`mapOr(value, default, f)` returns `f(value)` if `value` is not `null`,\notherwise returns `default`.\n\n## Examples\n\n```rescript\nlet someValue = Null.make(3)\nsomeValue->Null.mapOr(0, x => x + 5) // 8\n\nlet noneValue = null\nnoneValue->Null.mapOr(0, x => x + 5) // 0\n```"]
    }, 
    {
      "id": "RescriptCore.Null.mapWithDefault",
      "kind": "value",
      "name": "mapWithDefault",
      "deprecated": "Use mapOr instead",
      "signature": "let mapWithDefault: (t<'a>, 'b, 'a => 'b) => 'b",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Null.flatMap",
      "kind": "value",
      "name": "flatMap",
      "signature": "let flatMap: (t<'a>, 'a => t<'b>) => t<'b>",
      "docstrings": ["`flatMap(value, f)` returns `f(value)` if `value` is not `null`, otherwise\nreturns `value` unchanged.\n\n## Examples\n\n```rescript\nlet addIfAboveOne = value =>\n  if (value > 1) {\n    Null.make(value + 1)\n  } else {\n    null\n  }\n\nNull.flatMap(Null.make(2), addIfAboveOne) // Null.make(3)\nNull.flatMap(Null.make(-4), addIfAboveOne) // null\nNull.flatMap(null, addIfAboveOne) // null\n```"]
    }]
  }, 
  {
    "id": "RescriptCore.Nullable",
    "kind": "moduleAlias",
    "name": "Nullable",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Nullable.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'a> = Js.Nullable.t<'a>",
      "docstrings": ["Type representing a nullable value.\nA nullable value can be the value `'a`, `null` or `undefined`."]
    }, 
    {
      "id": "RescriptCore.Nullable.null",
      "kind": "value",
      "name": "null",
      "signature": "let null: t<'a>",
      "docstrings": ["The value `null`.\n\nSee [`null`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/null) on MDN.\n\n## Examples\n```rescript\nConsole.log(Nullable.null) // Logs `null` to the console.\n```"]
    }, 
    {
      "id": "RescriptCore.Nullable.undefined",
      "kind": "value",
      "name": "undefined",
      "signature": "let undefined: t<'a>",
      "docstrings": ["The value `undefined`.\n\nSee [`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/undefined) on MDN.\n\n## Examples\n```rescript\nConsole.log(undefined) // Logs `undefined` to the console.\n```"]
    }, 
    {
      "id": "RescriptCore.Nullable.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: 'a => t<'a>",
      "docstrings": ["Creates a new nullable value from the provided value.\nThis means the compiler will enforce null checks for the new value.\n\n## Examples\n```rescript\nlet myStr = \"Hello\"\nlet asNullable = myStr->Nullable.make\n\n// Can't do the below because we're now forced to check for nullability\n// myStr == asNullable\n\n// Need to do this\nswitch asNullable->Nullable.toOption {\n| Some(value) if value == myStr => Console.log(\"Yay, values matched!\")\n| _ => Console.log(\"Values did not match.\")\n}\n```"]
    }, 
    {
      "id": "RescriptCore.Nullable.equal",
      "kind": "value",
      "name": "equal",
      "signature": "let equal: (t<'a>, t<'b>, ('a, 'b) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Nullable.compare",
      "kind": "value",
      "name": "compare",
      "signature": "let compare: (t<'a>, t<'b>, ('a, 'b) => Core__Ordering.t) => Core__Ordering.t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Nullable.toOption",
      "kind": "value",
      "name": "toOption",
      "signature": "let toOption: t<'a> => option<'a>",
      "docstrings": ["Converts a nullable value into an option, so it can be pattern matched on.\nWill convert both `null` and `undefined` to `None`, and a present value to `Some(value)`.\n\n## Examples\n```rescript\nlet nullableString = Nullable.make(\"Hello\")\n\nswitch nullableString->Nullable.toOption {\n| Some(str) => Console.log2(\"Got string:\", str)\n| None => Console.log(\"Didn't have a value.\")\n}\n```"]
    }, 
    {
      "id": "RescriptCore.Nullable.fromOption",
      "kind": "value",
      "name": "fromOption",
      "signature": "let fromOption: option<'a> => t<'a>",
      "docstrings": ["Turns an `option` into a `Nullable.t`.\n\n## Examples\n```rescript\nlet optString = Some(\"Hello\")\nlet asNullable = optString->Nullable.fromOption // Nullable.t<string>\n```"]
    }, 
    {
      "id": "RescriptCore.Nullable.getOr",
      "kind": "value",
      "name": "getOr",
      "signature": "let getOr: (t<'a>, 'a) => 'a",
      "docstrings": ["`getOr(value, default)` returns `value` if not `null` or `undefined`,\notherwise return `default`.\n\n## Examples\n\n```rescript\nNullable.getOr(Nullable.null, \"Banana\") // Banana\nNullable.getOr(Nulalble.make(\"Apple\"), \"Banana\") // Apple\n\nlet greet = (firstName: option<string>) =>\n  \"Greetings \" ++ firstName->Nullable.getOr(\"Anonymous\")\n\nNullable.make(\"Jane\")->greet // \"Greetings Jane\"\nNullable.null->greet // \"Greetings Anonymous\"\n```"]
    }, 
    {
      "id": "RescriptCore.Nullable.getWithDefault",
      "kind": "value",
      "name": "getWithDefault",
      "deprecated": "Use getOr instead",
      "signature": "let getWithDefault: (t<'a>, 'a) => 'a",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Nullable.getExn",
      "kind": "value",
      "name": "getExn",
      "signature": "let getExn: t<'a> => 'a",
      "docstrings": ["`getExn(value)` raises an exception if `null` or `undefined`, otherwise returns the value.\n\n```rescript\nNullable.getExn(Nullable.make(3)) // 3\nNullable.getExn(Nullable.null) /* Raises an Error */\n```\n\n## Exceptions\n\n- Raises `Invalid_argument` if `value` is `null` or `undefined`"]
    }, 
    {
      "id": "RescriptCore.Nullable.getUnsafe",
      "kind": "value",
      "name": "getUnsafe",
      "signature": "let getUnsafe: t<'a> => 'a",
      "docstrings": ["`getUnsafe(value)` returns `value`.\n\n## Examples\n\n```rescript\nNullable.getUnsafe(Nullable.make(3)) == 3\nNullable.getUnsafe(Nullable.null) // Raises an error\n```\n\n## Important\n\n- This is an unsafe operation, it assumes `value` is not `null` or `undefined`."]
    }, 
    {
      "id": "RescriptCore.Nullable.map",
      "kind": "value",
      "name": "map",
      "signature": "let map: (t<'a>, 'a => 'b) => t<'b>",
      "docstrings": ["`map(value, f)` returns `f(value)` if `value` is not `null` or `undefined`,\notherwise returns `value` unchanged.\n\n## Examples\n\n```rescript\nNullable.map(Nullable.make(3), x => x * x) // Nullable.make(9)\nNullable.map(undefined, x => x * x) // undefined\n```"]
    }, 
    {
      "id": "RescriptCore.Nullable.mapOr",
      "kind": "value",
      "name": "mapOr",
      "signature": "let mapOr: (t<'a>, 'b, 'a => 'b) => 'b",
      "docstrings": ["`mapOr(value, default, f)` returns `f(value)` if `value` is not `null`\nor `undefined`, otherwise returns `default`.\n\n## Examples\n\n```rescript\nlet someValue = Nullable.make(3)\nsomeValue->Nullable.mapOr(0, x => x + 5) // 8\n\nlet noneValue = Nullable.null\nnoneValue->Nullable.mapOr(0, x => x + 5) // 0\n```"]
    }, 
    {
      "id": "RescriptCore.Nullable.mapWithDefault",
      "kind": "value",
      "name": "mapWithDefault",
      "deprecated": "Use mapOr instead",
      "signature": "let mapWithDefault: (t<'a>, 'b, 'a => 'b) => 'b",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Nullable.flatMap",
      "kind": "value",
      "name": "flatMap",
      "signature": "let flatMap: (t<'a>, 'a => t<'b>) => t<'b>",
      "docstrings": ["`flatMap(value, f)` returns `f(value)` if `value` is not `null` or `undefined`,\notherwise returns `value` unchanged.\n\n## Examples\n\n```rescript\nlet addIfAboveOne = value =>\n  if (value > 1) {\n    Nullable.make(value + 1)\n  } else {\n    Nullable.null\n  }\n\nNullable.flatMap(Nullable.make(2), addIfAboveOne) // Nullable.make(3)\nNullable.flatMap(Nullable.make(-4), addIfAboveOne) // undefined\nNullable.flatMap(Nullable.null, addIfAboveOne) // undefined\n```"]
    }]
  }, 
  {
    "id": "RescriptCore.Object",
    "kind": "moduleAlias",
    "name": "Object",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Object.empty",
      "kind": "value",
      "name": "empty",
      "signature": "let empty: unit => {..}",
      "docstrings": ["`empty` create a new object that inherits the properties and methods from the standard built-in Object, such as `toString`. See [Object on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)\n\n## Examples\n\n```rescript\nlet x = Object.empty()\nx->Object.keysToArray->Array.length // 0\nx->Object.get(\"toString\")->Option.isSome // true\n```"]
    }, 
    {
      "id": "RescriptCore.Object.is",
      "kind": "value",
      "name": "is",
      "signature": "let is: ('a, 'a) => bool",
      "docstrings": ["`is` determines if two objects are identical in all contexts. Objects, arrays, records, and other non-primitives are only identical if they reference the **exact** same object in memory. Primitives like ints, floats, and strings are identical if they have the same value. `+0` and `-0` are distinct. NaN is equal to itself. See [Object.is on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)\n\nIn most scenarios use `==` or `===` or the custom `equals` function (if provided) for the type.\n\n## Examples\n\n```rescript\nObject.is(25, 13) // false\nObject.is(\"abc\", \"abc\") // true\nObject.is(undefined, undefined) // true\nObject.is(undefined, null) // false\nObject.is(-0.0, 0.0) // false\nObject.is(list{1, 2}, list{1, 2}) // false\n\nObject.is([1, 2, 3], [1, 2, 3]) // false\n[1, 2, 3] == [1, 2, 3] // true\n[1, 2, 3] === [1, 2, 3] // false\n\nlet fruit = {\"name\": \"Apple\" }\nObject.is(fruit, fruit) // true\nObject.is(fruit, {\"name\": \"Apple\" }) // false\nfruit == {\"name\": \"Apple\" } // true\nfruit === {\"name\": \"Apple\" } // false\n```"]
    }, 
    {
      "id": "RescriptCore.Object.create",
      "kind": "value",
      "name": "create",
      "signature": "let create: {..} => {..}",
      "docstrings": ["`create` creates a new object, using an existing object as the prototype of the new object. See [Object.create on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create)\n\n**Note:** ReScript provides [first-class support for immutable objects](https://rescript-lang.org/docs/manual/latest/object) and [records](https://rescript-lang.org/docs/manual/latest/record). This is often safer and more convenient than using `create` and other functions in this module.\n\n## Examples\n\n```rescript\nlet x = {\"fruit\": \"banana\"}\nlet y = Object.create(x)\ny->Object.get(\"fruit\") // Some(\"banana\")\n```"]
    }, 
    {
      "id": "RescriptCore.Object.createWithProperties",
      "kind": "value",
      "name": "createWithProperties",
      "signature": "let createWithProperties: ({..}, {..}) => {..}",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Object.createWithNull",
      "kind": "value",
      "name": "createWithNull",
      "signature": "let createWithNull: unit => {..}",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Object.createWithNullAndProperties",
      "kind": "value",
      "name": "createWithNullAndProperties",
      "signature": "let createWithNullAndProperties: {..} => {..}",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Object.assign",
      "kind": "value",
      "name": "assign",
      "signature": "let assign: ({..}, {..}) => {..}",
      "docstrings": ["`assign(target, source)` copies enumerable own properties from the source to the target, overwriting properties with the same name. It returns the modified target object. A deep clone is not created; properties are copied by reference.\n\n**Warning:** ReScript provides compile-time support for type-safe access to JavaScript objects. This eliminates common errors such as accessing properties that do not exist, or using a property of type x as if it were a y. Using `assign` can bypass these safety checks and lead to run-time errors (if you are not careful). ReScript provides [first-class support for immutable objects](https://rescript-lang.org/docs/manual/latest/object) and [records](https://rescript-lang.org/docs/manual/latest/record). This is often safer and more convenient than using `assign` and other functions in this module.\n\nSee [Object.assign on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) or [ECMAScript Language Specification](https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.assign).\n\n## Examples\n\n```rescript\nObject.assign({\"a\": 1}, {\"a\": 2}) // {\"a\": 2}\nObject.assign({\"a\": 1, \"b\": 2}, {\"a\": 0}) // {\"a\": 0, \"b\": 2}\nObject.assign({\"a\": 1}, {\"a\": null}) // {\"a\": null}\n```"]
    }, 
    {
      "id": "RescriptCore.Object.assignMany",
      "kind": "value",
      "name": "assignMany",
      "signature": "let assignMany: ({..}, array<{..}>) => {..}",
      "docstrings": ["`assignMany(target, sources)` copies enumerable own properties from each source to the target, overwriting properties with the same name. Later sources' properties overwrite earlier ones. It returns the modified target object. A deep clone is not created; properties are copied by reference.\n\n**Note:** ReScript provides [first-class support for immutable objects](https://rescript-lang.org/docs/manual/latest/object), including spreading one object into another. This is often more convenient than using `assign` or `assignMany`.  \n\nSee [Object.assign on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) or [ECMAScript Language Specification](https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.assign)."]
    }, 
    {
      "id": "RescriptCore.Object.copy",
      "kind": "value",
      "name": "copy",
      "signature": "let copy: {..} => {..}",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Object.get",
      "kind": "value",
      "name": "get",
      "signature": "let get: ({..}, string) => option<'a>",
      "docstrings": ["`get` gets the value of a property by name. Returns `None` if the property does not exist or has the value `undefined`. Otherwise returns `Some`, including if the value is `null`.\n\n## Examples\n\n```rescript\n{\"a\": 1}->Object.get(\"a\") // Some(1)\n{\"a\": 1}->Object.get(\"b\") // None\n{\"a\": undefined}->Object.get(\"a\") // None\n{\"a\": null}->Object.get(\"a\") // Some(null)\n{\"a\": 1}->Object.get(\"toString\")->Option.isSome // true\n```"]
    }, 
    {
      "id": "RescriptCore.Object.getSymbol",
      "kind": "value",
      "name": "getSymbol",
      "signature": "let getSymbol: ({..}, Core__Symbol.t) => option<'a>",
      "docstrings": ["`getSymbol` gets the value of a property by symbol. Returns `None` if the property does not exist or has the value `undefined`. Otherwise returns `Some`, including if the value is `null`.\n\n## Examples\n\n```rescript\nlet fruit = Symbol.make(\"fruit\")\nlet x = Object.empty()\nx->Object.setSymbol(fruit, \"banana\")\nx->Object.getSymbol(fruit) // Some(\"banana\")\n```"]
    }, 
    {
      "id": "RescriptCore.Object.getSymbolUnsafe",
      "kind": "value",
      "name": "getSymbolUnsafe",
      "signature": "let getSymbolUnsafe: ({..}, Core__Symbol.t) => 'a",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Object.set",
      "kind": "value",
      "name": "set",
      "signature": "let set: ({..}, string, 'a) => unit",
      "docstrings": ["`set(name, value)` assigns a value to the named object property, overwriting the previous value if any. See [Working with Objects on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#objects_and_properties)\n\n## Examples\n\n```rescript\n{\"a\": 1}->Object.set(\"a\", 2) // {\"a\": 2}\n{\"a\": 1}->Object.set(\"a\", None) // {\"a\": None}\n{\"a\": 1}->Object.set(\"b\", 2) // {\"a\": 1, \"b\": 2}\n```"]
    }, 
    {
      "id": "RescriptCore.Object.setSymbol",
      "kind": "value",
      "name": "setSymbol",
      "signature": "let setSymbol: ({..}, Core__Symbol.t, 'a) => unit",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Object.keysToArray",
      "kind": "value",
      "name": "keysToArray",
      "signature": "let keysToArray: {..} => array<string>",
      "docstrings": ["`keysToArray` returns an array of an object's own enumerable string-keyed property names. See [ECMAScript Language Specification](https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.keys) \nor [Object.keys on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys).\n\n## Examples\n\n```rescript\n{\"a\": 1, \"b\": 2}->Object.keysToArray // [\"a\", \"b\"]\n{\"a\": None}->Object.keysToArray // [\"a\"]\nObject.empty()->Object.keysToArray // []\n```"]
    }, 
    {
      "id": "RescriptCore.Object.hasOwnProperty",
      "kind": "value",
      "name": "hasOwnProperty",
      "signature": "let hasOwnProperty: ({..}, string) => bool",
      "docstrings": ["`hasOwnProperty` determines whether the object has the specified property as its **own** property, as opposed to inheriting it. See [hasOwnProperty on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty)\n\n## Examples\n\n```rescript\nlet point = {\"x\": 1, \"y\": 2}\n{\"a\": 1}->hasOwnProperty(\"a\") // true\n{\"a\": 1}->hasOwnProperty(\"b\") // false\n{\"a\": 1}->hasOwnProperty(\"toString\") // false\n```"]
    }, 
    {
      "id": "RescriptCore.Object.seal",
      "kind": "value",
      "name": "seal",
      "signature": "let seal: {..} => {..}",
      "docstrings": ["`seal` seals an object. Sealing an object prevents extensions and makes existing properties non-configurable. A sealed object has a fixed set of properties. Unlike `freeze`, values of existing properties can still be changed as long as they are writable. \n\n**Note:** `seal` returns the same object that was passed in; it does not create a copy. Any attempt to delete or add properties to a sealed object will fail, either silently or by throwing an error. \n\nSee [ECMAScript Language Specification](https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.seal) and [Object.seal on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal)\n\n## Examples\n\n```rescript\nlet point = {\"x\": 1, \"y\": 2}\npoint->Object.set(\"x\", -7) // succeeds\npoint->Object.seal->ignore\npoint->Object.set(\"z\", 9) // fails\npoint->Object.set(\"x\", 13) // succeeds\n```"]
    }, 
    {
      "id": "RescriptCore.Object.preventExtensions",
      "kind": "value",
      "name": "preventExtensions",
      "signature": "let preventExtensions: {..} => {..}",
      "docstrings": ["`preventExtensions` prevents new properties from being added to the object. It modifies the object (rather than creating a copy) and returns it.\n\nSee [ECMAScript Language Specification](https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.preventextensions) and [Object.preventExtensions on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions)\n\n## Examples\n\n```rescript\nlet obj = {\"a\": 1}\nobj->Object.set(\"b\", 2) // succeeds\nobj->Object.preventExtensions->ignore\nobj->Object.set(\"c\", 3) // fails\n```"]
    }, 
    {
      "id": "RescriptCore.Object.freeze",
      "kind": "value",
      "name": "freeze",
      "signature": "let freeze: {..} => {..}",
      "docstrings": ["`freeze` freezes an object. Freezing an object makes existing properties non-writable and prevents extensions. Once an object is frozen, new properties cannot be be added, existing properties cannot be removed, and their values cannot be changed.\n\n**Note:** `freeze` returns the same object that was passed in; it does not create a frozen copy. Any attempt to change a frozen object will fail, either silently or by throwing an exception.\n\nSee [ECMAScript Language Specification](https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.isfrozen) and [Object.isFrozen on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen).\n\n## Examples\n\n ```rescript\nlet obj = {\"a\": 1}\nobj->Object.set(\"a\", 2) // succeeds\nobj->Object.freeze->ignore\nobj->Object.set(\"a\", 3) // fails\n```"]
    }, 
    {
      "id": "RescriptCore.Object.isSealed",
      "kind": "value",
      "name": "isSealed",
      "signature": "let isSealed: 'a => bool",
      "docstrings": ["`isSealed` determines if an object is sealed. A sealed object has a fixed set of properties.\n\nSee [ECMAScript Language Specification](https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.issealed) and [Object.isSealed on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed)\n\n## Examples\n\n```rescript\nlet point = {\"x\": 1, \"y\": 3}->Object.seal\nlet pointIsSealed = point->Object.isSealed // true\nlet fruit = {\"name\": \"Apple\" }\nlet fruitIsSealed = fruit->Object.isSealed // false\n ```"]
    }, 
    {
      "id": "RescriptCore.Object.isFrozen",
      "kind": "value",
      "name": "isFrozen",
      "signature": "let isFrozen: 'a => bool",
      "docstrings": ["`isFrozen` determines if an object is frozen. An object is frozen if an only if it is not extensible, all its properties are non-configurable, and all its data properties are non-writable.\n\nSee [ECMAScript Language Specification](https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.isfrozen) and [Object.isFrozen on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen).\n\n## Examples\n\n```rescript\nlet point = {\"x\": 1, \"y\": 3}->Object.freeze\nlet pointIsFrozen = point->Object.isFrozen // true\nlet fruit = {\"name\": \"Apple\" }\nlet fruitIsFrozen = fruit->Object.isFrozen // false\n ```"]
    }, 
    {
      "id": "RescriptCore.Object.isExtensible",
      "kind": "value",
      "name": "isExtensible",
      "signature": "let isExtensible: 'a => bool",
      "docstrings": ["`isExtensible` determines if an object is extensible (whether it can have new properties added to it).\n\nSee [ECMAScript Language Specification](https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.isextensible) and [Object.isExtensible on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible)\n\n## Examples\n\n```rescript\nlet obj = {\"a\": 1}\nobj->Object.isExtensible // true\nobj->Object.preventExtensions->ignore\nobj->Object.isExtensible // false\n```"]
    }]
  }, 
  {
    "id": "RescriptCore.Ordering",
    "kind": "moduleAlias",
    "name": "Ordering",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Ordering.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = float",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Ordering.less",
      "kind": "value",
      "name": "less",
      "signature": "let less: float",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Ordering.equal",
      "kind": "value",
      "name": "equal",
      "signature": "let equal: float",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Ordering.greater",
      "kind": "value",
      "name": "greater",
      "signature": "let greater: float",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Ordering.isLess",
      "kind": "value",
      "name": "isLess",
      "signature": "let isLess: float => bool",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Ordering.isEqual",
      "kind": "value",
      "name": "isEqual",
      "signature": "let isEqual: float => bool",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Ordering.isGreater",
      "kind": "value",
      "name": "isGreater",
      "signature": "let isGreater: float => bool",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Ordering.invert",
      "kind": "value",
      "name": "invert",
      "signature": "let invert: float => float",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Ordering.fromInt",
      "kind": "value",
      "name": "fromInt",
      "signature": "let fromInt: int => float",
      "docstrings": []
    }]
  }, 
  {
    "id": "RescriptCore.Promise",
    "kind": "moduleAlias",
    "name": "Promise",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Promise.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'a> = promise<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Promise.resolve",
      "kind": "value",
      "name": "resolve",
      "signature": "let resolve: 'a => t<'a>",
      "docstrings": ["`resolve(value)` creates a resolved Promise with a given `value`.\nSee [`Promise.resolve`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve) on MDN.\n\n## Examples\n\n```rescript\nlet p = Promise.resolve(5) // promise<int>\n```"]
    }, 
    {
      "id": "RescriptCore.Promise.reject",
      "kind": "value",
      "name": "reject",
      "signature": "let reject: exn => t<'a>",
      "docstrings": ["`reject(exn)` reject a Promise.\nSee [`Promise.reject`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject) on MDN.\n\n## Examples\n\n```rescript\nexception TestError(string)\n\nlet p = Promise.reject(TestError(\"some rejected value\"))\n```"]
    }, 
    {
      "id": "RescriptCore.Promise.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: (((. 'a) => unit, (. 'e) => unit) => unit) => t<'a>",
      "docstrings": ["`make(callback)` creates a new Promise based on a `callback` that receives two\nuncurried functions `resolve` and `reject` for defining the Promise's result.\n\n## Examples\n\n```rescript\nopen Promise\n\nlet n = 4\nPromise.make((resolve, reject) => {\n  if(n < 5) {\n    resolve(. \"success\")\n  }\n  else {\n    reject(. \"failed\")\n  }\n})\n->then(str => {\n  Console.log(str)->resolve\n})\n->catch(e => {\n  Console.log(\"Error occurred\")\n  resolve()\n})\n->ignore\n```"]
    }, 
    {
      "id": "RescriptCore.Promise.catch",
      "kind": "value",
      "name": "catch",
      "signature": "let catch: (t<'a>, exn => t<'a>) => t<'a>",
      "docstrings": ["`catch(promise, errorCallback)` registers an exception handler in a promise chain.\nThe `errorCallback` receives an `exn` value that can later be refined into a JS\nerror or ReScript error. The `errorCallback` needs to return a promise with the\nsame type as the consumed promise. See [`Promise.catch`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch) on MDN.\n\n## Examples\n\n```rescript\nopen Promise\n\nexception SomeError(string)\n\nreject(SomeError(\"this is an error\"))\n->then(_ => {\n  Ok(\"This result will never be returned\")->resolve\n})\n->catch(e => {\n  let msg = switch(e) {\n    | SomeError(msg) => \"ReScript error occurred: \" ++ msg\n    | Exn.Error(obj) =>\n      switch Exn.message(obj) {\n        | Some(msg) => \"JS exception occurred: \" ++ msg\n        | None => \"Some other JS value has been thrown\"\n      }\n    | _ => \"Unexpected error occurred\"\n  }\n\n  Error(msg)->resolve\n})\n->then(result => {\n  switch result {\n  | Ok(r) => Console.log2(\"Operation successful: \", r)\n  | Error(msg) => Console.log2(\"Operation failed: \", msg)\n  }->resolve\n})\n->ignore // Ignore needed for side-effects\n```\n\nIn case you want to return another promise in your `callback`, consider using\n`then` instead."]
    }, 
    {
      "id": "RescriptCore.Promise.then",
      "kind": "value",
      "name": "then",
      "signature": "let then: (t<'a>, 'a => t<'b>) => t<'b>",
      "docstrings": ["`then(promise, callback)` returns a new promise based on the result of `promise`'s \nvalue. The `callback` needs to explicitly return a new promise via `resolve`.\nIt is **not allowed** to resolve a nested promise (like `resolve(resolve(1))`).\nSee [`Promise.then`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then) on MDN.\n## Examples\n\n```rescript\nPromise.resolve(5)\n->then(num => {\n  resolve(num + 5)\n})\n->then(num => {\n  Console.log2(\"Your lucky number is: \", num)\n  resolve()\n})\n->ignore\n```"]
    }, 
    {
      "id": "RescriptCore.Promise.thenResolve",
      "kind": "value",
      "name": "thenResolve",
      "signature": "let thenResolve: (t<'a>, 'a => 'b) => t<'b>",
      "docstrings": ["`thenResolve(promise, callback)` converts an encapsulated value of a promise\ninto another promise wrapped value. It is **not allowed** to return a promise\nwithin the provided callback (e.g. `thenResolve(value => resolve(value))`).\n\n## Examples\n\n```rescript\nresolve(\"Anna\")\n->thenResolve(str => {\n  \"Hello \" ++ str\n})\n->thenResolve(str => {\n  Console.log(str)\n})\n->ignore // Ignore needed for side-effects\n```\n\nIn case you want to return another promise in your `callback`, consider using\n`then` instead."]
    }, 
    {
      "id": "RescriptCore.Promise.finally",
      "kind": "value",
      "name": "finally",
      "signature": "let finally: (t<'a>, unit => unit) => t<'a>",
      "docstrings": ["`finally(promise, callback)` is used to execute a function that is called no\nmatter if a promise was resolved or rejected. It will return the same `promise`\nit originally received. See [`Promise.finally`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally) on MDN.\n\n## Examples\n\n```rescript\nexception SomeError(string)\nlet isDone = ref(false)\n\nresolve(5)\n->then(_ => {\n  reject(TestError(\"test\"))\n})\n->then(v => {\n  Console.log2(\"final result\", v)\n  resolve()\n})\n->catch(_ => {\n  Console.log(\"Error handled\")\n  resolve()\n})\n->finally(() => {\n  Console.log(\"finally\")\n  isDone := true\n})\n->then(() => {\n  Console.log2(\"isDone:\", isDone.contents)\n  resolve()\n})\n->ignore\n```"]
    }, 
    {
      "id": "RescriptCore.Promise.race",
      "kind": "value",
      "name": "race",
      "signature": "let race: array<t<'a>> => t<'a>",
      "docstrings": ["`race(arr)` combining `array` of promises. See [`Promise.race`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race) on MDN.\n\n## Examples\n\n```rescript\nopen Promise\nlet racer = (ms, name) => {\n  Promise.make((resolve, _) => {\n    Global.setTimeout(() => {\n      resolve(. name)\n    }, ms)->ignore\n  })\n}\n\nlet promises = [racer(1000, \"Turtle\"), racer(500, \"Hare\"), racer(100, \"Eagle\")]\n\nrace(promises)->then(winner => {\n  Console.log(\"The winner is \" ++ winner)\n  resolve()\n})\n```"]
    }, 
    {
      "id": "RescriptCore.Promise.all",
      "kind": "value",
      "name": "all",
      "signature": "let all: array<t<'a>> => t<array<'a>>",
      "docstrings": ["`all(promises)` runs all promises in parallel and returns a new promise resolving\nall gathered results in a unified array. See [`Promise.all`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all) on MDN.\n\n```rescript\nopen Promise\nlet promises = [resolve(1), resolve(2), resolve(3)]\n\nall(promises)\n->then((results) => {\n  results->Array.forEach(num => {\n    Console.log2(\"Number: \", num)\n  })\n\n  resolve()\n})\n->ignore\n```"]
    }, 
    {
      "id": "RescriptCore.Promise.all2",
      "kind": "value",
      "name": "all2",
      "signature": "let all2: ((t<'a>, t<'b>)) => t<('a, 'b)>",
      "docstrings": ["`all2((p1, p2))`. Like `all()`, but with a fixed size tuple of 2"]
    }, 
    {
      "id": "RescriptCore.Promise.all3",
      "kind": "value",
      "name": "all3",
      "signature": "let all3: ((t<'a>, t<'b>, t<'c>)) => t<('a, 'b, 'c)>",
      "docstrings": ["`all3((p1, p2, p3))`. Like `all()`, but with a fixed size tuple of 3"]
    }, 
    {
      "id": "RescriptCore.Promise.all4",
      "kind": "value",
      "name": "all4",
      "signature": "let all4: ((t<'a>, t<'b>, t<'c>, t<'d>)) => t<('a, 'b, 'c, 'd)>",
      "docstrings": ["`all4((p1, p2, p3, p4))`. Like `all()`, but with a fixed size tuple of 4"]
    }, 
    {
      "id": "RescriptCore.Promise.all5",
      "kind": "value",
      "name": "all5",
      "signature": "let all5: ((t<'a>, t<'b>, t<'c>, t<'d>, t<'e>)) => t<('a, 'b, 'c, 'd, 'e)>",
      "docstrings": ["`all5((p1, p2, p3, p4, p5))`. Like `all()`, but with a fixed size tuple of 5"]
    }, 
    {
      "id": "RescriptCore.Promise.all6",
      "kind": "value",
      "name": "all6",
      "signature": "let all6: ((t<'a>, t<'b>, t<'c>, t<'d>, t<'e>, t<'f>)) => t<('a, 'b, 'c, 'd, 'e, 'f)>",
      "docstrings": ["`all6((p1, p2, p4, p5, p6))`. Like `all()`, but with a fixed size tuple of 6\n\")"]
    }, 
    {
      "id": "RescriptCore.Promise.done",
      "kind": "value",
      "name": "done",
      "signature": "let done: promise<'a> => unit",
      "docstrings": ["`done(p)` is a safe way to ignore a promise. If a value is anything else than a\npromise, it will raise a type error."]
    }]
  }, 
  {
    "id": "RescriptCore.RegExp",
    "kind": "moduleAlias",
    "name": "RegExp",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.RegExp.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = Js.Re.t",
      "docstrings": ["Type representing an instantiated `RegExp`."]
    }, 
    {
      "id": "RescriptCore.RegExp.Result",
      "name": "Result",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.RegExp.Result.t",
        "kind": "type",
        "name": "t",
        "signature": "type t = array<string>",
        "docstrings": ["Type representing the result of a `RegExp` execution."]
      }, 
      {
        "id": "RescriptCore.RegExp.Result.fullMatch",
        "kind": "value",
        "name": "fullMatch",
        "signature": "let fullMatch: t => string",
        "docstrings": ["`fullMatch(regExpResult)` returns the full string that matched in this result.\n\n  ## Examples\n  ```rescript\n  // Match the first two words separated by a space\n  let regexp = RegExp.fromString(\"(\\\\w+) (\\\\w+)\")\n\n  switch regexp->RegExp.exec(\"ReScript is pretty cool, right?\") {\n  | None => Console.log(\"Nope, no match...\")\n  | Some(result) => Console.log(result->RegExp.Result.fullMatch) // Prints the full string that matched, \"ReScript is\"\n  }\n  ```"]
      }, 
      {
        "id": "RescriptCore.RegExp.Result.matches",
        "kind": "value",
        "name": "matches",
        "signature": "let matches: t => array<string>",
        "docstrings": ["`matches(regExpResult)` returns all matches for `regExpResult`.\n\n  ## Examples\n  ```rescript\n  // Match the first two words separated by a space\n  let regexp = RegExp.fromString(\"(\\\\w+) (\\\\w+)\")\n\n  // This below will log \"ReScript\" and \"is\" to the console.\n  switch regexp->RegExp.exec(\"ReScript is pretty cool, right?\") {\n  | None => Console.log(\"Nope, no match...\")\n  | Some(result) => switch result->RegExp.Result.matches {\n    | [firstWord, secondWord] => Console.log2(firstWord, secondWord)\n    | _ => Console.log(\"Didn't find exactly two words...\")\n    }\n  }\n  ```"]
      }, 
      {
        "id": "RescriptCore.RegExp.Result.index",
        "kind": "value",
        "name": "index",
        "signature": "let index: t => int",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.RegExp.Result.input",
        "kind": "value",
        "name": "input",
        "signature": "let input: t => string",
        "docstrings": ["`input(regExpResult)` returns the full input string that was passed to what produced the `RegExp.Result.t`.\n\n  ## Examples\n  ```rescript\n  // Match the first two words separated by a space\n  let regexp = RegExp.fromString(\"(\\\\w+) (\\\\w+)\")\n\n  // This below will log the full input string \"ReScript is pretty cool, right?\" to the console.\n  switch regexp->RegExp.exec(\"ReScript is pretty cool, right?\") {\n  | None => Console.log(\"Nope, no match...\")\n  | Some(result) => Console.log(result->RegExp.Result.input)\n  }\n  ```"]
      }]
    }, 
    {
      "id": "RescriptCore.RegExp.fromString",
      "kind": "value",
      "name": "fromString",
      "signature": "let fromString: string => t",
      "docstrings": ["`fromString(string)` creates a `RegExp.t` from the provided string. This can then be used to match on strings using `RegExp.exec`.\n\nSee [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/RegExp) on MDN.\n\n## Examples\n```rescript\n// Match the first word in a sentence\nlet regexp = RegExp.fromString(\"\\\\w+\")\n\nswitch regexp->RegExp.exec(\"ReScript is pretty cool, right?\") {\n| None => Console.log(\"Nope, no match...\")\n| Some(result) => Console.log(result->RegExp.Result.fullMatch) // Prints \"ReScript\"\n}\n```"]
    }, 
    {
      "id": "RescriptCore.RegExp.fromStringWithFlags",
      "kind": "value",
      "name": "fromStringWithFlags",
      "signature": "let fromStringWithFlags: (string, ~flags: string) => t",
      "docstrings": ["`fromStringWithFlags(string)` creates a `RegExp.t` from the provided string, using the provided `flags`. This can then be used to match on strings using `RegExp.exec`.\n\nSee [`RegExp parameters`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/RegExp#parameters) on MDN.\n\n## Examples\n```rescript\n// Match the first word in a sentence\nlet regexp = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"g\")\n\nswitch regexp->RegExp.exec(\"ReScript is pretty cool, right?\") {\n| None => Console.log(\"Nope, no match...\")\n| Some(result) => Console.log(result->RegExp.Result.fullMatch) // Prints \"ReScript\"\n}\n```"]
    }, 
    {
      "id": "RescriptCore.RegExp.test",
      "kind": "value",
      "name": "test",
      "signature": "let test: (t, string) => bool",
      "docstrings": ["`test(regexp, string)` tests whether the provided `regexp` matches on the provided string.\n\nSee [`RegExp.test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test) on MDN.\n\n## Examples\n```rescript\n// Match the first word in a sentence\nlet regexp = RegExp.fromString(\"\\\\w+\")\n\nif regexp->RegExp.test(\"ReScript is cool!\") {\n  Console.log(\"Yay, there's a word in there.\")\n}\n```"]
    }, 
    {
      "id": "RescriptCore.RegExp.exec",
      "kind": "value",
      "name": "exec",
      "signature": "let exec: (t, string) => option<Result.t>",
      "docstrings": ["`exec(regexp, string)` executes the provided regexp on the provided string, optionally returning a `RegExp.Result.t` if the regexp matches on the string.\n\nSee [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec) on MDN.\n\n## Examples\n```rescript\n// Match the first word in a sentence\nlet regexp = RegExp.fromString(\"\\\\w+\")\n\nswitch regexp->RegExp.exec(\"ReScript is pretty cool, right?\") {\n| None => Console.log(\"Nope, no match...\")\n| Some(result) => Console.log(result->RegExp.Result.fullMatch) // Prints \"ReScript\"\n}\n```"]
    }, 
    {
      "id": "RescriptCore.RegExp.lastIndex",
      "kind": "value",
      "name": "lastIndex",
      "signature": "let lastIndex: t => int",
      "docstrings": ["`lastIndex(regexp)` returns the index the next match will start from.\n\nSee [`RegExp.lastIndex`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex) on MDN.\n\n## Examples\n```rescript\n// Match the first word in a sentence\nlet regexp = RegExp.fromString(\"\\\\w+\")\nlet someStr = \"Many words here.\"\n\nConsole.log(regexp->RegExp.lastIndex) // Logs `0` to the console\n\nregexp->RegExp.exec(someStr)->ignore\n\nConsole.log(regexp->RegExp.lastIndex) // Logs `4` to the console\n```"]
    }, 
    {
      "id": "RescriptCore.RegExp.ignoreCase",
      "kind": "value",
      "name": "ignoreCase",
      "signature": "let ignoreCase: t => bool",
      "docstrings": ["`ignoreCase(regexp)` returns whether the ignore case (`i`) flag is set on this `RegExp`.\n\nSee [`RegExp.ignoreCase`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/ignoreCase) on MDN.\n\n## Examples\n```rescript\nlet regexp1 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"g\")\nConsole.log(regexp1->RegExp.ignoreCase) // Logs `false`, since `i` is not set\n\nlet regexp2 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"i\")\nConsole.log(regexp2->RegExp.ignoreCase) // Logs `true`, since `i` is set\n```"]
    }, 
    {
      "id": "RescriptCore.RegExp.global",
      "kind": "value",
      "name": "global",
      "signature": "let global: t => bool",
      "docstrings": ["`global(regexp)` returns whether the global (`g`) flag is set on this `RegExp`.\n\nSee [`RegExp.global`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/global) on MDN.\n\n## Examples\n```rescript\nlet regexp1 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"g\")\nConsole.log(regexp1->RegExp.global) // Logs `true`, since `g` is set\n\nlet regexp2 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"i\")\nConsole.log(regexp2->RegExp.global) // Logs `false`, since `g` is not set\n```"]
    }, 
    {
      "id": "RescriptCore.RegExp.multiline",
      "kind": "value",
      "name": "multiline",
      "signature": "let multiline: t => bool",
      "docstrings": ["`multiline(regexp)` returns whether the multiline (`m`) flag is set on this `RegExp`.\n\nSee [`RegExp.multiline`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/multiline) on MDN.\n\n## Examples\n```rescript\nlet regexp1 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"g\")\nConsole.log(regexp1->RegExp.multiline) // Logs `false`, since `m` is not set\n\nlet regexp2 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"mi\")\nConsole.log(regexp2->RegExp.multiline) // Logs `true`, since `m` is set\n```"]
    }, 
    {
      "id": "RescriptCore.RegExp.source",
      "kind": "value",
      "name": "source",
      "signature": "let source: t => string",
      "docstrings": ["`source(regexp)` returns the source text for this `RegExp`, without the two forward slashes (if present), and without any set flags.\n\nSee [`RegExp.source`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/source) on MDN.\n\n## Examples\n```rescript\nlet regexp = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"g\")\nConsole.log(regexp->RegExp.source) // Logs `\\w+`, the source text of the `RegExp`\n```"]
    }, 
    {
      "id": "RescriptCore.RegExp.sticky",
      "kind": "value",
      "name": "sticky",
      "signature": "let sticky: t => bool",
      "docstrings": ["`sticky(regexp)` returns whether the sticky (`y`) flag is set on this `RegExp`.\n\nSee [`RegExp.sticky`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky) on MDN.\n\n## Examples\n```rescript\nlet regexp1 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"g\")\nConsole.log(regexp1->RegExp.unicode) // Logs `false`, since `y` is not set\n\nlet regexp2 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"my\")\nConsole.log(regexp2->RegExp.unicode) // Logs `true`, since `y` is set\n```"]
    }, 
    {
      "id": "RescriptCore.RegExp.unicode",
      "kind": "value",
      "name": "unicode",
      "signature": "let unicode: t => bool",
      "docstrings": ["`unicode(regexp)` returns whether the unicode (`y`) flag is set on this `RegExp`.\n\nSee [`RegExp.unicode`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/unicode) on MDN.\n\n## Examples\n```rescript\nlet regexp1 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"g\")\nConsole.log(regexp1->RegExp.unicode) // Logs `false`, since `u` is not set\n\nlet regexp2 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"mu\")\nConsole.log(regexp2->RegExp.unicode) // Logs `true`, since `u` is set\n```"]
    }]
  }, 
  {
    "id": "RescriptCore.String",
    "kind": "moduleAlias",
    "name": "String",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.String.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: 'a => string",
      "docstrings": ["`make(value)` converts the given value to a `string`.\n\n## Examples\n\n```rescript\nString.make(3.5) == \"3.5\"\nString.make([1, 2, 3]) == \"1,2,3\"\n```"]
    }, 
    {
      "id": "RescriptCore.String.fromCharCode",
      "kind": "value",
      "name": "fromCharCode",
      "signature": "let fromCharCode: int => string",
      "docstrings": ["`fromCharCode(n)` creates a `string` containing the character corresponding to\nthat number, `n` ranges from 0 to 65535. If out of range, the lower 16 bits of\nthe value are used. Thus, `fromCharCode(0x1F63A)` gives the same result as\n`fromCharCode(0xF63A)`.\nSee [`String.fromCharCode`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode) on MDN.\n\n## Examples\n\n```rescript\nString.fromCharCode(65) == \"A\"\nString.fromCharCode(0x3c8) == `ψ`\nString.fromCharCode(0xd55c) == `한`\nString.fromCharCode(-64568) == `ψ`\n```"]
    }, 
    {
      "id": "RescriptCore.String.fromCharCodeMany",
      "kind": "value",
      "name": "fromCharCodeMany",
      "signature": "let fromCharCodeMany: array<int> => string",
      "docstrings": ["`fromCharCodeMany([n1, n2, n3])` creates a `string` from the characters\ncorresponding to the given numbers, using the same rules as `fromCharCode`.\nSee [`String.fromCharCode`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode) on MDN.\n\n## Examples\n\n```rescript\nString.fromCharCodeMany([189, 43, 190, 61]) == \"½+¾=\"\nString.fromCharCode([65, 66, 67]) == \"ABC\"\n```"]
    }, 
    {
      "id": "RescriptCore.String.fromCodePoint",
      "kind": "value",
      "name": "fromCodePoint",
      "signature": "let fromCodePoint: int => string",
      "docstrings": ["`fromCodePoint(n)` creates a `string` containing the character corresponding to\nthat numeric code point.\nSee [`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint) on MDN.\n\n## Examples\n\n```rescript\nString.fromCodePoint(65) == \"A\"\nString.fromCodePoint(0x3c8) == `ψ`\nString.fromCodePoint(0xd55c) == `한`\nString.fromCodePoint(0x1f63a) == `😺`\n```\n\n## Exceptions\n\n- `RangeError`: If the number is not a valid code point, like `fromCharCode(-5)`."]
    }, 
    {
      "id": "RescriptCore.String.fromCodePointMany",
      "kind": "value",
      "name": "fromCodePointMany",
      "signature": "let fromCodePointMany: array<int> => string",
      "docstrings": ["`fromCodePointMany([n1, n2, n3])` creates a `string` from the characters\ncorresponding to the given code point numbers, using the same rules as\n`fromCodePoint`.\nSee [`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint) on MDN.\n\n## Examples\n\n```rescript\nString.fromCodePointMany([0xd55c, 0xae00, 0x1f63a]) == `한글😺`\n```\n\n## Exceptions\n\n- `RangeError`: If one of the number is not a valid code point, like\n`fromCharCode([1, -5])`."]
    }, 
    {
      "id": "RescriptCore.String.equal",
      "kind": "value",
      "name": "equal",
      "signature": "let equal: (string, string) => bool",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.String.compare",
      "kind": "value",
      "name": "compare",
      "signature": "let compare: (string, string) => Core__Ordering.t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.String.length",
      "kind": "value",
      "name": "length",
      "signature": "let length: string => int",
      "docstrings": ["`length(str)` returns the length of the given `string`.\nSee [`String.length`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length) on MDN.\n\n## Examples\n\n```rescript\nString.length(\"abcd\") == 4\n```"]
    }, 
    {
      "id": "RescriptCore.String.get",
      "kind": "value",
      "name": "get",
      "signature": "let get: (string, int) => option<string>",
      "docstrings": ["`get(str, index)` returns an `option<string>` at the given `index` number. If\n`index` is out of range, this function returns `None`.\n\n## Examples\n\n```rescript\nString.get(\"ReScript\", 0) == Some(\"R\")\nString.get(\"Hello\", 4) == Some(\"o\")\nString.get(`JS`, 4) == None\n```"]
    }, 
    {
      "id": "RescriptCore.String.charAt",
      "kind": "value",
      "name": "charAt",
      "signature": "let charAt: (string, int) => string",
      "docstrings": ["`charAt(str, index)` gets the character at `index` within string `str`. If\n`index` is negative or greater than the length of `str`, it returns the empty\nstring. If the string contains characters outside the range \\u0000-\\uffff, it\nwill return the first 16-bit value at that position in the string.\nSee [`String.charAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charAt) on MDN.\n\n## Examples\n\n```rescript\nString.charAt(\"ReScript\", 0) == \"R\"\nString.charAt(\"Hello\", 12) == \"\"\nString.charAt(`JS`, 5) == \"\"\n```"]
    }, 
    {
      "id": "RescriptCore.String.charCodeAt",
      "kind": "value",
      "name": "charCodeAt",
      "signature": "let charCodeAt: (string, int) => float",
      "docstrings": ["`charCodeAt(str, index)` returns the character code at position `index` in\nstring `str` the result is in the range 0-65535, unlike `codePointAt`, so it\nwill not work correctly for characters with code points greater than or equal\nto 0x10000. The return type is `float` because this function returns NaN if\n`index` is less than zero or greater than the length of the string.\nSee [`String.charCodeAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt) on MDN.\n\n## Examples\n\n```rescript\nString.charCodeAt(`😺`, 0) == 0xd83d->Int.toFloat\nString.codePointAt(`😺`, 0) == Some(0x1f63a)\n```"]
    }, 
    {
      "id": "RescriptCore.String.codePointAt",
      "kind": "value",
      "name": "codePointAt",
      "signature": "let codePointAt: (string, int) => option<int>",
      "docstrings": ["`codePointAt(str, index)` returns the code point at position `index` within\nstring `str` as a `Some(value)`. The return value handles code points greater\nthan or equal to 0x10000. If there is no code point at the given position, the\nfunction returns `None`.\nSee [`String.codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt) on MDN.\n\n## Examples\n\n```rescript\nString.codePointAt(`¿😺?`, 1) == Some(0x1f63a)\nString.codePointAt(\"abc\", 5) == None\n```"]
    }, 
    {
      "id": "RescriptCore.String.concat",
      "kind": "value",
      "name": "concat",
      "signature": "let concat: (string, string) => string",
      "docstrings": ["`concat(original, append)` returns a new `string` with `append` added after\n`original`.\nSee [`String.concat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/concat) on MDN.\n\n## Examples\n\n```rescript\nString.concat(\"cow\", \"bell\") == \"cowbell\"\nString.concat(\"Re\", \"Script\") == \"ReScript\"\n```"]
    }, 
    {
      "id": "RescriptCore.String.concatMany",
      "kind": "value",
      "name": "concatMany",
      "signature": "let concatMany: (string, array<string>) => string",
      "docstrings": ["`concatMany(original, arr)` returns a new `string` consisting of each item of an\narray of strings added to the `original` string.\nSee [`String.concat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/concat) on MDN.\n\n## Examples\n\n```rescript\nString.concatMany(\"1st\", [\"2nd\", \"3rd\", \"4th\"]) == \"1st2nd3rd4th\"\n```"]
    }, 
    {
      "id": "RescriptCore.String.endsWith",
      "kind": "value",
      "name": "endsWith",
      "signature": "let endsWith: (string, string) => bool",
      "docstrings": ["`endsWith(str, substr)` returns `true` if the `str` ends with `substr`, `false`\notherwise.\nSee [`String.endsWith`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith) on MDN.\n\n## Examples\n\n```rescript\nString.endsWith(\"BuckleScript\", \"Script\") == true\nString.endsWith(\"BuckleShoes\", \"Script\") == false\n```"]
    }, 
    {
      "id": "RescriptCore.String.endsWithFrom",
      "kind": "value",
      "name": "endsWithFrom",
      "signature": "let endsWithFrom: (string, string, int) => bool",
      "docstrings": ["`endsWithFrom(str, ending, len)` returns `true` if the first len characters of\n`str` end with `ending`, `false` otherwise. If `len` is greater than or equal\nto the length of `str`, then it works like `endsWith`.\nSee [`String.endsWith`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith) on MDN.\n\n## Examples\n\n```rescript\nString.endsWithFrom(\"abcd\", \"cd\", 4) == true\nString.endsWithFrom(\"abcde\", \"cd\", 3) == false\nString.endsWithFrom(\"abcde\", \"cde\", 99) == true\nString.endsWithFrom(\"example.dat\", \"ple\", 7) == true\n```"]
    }, 
    {
      "id": "RescriptCore.String.includes",
      "kind": "value",
      "name": "includes",
      "signature": "let includes: (string, string) => bool",
      "docstrings": ["`includes(str, searchValue)` returns `true` if `searchValue` is found anywhere\nwithin `str`, `false` otherwise.\nSee [`String.includes`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes) on MDN.\n\n## Examples\n\n```rescript\nString.includes(\"programmer\", \"gram\") == true\nString.includes(\"programmer\", \"er\") == true\nString.includes(\"programmer\", \"pro\") == true\nString.includes(\"programmer.dat\", \"xyz\") == false\n```"]
    }, 
    {
      "id": "RescriptCore.String.includesFrom",
      "kind": "value",
      "name": "includesFrom",
      "signature": "let includesFrom: (string, string, int) => bool",
      "docstrings": ["`includesFrom(str, searchValue, start)` returns `true` if `searchValue` is found\nanywhere within `str` starting at character number `start` (where 0 is the\nfirst character), `false` otherwise.\nSee [`String.includes`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes) on MDN.\n\n## Examples\n\n```rescript\nString.includesFrom(\"programmer\", \"gram\", 1) == true\nString.includesFrom(\"programmer\", \"gram\", 4) == false\nString.includesFrom(`대한민국`, `한`, 1) == true\n```"]
    }, 
    {
      "id": "RescriptCore.String.indexOf",
      "kind": "value",
      "name": "indexOf",
      "signature": "let indexOf: (string, string) => int",
      "docstrings": ["`indexOf(str, searchValue)` returns the position at which `searchValue` was\nfirst found within `str`, or `-1` if `searchValue` is not in `str`.\nSee [`String.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf) on MDN.\n\n## Examples\n\n```rescript\nString.indexOf(\"bookseller\", \"ok\") == 2\nString.indexOf(\"bookseller\", \"sell\") == 4\nString.indexOf(\"beekeeper\", \"ee\") == 1\nString.indexOf(\"bookseller\", \"xyz\") == -1\n```"]
    }, 
    {
      "id": "RescriptCore.String.indexOfOpt",
      "kind": "value",
      "name": "indexOfOpt",
      "signature": "let indexOfOpt: (string, string) => option<int>",
      "docstrings": ["`indexOfOpt(str, searchValue)`. Like `indexOf`, but return an `option<int>`.\n\n## Examples\n\n```rescript\nString.indexOf(\"bookseller\", \"ok\") == Some(2)\nString.indexOf(\"bookseller\", \"xyz\") == None\n```"]
    }, 
    {
      "id": "RescriptCore.String.indexOfFrom",
      "kind": "value",
      "name": "indexOfFrom",
      "signature": "let indexOfFrom: (string, string, int) => int",
      "docstrings": ["`indexOfFrom(str, searchValue, start)` returns the position at which\n`searchValue` was found within `str` starting at character position `start`, or\n`-1` if `searchValue` is not found in that portion of `str`. The return value is\nrelative to the beginning of the string, no matter where the search started\nfrom.\nSee [`String.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf) on MDN.\n\n## Examples\n\n```rescript\nString.indexOfFrom(\"bookseller\", \"ok\", 1) == 2\nString.indexOfFrom(\"bookseller\", \"sell\", 2) == 4\nString.indexOfFrom(\"bookseller\", \"sell\", 5) == -1\n```"]
    }, 
    {
      "id": "RescriptCore.String.lastIndexOf",
      "kind": "value",
      "name": "lastIndexOf",
      "signature": "let lastIndexOf: (string, string) => int",
      "docstrings": ["`lastIndexOf(str, searchValue)` returns the position of the last occurrence of\n`searchValue` within `str`, searching backwards from the end of the string.\nReturns `-1` if `searchValue` is not in `str`. The return value is always\nrelative to the beginning of the string.\nSee [`String.lastIndexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf) on MDN.\n\n## Examples\n\n```rescript\nString.lastIndexOf(\"bookseller\", \"ok\") == 2\nString.lastIndexOf(\"beekeeper\", \"ee\") == 4\nString.lastIndexOf(\"abcdefg\", \"xyz\") == -1\n```"]
    }, 
    {
      "id": "RescriptCore.String.lastIndexOfOpt",
      "kind": "value",
      "name": "lastIndexOfOpt",
      "signature": "let lastIndexOfOpt: (string, string) => option<int>",
      "docstrings": ["`lastIndexOfOpt(str, searchValue)`. Like `lastIndexOfOpt`, but return an\n`option<int>`.\n\n## Examples\n\n```rescript\nString.lastIndexOf(\"bookseller\", \"ok\") == Some(2)\nString.lastIndexOf(\"beekeeper\", \"ee\") == Some(4)\nString.lastIndexOf(\"abcdefg\", \"xyz\") == None\n```"]
    }, 
    {
      "id": "RescriptCore.String.lastIndexOfFrom",
      "kind": "value",
      "name": "lastIndexOfFrom",
      "signature": "let lastIndexOfFrom: (string, string, int) => int",
      "docstrings": ["`lastIndexOfFrom(str, searchValue, start)` returns the position of the last\noccurrence of `searchValue` within `str`, searching backwards from the given\nstart position. Returns `-1` if `searchValue` is not in `str`. The return value\nis always relative to the beginning of the string.\nSee [`String.lastIndexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf) on MDN.\n\n## Examples\n\n```rescript\nString.lastIndexOfFrom(\"bookseller\", \"ok\", 6) == 2\nString.lastIndexOfFrom(\"beekeeper\", \"ee\", 8) == 4\nString.lastIndexOfFrom(\"beekeeper\", \"ee\", 3) == 1\nString.lastIndexOfFrom(\"abcdefg\", \"xyz\", 4) == -1\n```"]
    }, 
    {
      "id": "RescriptCore.String.match",
      "kind": "value",
      "name": "match",
      "signature": "let match: (string, Core__RegExp.t) => option<Core__RegExp.Result.t>",
      "docstrings": ["`match(str, regexp)` matches a `string` against the given `regexp`. If there is\nno match, it returns `None`. For regular expressions without the g modifier, if\nthere is a match, the return value is `Some(array)` where the array contains:\n- The entire matched string\n- Any capture groups if the regexp had parentheses\nFor regular expressions with the g modifier, a matched expression returns\n`Some(array)` with all the matched substrings and no capture groups.\nSee [`String.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match) on MDN.\n\n## Examples\n\n```rescript\nString.match(\"The better bats\", %re(\"/b[aeiou]t/\")) == Some([\"bet\"])\nString.match(\"The better bats\", %re(\"/b[aeiou]t/g\")) == Some([\"bet\", \"bat\"])\nString.match(\"Today is 2018-04-05.\", %re(\"/(\\d+)-(\\d+)-(\\d+)/\")) ==\n  Some([\"2018-04-05\", \"2018\", \"04\", \"05\"])\nString.match(\"The large container.\", %re(\"/b[aeiou]g/\")) == None\n```"]
    }, 
    {
      "id": "RescriptCore.String.normalize",
      "kind": "value",
      "name": "normalize",
      "signature": "let normalize: string => string",
      "docstrings": ["`normalize(str)` returns the normalized Unicode string using Normalization Form\nCanonical (NFC) Composition. Consider the character ã, which can be represented\nas the single codepoint \\u00e3 or the combination of a lower case letter A\n\\u0061 and a combining tilde \\u0303. Normalization ensures that both can be\nstored in an equivalent binary representation.\nSee [`String.normalize`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize) on MDN.\nSee also [Unicode technical report #15](https://unicode.org/reports/tr15/) for details.\n\n## Examples\n\n```rescript\nlet string1 = \"\\uFB00\"\nlet string2 = \"\\u0066\\u0066\"\nConsole.log(string1 === string2) // false\n\nlet normalizeString1 = String.normalize(string1, \"NFKD\")\nlet normalizeString2 = String.normalize(string2, \"NFKD\")\nassert(normalizeString1 === normalizeString2)\n```"]
    }, 
    {
      "id": "RescriptCore.String.normalizeForm",
      "kind": "type",
      "name": "normalizeForm",
      "signature": "type normalizeForm = [#NFC | #NFD | #NFKC | #NFKD]",
      "docstrings": ["`normalizeByForm(str, form)` returns the normalized Unicode string using the\nspecified form of normalization, which may be one of:\n- \"NFC\" — Normalization Form Canonical Composition.\n- \"NFD\" — Normalization Form Canonical Decomposition.\n- \"NFKC\" — Normalization Form Compatibility Composition.\n- \"NFKD\" — Normalization Form Compatibility Decomposition.\nSee [`String.normalize`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize) on MDN.\nSee also [Unicode technical report #15](https://unicode.org/reports/tr15/) for\ndetails.\n\n## Examples\n\n```rescript\nlet string1 = \"\\uFB00\"\nlet string2 = \"\\u0066\\u0066\"\nConsole.log(string1 == string2) // false\n\nlet normalizeString1 = String.normalizeByForm(string1, #NFKD)\nlet normalizeString2 = String.normalizeByForm(string2, #NFKD)\nConsole.log(normalizeString1 == normalizeString2) // true\n```"]
    }, 
    {
      "id": "RescriptCore.String.normalizeByForm",
      "kind": "value",
      "name": "normalizeByForm",
      "signature": "let normalizeByForm: (string, normalizeForm) => string",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.String.repeat",
      "kind": "value",
      "name": "repeat",
      "signature": "let repeat: (string, int) => string",
      "docstrings": ["`repeat(str, n)` returns a `string` that consists of `n` repetitions of `str`.\nSee [`String.repeat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat) on MDN.\n\n## Examples\n\n```rescript\nString.repeat(\"ha\", 3) == \"hahaha\"\nString.repeat(\"empty\", 0) == \"\"\n```\n\n## Exceptions\n\n- `RangeError`: if `n` is negative."]
    }, 
    {
      "id": "RescriptCore.String.replace",
      "kind": "value",
      "name": "replace",
      "signature": "let replace: (string, string, string) => string",
      "docstrings": ["`replace(str, substr, newSubstr)` returns a new `string` which is\nidentical to `str` except with the first matching instance of `substr` replaced\nby `newSubstr`. `substr` is treated as a verbatim string to match, not a\nregular expression.\nSee [`String.replace`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) on MDN.\n\n## Examples\n\n```rescript\nString.replace(\"old string\", \"old\", \"new\") == \"new string\"\nString.replace(\"the cat and the dog\", \"the\", \"this\") == \"this cat and the dog\"\n```"]
    }, 
    {
      "id": "RescriptCore.String.replaceRegExp",
      "kind": "value",
      "name": "replaceRegExp",
      "signature": "let replaceRegExp: (string, Core__RegExp.t, string) => string",
      "docstrings": ["`replaceRegExp(str, regex, replacement)` returns a new `string` where\noccurrences matching regex have been replaced by `replacement`.\nSee [`String.replace`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) on MDN.\n\n## Examples\n\n```rescript\nString.replaceRegExp(\"vowels be gone\", %re(\"/[aeiou]/g\"), \"x\") == \"vxwxls bx gxnx\"\nString.replaceRegExp(\"Juan Fulano\", %re(\"/(\\w+) (\\w+)/\"), \"$2, $1\") == \"Fulano, Juan\"\n```"]
    }, 
    {
      "id": "RescriptCore.String.unsafeReplaceRegExpBy0",
      "kind": "value",
      "name": "unsafeReplaceRegExpBy0",
      "signature": "let unsafeReplaceRegExpBy0: (\\n  string,\\n  Core__RegExp.t,\\n  (~match: string, ~offset: int, ~input: string) => string,\\n) => string",
      "docstrings": ["`unsafeReplaceRegExpBy0(str, regex, f)` returns a new `string` with some or all\nmatches of a pattern with no capturing parentheses replaced by the value\nreturned from the given function. The function receives as its parameters the\nmatched string, the offset at which the match begins, and the whole string being\nmatched.\nSee [`String.replace`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) on MDN.\n\n## Examples\n\n```rescript\nlet str = \"beautiful vowels\"\nlet re = %re(\"/[aeiou]/g\")\nlet matchFn = (matchPart, _offset, _wholeString) => String.toUpperCase(matchPart)\nString.unsafeReplaceRegExpBy0(str, re, matchFn) == \"bEAUtIfUl vOwEls\"\n```"]
    }, 
    {
      "id": "RescriptCore.String.unsafeReplaceRegExpBy1",
      "kind": "value",
      "name": "unsafeReplaceRegExpBy1",
      "signature": "let unsafeReplaceRegExpBy1: (\\n  string,\\n  Core__RegExp.t,\\n  (~match: string, ~group1: string, ~offset: int, ~input: string) => string,\\n) => string",
      "docstrings": ["`unsafeReplaceRegExpBy1(str, regexp, f)`. Like `unsafeReplaceRegExpBy0`, but `f`\nhas `group1` parameter.\nSee [`String.replace`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) on MDN.\n\n## Examples\n\n```rescript\nlet str = \"Jony is 40\"\nlet re = %re(\"/(Jony is )\\d+/g\")\nlet matchFn = (_match, part1, _offset, _wholeString) => {\n  part1 ++ \"41\"\n}\nString.unsafeReplaceRegExpBy1(str, re, matchFn) == \"Jony is 41\"\n```"]
    }, 
    {
      "id": "RescriptCore.String.unsafeReplaceRegExpBy2",
      "kind": "value",
      "name": "unsafeReplaceRegExpBy2",
      "signature": "let unsafeReplaceRegExpBy2: (\\n  string,\\n  Core__RegExp.t,\\n  (~match: string, ~group1: string, ~group2: string, ~offset: int, ~input: string) => string,\\n) => string",
      "docstrings": ["`unsafeReplaceRegExpBy2(str, regexp, f)`. Like `unsafeReplaceRegExpBy1`, but `f`\nhas two group parameters.\nSee [`String.replace`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) on MDN.\n\n## Examples\n\n```rescript\nlet str = \"7 times 6\"\nlet re = %re(\"/(\\d+) times (\\d+)/\")\nlet matchFn = (_match, p1, p2, _offset, _wholeString) => {\n  switch (Int.fromString(p1), Int.fromString(p2)) {\n  | (Some(x), Some(y)) => Int.toString(x * y)\n  | _ => \"???\"\n  }\n}\nString.unsafeReplaceRegExpBy2(str, re, matchFn) == \"42\"\n```"]
    }, 
    {
      "id": "RescriptCore.String.unsafeReplaceRegExpBy3",
      "kind": "value",
      "name": "unsafeReplaceRegExpBy3",
      "signature": "let unsafeReplaceRegExpBy3: (\\n  string,\\n  Core__RegExp.t,\\n  (\\n    ~match: string,\\n    ~group1: string,\\n    ~group2: string,\\n    ~group3: string,\\n    ~offset: int,\\n    ~input: string,\\n  ) => string,\\n) => string",
      "docstrings": ["`unsafeReplaceRegExpBy3(str, regexp, f)`. Like `unsafeReplaceRegExpBy1`, but `f`\nhas three group parameters.\nSee [`String.replace`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) on MDN."]
    }, 
    {
      "id": "RescriptCore.String.search",
      "kind": "value",
      "name": "search",
      "signature": "let search: (string, Core__RegExp.t) => int",
      "docstrings": ["`search(str, regexp)` returns the starting position of the first match of\n`regexp` in the given `str`, or -1 if there is no match.\nSee [`String.search`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/search) on MDN.\n\n## Examples\n\n```rescript\nString.search(\"testing 1 2 3\", %re(\"/\\d+/\")) == 8\nString.search(\"no numbers\", %re(\"/\\d+/\")) == -1\n```"]
    }, 
    {
      "id": "RescriptCore.String.searchOpt",
      "kind": "value",
      "name": "searchOpt",
      "signature": "let searchOpt: (string, Core__RegExp.t) => option<int>",
      "docstrings": ["`searchOpt(str, regexp)`. Like `search`, but return an `option<int>`.\n\n## Examples\n\n```rescript\nString.search(\"testing 1 2 3\", %re(\"/\\d+/\")) == Some(8)\nString.search(\"no numbers\", %re(\"/\\d+/\")) == None\n```"]
    }, 
    {
      "id": "RescriptCore.String.slice",
      "kind": "value",
      "name": "slice",
      "signature": "let slice: (string, ~start: int, ~end: int) => string",
      "docstrings": ["`slice(str, ~start, ~end)` returns the substring of `str` starting at\ncharacter `start` up to but not including `end`.\n- If either `start` or `end` is negative, then it is evaluated as\n`length(str - start)` or `length(str - end)`.\n- If `end` is greater than the length of `str`, then it is treated as\n`length(str)`.\n- If `start` is greater than `end`, slice returns the empty string.\nSee [`String.slice`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice) on MDN.\n\n## Examples\n\n```rescript\nString.slice(\"abcdefg\", ~start=2, ~end=5) == \"cde\"\nString.slice(\"abcdefg\", ~start=2, ~end=9) == \"cdefg\"\nString.slice(\"abcdefg\", ~start=-4, ~end=-2) == \"de\"\nString.slice(\"abcdefg\", ~start=5, ~end=1) == \"\"\n```"]
    }, 
    {
      "id": "RescriptCore.String.sliceToEnd",
      "kind": "value",
      "name": "sliceToEnd",
      "signature": "let sliceToEnd: (string, ~start: int) => string",
      "docstrings": ["`sliceToEnd(str, ~start)` returns the substring of `str` starting at character\n`start` to the end of the string.\n- If `start` is negative, then it is evaluated as `length(str - start)`.\n- If `start` is greater than the length of `str`, then sliceToEnd returns the empty string.\nSee [`String.slice`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice) on MDN.\n\n## Examples\n\n```rescript\nString.sliceToEnd(\"abcdefg\", ~start=4) == \"efg\"\nString.sliceToEnd(\"abcdefg\", ~start=-2) == \"fg\"\nString.sliceToEnd(\"abcdefg\", ~start=7) == \"\"\n```"]
    }, 
    {
      "id": "RescriptCore.String.split",
      "kind": "value",
      "name": "split",
      "signature": "let split: (string, string) => array<string>",
      "docstrings": ["`split(str, delimiter)` splits the given `str` at every occurrence of\n`delimiter` and returns an array of the resulting substrings.\nSee [`String.split`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split) on MDN.\n\n## Examples\n\n```rescript\nString.split(\"2018-01-02\", \"-\") == [\"2018\", \"01\", \"02\"]\nString.split(\"a,b,,c\", \",\") == [\"a\", \"b\", \"\", \"c\"]\nString.split(\"good::bad as great::awful\", \"::\") == [\"good\", \"bad as great\", \"awful\"]\nString.split(\"has-no-delimiter\", \";\") == [\"has-no-delimiter\"]\n```"]
    }, 
    {
      "id": "RescriptCore.String.splitAtMost",
      "kind": "value",
      "name": "splitAtMost",
      "signature": "let splitAtMost: (string, string, ~limit: int) => array<string>",
      "docstrings": ["`splitAtMost(str, delimiter, ~limit)` splits the given `str` at every\noccurrence of `delimiter` and returns an array of the first `limit` resulting\nsubstrings. If `limit` is negative or greater than the number of substrings,\nthe array will contain all the substrings.\n\n## Examples\n\n```rescript\nString.splitAtMost(\"ant/bee/cat/dog/elk\", \"/\", ~limit=3) = [\"ant\", \"bee\", \"cat\"]\nString.splitAtMost(\"ant/bee/cat/dog/elk\", \"/\", ~limit=0) = []\nString.splitAtMost(\"ant/bee/cat/dog/elk\", \"/\", ~limit=9) = [\"ant\", \"bee\", \"cat\", \"dog\", \"elk\"]\n```"]
    }, 
    {
      "id": "RescriptCore.String.splitByRegExp",
      "kind": "value",
      "name": "splitByRegExp",
      "signature": "let splitByRegExp: (string, Core__RegExp.t) => array<option<string>>",
      "docstrings": ["`splitByRegExp(str, regexp)` splits the given `str` at every occurrence of\n`regexp` and returns an array of the resulting substrings.\nSee [`String.split`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split) on MDN.\n\n## Examples\n\n```rescript\nString.splitByRegExp(\"Jan,Feb,Mar\", %re(\"/,/\")) == [Some(\"Jan\"), Some(\"Feb\"), Some(\"Mar\")]\n```"]
    }, 
    {
      "id": "RescriptCore.String.splitByRegExpAtMost",
      "kind": "value",
      "name": "splitByRegExpAtMost",
      "signature": "let splitByRegExpAtMost: (string, Core__RegExp.t, ~limit: int) => array<option<string>>",
      "docstrings": ["`splitByRegExpAtMost(str, regexp, ~limit)` splits the given `str` at every\noccurrence of `regexp` and returns an array of the first `limit` resulting\nsubstrings. If `limit` is negative or greater than the number of substrings, the\narray will contain all the substrings.\nSee [`String.split`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split) on MDN.\n\n## Examples\n\n```rescript\nString.splitByRegExpAtMost(\"Hello World. How are you doing?\", %re(\"/ /\"), ~limit=3) == [\n  Some(\"Hello\"),\n  Some(\"World.\"),\n  Some(\"How\"),\n]\n```"]
    }, 
    {
      "id": "RescriptCore.String.startsWith",
      "kind": "value",
      "name": "startsWith",
      "signature": "let startsWith: (string, string) => bool",
      "docstrings": ["`startsWith(str, substr)` returns `true` if the `str` starts with `substr`,\n`false` otherwise.\nSee [`String.startsWith`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith) on MDN.\n\n## Examples\n\n```rescript\nString.startsWith(\"BuckleScript\", \"Buckle\") == true\nString.startsWith(\"BuckleScript\", \"\") == true\nString.startsWith(\"JavaScript\", \"Buckle\") == false\n```"]
    }, 
    {
      "id": "RescriptCore.String.startsWithFrom",
      "kind": "value",
      "name": "startsWithFrom",
      "signature": "let startsWithFrom: (string, string, int) => bool",
      "docstrings": ["`startsWithFrom(str, substr, n)` returns `true` if the `str` starts\nwith `substr` starting at position `n`, `false` otherwise. If `n` is negative,\nthe search starts at the beginning of `str`.\nSee [`String.startsWith`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith) on MDN.\n\n## Examples\n\n```rescript\nString.startsWithFrom(\"BuckleScript\", \"kle\", 3) == true\nString.startsWithFrom(\"BuckleScript\", \"\", 3) == true\nString.startsWithFrom(\"JavaScript\", \"Buckle\", 2) == false\n```"]
    }, 
    {
      "id": "RescriptCore.String.substring",
      "kind": "value",
      "name": "substring",
      "signature": "let substring: (string, ~start: int, ~end: int) => string",
      "docstrings": ["`substring(str, ~start, ~end)` returns characters `start` up to but not\nincluding end from `str`.\n- If `start` is less than zero, it is treated as zero.\n- If `end` is zero or negative, the empty string is returned.\n- If `start` is greater than `end`, the `start` and `end` points are swapped.\nSee [`String.substring`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring) on MDN.\n\n## Examples\n\n```rescript\nString.substring(\"playground\", ~start=3, ~end=6) == \"ygr\"\nString.substring(\"playground\", ~start=6, ~end=3) == \"ygr\"\nString.substring(\"playground\", ~start=4, ~end=12) == \"ground\"\n```"]
    }, 
    {
      "id": "RescriptCore.String.substringToEnd",
      "kind": "value",
      "name": "substringToEnd",
      "signature": "let substringToEnd: (string, ~start: int) => string",
      "docstrings": ["`substringToEnd(str, ~start)` returns the substring of `str` from position\n`start` to the end.\n- If `start` is less than or equal to zero, the entire string is returned.\n- If `start` is greater than or equal to the length of `str`, the empty string\nis returned.\nSee [`String.substring`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring) on MDN.\n\n## Examples\n\n```rescript\nString.substringToEnd(\"playground\", ~start=4) == \"ground\"\nString.substringToEnd(\"playground\", ~start=-3) == \"playground\"\nString.substringToEnd(\"playground\", ~start=12) == \"\"\n```"]
    }, 
    {
      "id": "RescriptCore.String.toLowerCase",
      "kind": "value",
      "name": "toLowerCase",
      "signature": "let toLowerCase: string => string",
      "docstrings": ["`toLowerCase(str)` converts `str` to lower case using the locale-insensitive\ncase mappings in the Unicode Character Database. Notice that the conversion can\ngive different results depending upon context, for example with the Greek\nletter sigma, which has two different lower case forms, one when it is the last\ncharacter in a string and another when it is not.\nSee [`String.toLowerCase`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase) on MDN.\n\n## Examples\n\n```rescript\nString.toLowerCase(\"ABC\") == \"abc\"\nString.toLowerCase(`ΣΠ`) == `σπ`\nString.toLowerCase(`ΠΣ`) == `πς`\n```"]
    }, 
    {
      "id": "RescriptCore.String.toLocaleLowerCase",
      "kind": "value",
      "name": "toLocaleLowerCase",
      "signature": "let toLocaleLowerCase: string => string",
      "docstrings": ["`toLocaleLowerCase(str)` converts `str` to lower case using the current locale.\nSee [`String.toLocaleLowerCase`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase) on MDN."]
    }, 
    {
      "id": "RescriptCore.String.toUpperCase",
      "kind": "value",
      "name": "toUpperCase",
      "signature": "let toUpperCase: string => string",
      "docstrings": ["`toUpperCase(str)` converts `str` to upper case using the locale-insensitive\ncase mappings in the Unicode Character Database. Notice that the conversion can\nexpand the number of letters in the result, for example the German ß\ncapitalizes to two Ses in a row.\nSee [`String.toUpperCase`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase) on MDN.\n\n## Examples\n\n```rescript\nString.toUpperCase(\"abc\") == \"ABC\"\nString.toUpperCase(`Straße`) == `STRASSE`\nString.toUpperCase(`πς`) == `ΠΣ`\n```"]
    }, 
    {
      "id": "RescriptCore.String.toLocaleUpperCase",
      "kind": "value",
      "name": "toLocaleUpperCase",
      "signature": "let toLocaleUpperCase: string => string",
      "docstrings": ["`toLocaleUpperCase(str)` converts `str` to upper case using the current locale.\nSee [`String.toLocaleUpperCase`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleUpperCase) on MDN."]
    }, 
    {
      "id": "RescriptCore.String.trim",
      "kind": "value",
      "name": "trim",
      "signature": "let trim: string => string",
      "docstrings": ["`trim(str)` returns a string that is `str` with whitespace stripped from both\nends. Internal whitespace is not removed.\nSee [`String.trim`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim) on MDN.\n\n## Examples\n\n```rescript\nString.trim(\"   abc def   \") == \"abc def\"\nString.trim(\"\\n\\r\\t abc def \\n\\n\\t\\r \") == \"abc def\"\n```"]
    }, 
    {
      "id": "RescriptCore.String.trimStart",
      "kind": "value",
      "name": "trimStart",
      "signature": "let trimStart: string => string",
      "docstrings": ["`trimStart(str)` returns a string that is `str` with whitespace stripped from\nthe beginning of a string. Internal whitespace is not removed.\nSee [`String.trimStart`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trimStart) on MDN.\n\n## Examples\n\n```rescript\nString.trimStart(\"   Hello world!   \") == \"Hello world!   \"\nString.trimStart(\"   Hello   world!   \") == \"Hello   world!   \"\n```"]
    }, 
    {
      "id": "RescriptCore.String.trimEnd",
      "kind": "value",
      "name": "trimEnd",
      "signature": "let trimEnd: string => string",
      "docstrings": ["`trinEnd(str)` returns a string that is `str` with whitespace stripped from the\nend of a string. Internal whitespace is not removed.\nSee [`String.trimEnd`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trimEnd) on MDN.\n\n## Examples\n\n```rescript\nString.trimEnd(\"   Hello world!   \") == \"   Hello world!\"\nString.trimEnd(\"   Hello   world!   \") == \"   Hello   world!\"\n```"]
    }, 
    {
      "id": "RescriptCore.String.padStart",
      "kind": "value",
      "name": "padStart",
      "signature": "let padStart: (string, int, string) => string",
      "docstrings": ["`padStart(str, n, padStr)` returns a string that has been padded with `padStr`\n(multiple times, if needed) until the resulting string reaches the given `n`\nlength. The padding is applied from the start of the current string.\nSee [`String.padStart`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart) on MDN.\n\n## Examples\n\n```rescript\nString.padStart(\"abc\", 5, \" \") == \"  abc\"\nString.padStart(\"abc\", 6, \"123465\") == \"123abc\"\n```"]
    }, 
    {
      "id": "RescriptCore.String.padEnd",
      "kind": "value",
      "name": "padEnd",
      "signature": "let padEnd: (string, int, string) => string",
      "docstrings": ["`padEnd(str, n, padStr)` returns a string that has been padded with `padStr`\n(multiple times, if needed) until the resulting string reaches the given `n`\nlength. The padding is applied from the end of the current string.\nSee [`String.padEnd`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd) on MDN.\n\n## Examples\n\n```rescript\nString.padEnd(\"Hello\", 10, \".\") == \"Hello.....\"\nString.padEnd(\"abc\", 1, \"\") == \"abc\"\n```"]
    }, 
    {
      "id": "RescriptCore.String.getSymbol",
      "kind": "value",
      "name": "getSymbol",
      "signature": "let getSymbol: (string, Core__Symbol.t) => option<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.String.getSymbolUnsafe",
      "kind": "value",
      "name": "getSymbolUnsafe",
      "signature": "let getSymbolUnsafe: (string, Core__Symbol.t) => 'a",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.String.setSymbol",
      "kind": "value",
      "name": "setSymbol",
      "signature": "let setSymbol: (string, Core__Symbol.t, 'a) => unit",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.String.localeCompare",
      "kind": "value",
      "name": "localeCompare",
      "signature": "let localeCompare: (string, string) => float",
      "docstrings": ["`localeCompare(referenceStr, compareStr)` returns a float than indicatings\nwhether a reference string comes before or after, or is the same as the given\nstring in sort order. If `referenceStr` occurs before `compareStr` positive if\nthe `referenceStr` occurs after `compareStr`, `0` if they are equivalent.\nDo not rely on exact return values of `-1` or `1`\nSee [`String.localeCompare`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare) on MDN.\n\n## Examples\n\n```rescript\nString.localeCompare(\"a\", \"c\") < 0.0 == true\nString.localeCompare(\"a\", \"a\") == 0.0\n```"]
    }]
  }, 
  {
    "id": "RescriptCore.Symbol",
    "kind": "moduleAlias",
    "name": "Symbol",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Symbol.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = Js.Types.symbol",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Symbol.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: string => t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Symbol.getFor",
      "kind": "value",
      "name": "getFor",
      "signature": "let getFor: string => t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Symbol.keyFor",
      "kind": "value",
      "name": "keyFor",
      "signature": "let keyFor: t => option<string>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Symbol.asyncIterator",
      "kind": "value",
      "name": "asyncIterator",
      "signature": "let asyncIterator: t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Symbol.hasInstance",
      "kind": "value",
      "name": "hasInstance",
      "signature": "let hasInstance: t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Symbol.isConcatSpreadable",
      "kind": "value",
      "name": "isConcatSpreadable",
      "signature": "let isConcatSpreadable: t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Symbol.iterator",
      "kind": "value",
      "name": "iterator",
      "signature": "let iterator: t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Symbol.match",
      "kind": "value",
      "name": "match",
      "signature": "let match: t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Symbol.matchAll",
      "kind": "value",
      "name": "matchAll",
      "signature": "let matchAll: t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Symbol.replace",
      "kind": "value",
      "name": "replace",
      "signature": "let replace: t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Symbol.search",
      "kind": "value",
      "name": "search",
      "signature": "let search: t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Symbol.species",
      "kind": "value",
      "name": "species",
      "signature": "let species: t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Symbol.split",
      "kind": "value",
      "name": "split",
      "signature": "let split: t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Symbol.toPrimitive",
      "kind": "value",
      "name": "toPrimitive",
      "signature": "let toPrimitive: t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Symbol.toStringTag",
      "kind": "value",
      "name": "toStringTag",
      "signature": "let toStringTag: t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Symbol.unscopables",
      "kind": "value",
      "name": "unscopables",
      "signature": "let unscopables: t",
      "docstrings": []
    }]
  }, 
  {
    "id": "RescriptCore.Type",
    "kind": "moduleAlias",
    "name": "Type",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Type.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = [\\n  | #bigint\\n  | #boolean\\n  | #function\\n  | #number\\n  | #object\\n  | #string\\n  | #symbol\\n  | #undefined\\n]",
      "docstrings": ["The possible types of JavaScript values."]
    }, 
    {
      "id": "RescriptCore.Type.typeof",
      "kind": "value",
      "name": "typeof",
      "signature": "let typeof: 'a => t",
      "docstrings": ["`typeof(someValue)`\n\nReturns the underlying JavaScript type of any runtime value.\n\nSee [`typeof`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof) on MDN.\n\n## Examples\n```rescript\nConsole.log(Type.typeof(\"Hello\")) // Logs \"string\" to the console.\n\nlet someVariable = true\n\nswitch someVariable->Type.typeof {\n| #boolean => Console.log(\"This is a bool, yay!\")\n| _ => Console.log(\"Oh, not a bool sadly...\")\n}\n```"]
    }, 
    {
      "id": "RescriptCore.Type.Classify",
      "name": "Classify",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.Type.Classify.function",
        "kind": "type",
        "name": "function",
        "signature": "type function",
        "docstrings": ["An abstract type representing a JavaScript function.\n\n  See [`function`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) on MDN."]
      }, 
      {
        "id": "RescriptCore.Type.Classify.object",
        "kind": "type",
        "name": "object",
        "signature": "type object",
        "docstrings": ["An abstract type representing a JavaScript object.\n\n  See [`object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) on MDN."]
      }, 
      {
        "id": "RescriptCore.Type.Classify.t",
        "kind": "type",
        "name": "t",
        "signature": "type t =\\n  | Bool(bool)\\n  | Null\\n  | Undefined\\n  | String(string)\\n  | Number(float)\\n  | Object(object)\\n  | Function(function)\\n  | Symbol(Core__Symbol.t)\\n  | BigInt(Core__BigInt.t)",
        "docstrings": ["The type representing a classified JavaScript value."],
        "detail": 
        {
          "kind": "variant",
          "items": [
          {
            "name": "Bool",
            "docstrings": [],
            "signature": "Bool(bool)"
          }, 
          {
            "name": "Null",
            "docstrings": [],
            "signature": "Null"
          }, 
          {
            "name": "Undefined",
            "docstrings": [],
            "signature": "Undefined"
          }, 
          {
            "name": "String",
            "docstrings": [],
            "signature": "String(string)"
          }, 
          {
            "name": "Number",
            "docstrings": [],
            "signature": "Number(float)"
          }, 
          {
            "name": "Object",
            "docstrings": [],
            "signature": "Object(object)"
          }, 
          {
            "name": "Function",
            "docstrings": [],
            "signature": "Function(function)"
          }, 
          {
            "name": "Symbol",
            "docstrings": [],
            "signature": "Symbol(Core__Symbol.t)"
          }, 
          {
            "name": "BigInt",
            "docstrings": [],
            "signature": "BigInt(Core__BigInt.t)"
          }]
        }
      }, 
      {
        "id": "RescriptCore.Type.Classify.classify",
        "kind": "value",
        "name": "classify",
        "signature": "let classify: 'a => t",
        "docstrings": ["`classify(anyValue)`\nClassifies a JavaScript value.\n\n## Examples\n```rescript\nswitch %raw(`null`)->Type.Classify.classify {\n| Null => Console.log(\"Yup, that's null.\")\n| _ => Console.log(\"This doesn't actually appear to be null...\")\n}\n```"]
      }]
    }]
  }, 
  {
    "id": "RescriptCore.JSON",
    "kind": "moduleAlias",
    "name": "JSON",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.JSON.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = Js.Json.t",
      "docstrings": ["A type representing a JSON object."]
    }, 
    {
      "id": "RescriptCore.JSON.parseExn",
      "kind": "value",
      "name": "parseExn",
      "signature": "let parseExn: string => t",
      "docstrings": ["`parseExn(string)` \n\nParses a JSON string or throws a JavaScript exception (SyntaxError), if the string isn't valid.\nIt returns a JSON type.\n\n## Examples\n```rescript\ntry {\n  let _ = JSON.parseExn(`{\"foo\":\"bar\",\"hello\":\"world\"}`)\n  // { foo: 'bar', hello: 'world' }\n\n  let _ = JSON.parseExn(\"\")\n  // error\n} catch {\n| Exn.Error(obj) => Console.log(\"error\")\n}\n```\n\n## Exceptions \n\n- Raises a SyntaxError (Exn.t) if the string isn't valid JSON."]
    }, 
    {
      "id": "RescriptCore.JSON.parseExnWithReviver",
      "kind": "value",
      "name": "parseExnWithReviver",
      "signature": "let parseExnWithReviver: (string, (string, t) => t) => t",
      "docstrings": ["`parseExnWithReviver(string, reviver)` \n\nParses a JSON string or throws a JavaScript exception (SyntaxError), if the string isn't valid.\nThe reviver describes how the value should be transformed. It is a function which receives a key and a value.\nIt returns a JSON type.\n\n## Examples\n```rescript\nlet reviver = (key, value) => {\n  let valueType = JSON.Classify.classify(value)\n\n  switch valueType {\n  | String(string) => string->String.toUpperCase->JSON.Encode.string\n  | Number(number) => (number *. 2.0)->JSON.Encode.float\n  | _ => value\n  }\n}\n\nlet jsonString = `{\"hello\":\"world\",\"someNumber\":21}`\n\ntry {\n  JSON.parseExnWithReviver(jsonString, reviver)->Console.log\n  // { hello: 'WORLD', someNumber: 42 }\n\n  JSON.parseExnWithReviver(\"\", reviver)->Console.log\n  // error\n} catch {\n| Exn.Error(_) => Console.log(\"error\")\n}\n```\n\n## Exceptions \n\n- Raises a SyntaxError if the string isn't valid JSON."]
    }, 
    {
      "id": "RescriptCore.JSON.stringify",
      "kind": "value",
      "name": "stringify",
      "signature": "let stringify: t => string",
      "docstrings": ["`stringify(json)` \n\nConverts a JSON object to a JSON string.\nIf you want to stringify any type, use `JSON.stringifyAny` instead.\n\n## Examples\n```rescript\nlet json =\n  Dict.fromArray([\n    (\"foo\", JSON.Encode.string(\"bar\")),\n    (\"hello\", JSON.Encode.string(\"world\")),\n    (\"someNumber\", JSON.Encode.int(42)),\n  ])->JSON.Encode.object\n\nJSON.stringify(json)\n// {\"foo\":\"bar\",\"hello\":\"world\",\"someNumber\":42}\n```"]
    }, 
    {
      "id": "RescriptCore.JSON.stringifyWithIndent",
      "kind": "value",
      "name": "stringifyWithIndent",
      "signature": "let stringifyWithIndent: (t, int) => string",
      "docstrings": ["`stringifyWithIndent(json, indentation)` \n\nConverts a JSON object to a JSON string. The output will be indented.\nIf you want to stringify any type, use `JSON.stringifyAnyWithIndent` instead.\n\n## Examples\n```rescript\nlet json =\n  Dict.fromArray([\n    (\"foo\", JSON.Encode.string(\"bar\")),\n    (\"hello\", JSON.Encode.string(\"world\")),\n    (\"someNumber\", JSON.Encode.int(42)),\n  ])->JSON.Encode.object\n\nJSON.stringifyWithIndent(json, 2)\n// {\n//   \"foo\": \"bar\",\n//   \"hello\": \"world\",\n//   \"someNumber\": 42\n// }\n```"]
    }, 
    {
      "id": "RescriptCore.JSON.stringifyWithReplacer",
      "kind": "value",
      "name": "stringifyWithReplacer",
      "signature": "let stringifyWithReplacer: (t, (string, t) => t) => string",
      "docstrings": ["`stringifyWithReplacer(json, replacer)` \n\nConverts a JSON object to a JSON string.\nThe replacer describes how the value should be transformed. It is a function which receives a key and a value.\nIf you want to stringify any type, use `JSON.stringifyAnyWithReplacer` instead.\n\n## Examples\n```rescript\nlet json =\n  Dict.fromArray([\n    (\"foo\", JSON.Encode.string(\"bar\")),\n    (\"hello\", JSON.Encode.string(\"world\")),\n    (\"someNumber\", JSON.Encode.int(42)),\n  ])->JSON.Encode.object\n\nlet replacer = (key, value) => {\n  let decodedValue = value->JSON.Decode.string\n\n  switch decodedValue {\n  | Some(string) => string->String.toUpperCase->JSON.Encode.string\n  | None => value\n  }\n}\n\nJSON.stringifyWithReplacer(json, replacer)\n// {\"foo\":\"BAR\",\"hello\":\"WORLD\",\"someNumber\":42}\n```"]
    }, 
    {
      "id": "RescriptCore.JSON.stringifyWithReplacerAndIndent",
      "kind": "value",
      "name": "stringifyWithReplacerAndIndent",
      "signature": "let stringifyWithReplacerAndIndent: (t, (string, t) => t, int) => string",
      "docstrings": ["`stringifyWithReplacerAndIndent(json, replacer, indentation)` \n\nConverts a JSON object to a JSON string. The output will be indented.\nThe replacer describes how the value should be transformed. It is a function which receives a key and a value.\nIf you want to stringify any type, use `JSON.stringifyAnyWithReplacerAndIndent` instead.\n\n## Examples\n```rescript\nlet json =\n  Dict.fromArray([\n    (\"foo\", JSON.Encode.string(\"bar\")),\n    (\"hello\", JSON.Encode.string(\"world\")),\n    (\"someNumber\", JSON.Encode.int(42)),\n  ])->JSON.Encode.object\n\nlet replacer = (key, value) => {\n  let decodedValue = value->JSON.Decode.string\n\n  switch decodedValue {\n  | Some(string) => string->String.toUpperCase->JSON.Encode.string\n  | None => value\n  }\n}\n\nJSON.stringifyWithReplacerAndIndent(json, replacer, 2)\n// {\n  \"foo\": \"BAR\",\n  \"hello\": \"WORLD\",\n  \"someNumber\": 42\n}\n```"]
    }, 
    {
      "id": "RescriptCore.JSON.stringifyWithFilter",
      "kind": "value",
      "name": "stringifyWithFilter",
      "signature": "let stringifyWithFilter: (t, array<string>) => string",
      "docstrings": ["`stringifyWithFilter(json, filter)` \n\nConverts a JSON object to a JSON string.\nThe filter is an array of keys, which should be included in the output.\nIf you want to stringify any type, use `JSON.stringifyAnyWithFilter` instead.\n\n## Examples\n```rescript\nlet json =\n  Dict.fromArray([\n    (\"foo\", JSON.Encode.string(\"bar\")),\n    (\"hello\", JSON.Encode.string(\"world\")),\n    (\"someNumber\", JSON.Encode.int(42)),\n  ])->JSON.Encode.object\n\nJSON.stringifyWithFilter(json, [\"foo\", \"someNumber\"])\n// {\"foo\":\"bar\",\"someNumber\":42}\n```"]
    }, 
    {
      "id": "RescriptCore.JSON.stringifyWithFilterAndIndent",
      "kind": "value",
      "name": "stringifyWithFilterAndIndent",
      "signature": "let stringifyWithFilterAndIndent: (t, array<string>, int) => string",
      "docstrings": ["`stringifyWithFilterAndIndent(json, filter, indentation)` \n\nConverts a JSON object to a JSON string. The output will be indented.\nThe filter is an array of keys, which should be included in the output.\nIf you want to stringify any type, use `JSON.stringifyAnyWithFilterAndIndent` instead.\n\n## Examples\n```rescript\nlet json =\n  Dict.fromArray([\n    (\"foo\", JSON.Encode.string(\"bar\")),\n    (\"hello\", JSON.Encode.string(\"world\")),\n    (\"someNumber\", JSON.Encode.int(42)),\n  ])->JSON.Encode.object\n\nJSON.stringifyWithFilterAndIndent(json, [\"foo\", \"someNumber\"], 2)\n// {\n//   \"foo\": \"bar\",\n//   \"someNumber\": 42\n// }\n```"]
    }, 
    {
      "id": "RescriptCore.JSON.stringifyAny",
      "kind": "value",
      "name": "stringifyAny",
      "signature": "let stringifyAny: 'a => option<string>",
      "docstrings": ["`stringifyAny(any)` \n\nConverts any type to a JSON string.\nStringifying a function or `undefined` will return `None`.\nIf the value contains circular references or `BigInt`s, the function will throw a JavaScript exception (TypeError).\nIf you want to stringify a JSON object, use `JSON.stringify` instead.\n\n## Examples\n```rescript\nlet dict = Dict.fromArray([\n  (\"foo\", JSON.Encode.string(\"bar\")),\n  (\"hello\", JSON.Encode.string(\"world\")),\n  (\"someNumber\", JSON.Encode.int(42)),\n])\n\nJSON.stringifyAny(dict)\n// {\"foo\":\"bar\",\"hello\":\"world\",\"someNumber\":42}\n\nJSON.stringifyAny(() => \"hello world\")\n// None\n\nBigInt.fromInt(0)->JSON.stringifyAny\n// exception\n```\n\n## Exceptions \n\n- Raises a TypeError if the value contains circular references.\n- Raises a TypeError if the value contains `BigInt`s."]
    }, 
    {
      "id": "RescriptCore.JSON.stringifyAnyWithIndent",
      "kind": "value",
      "name": "stringifyAnyWithIndent",
      "signature": "let stringifyAnyWithIndent: ('a, int) => option<string>",
      "docstrings": ["`stringifyAnyWithIndent(any, indentation)` \n\nConverts any type to a JSON string. The output will be indented.\nStringifying a function or `undefined` will return `None`.\nIf the value contains circular references or `BigInt`s, the function will throw a JavaScript exception (TypeError).\nIf you want to stringify a JSON object, use `JSON.stringifyWithIndent` instead.\n\n## Examples\n```rescript\nlet dict = Dict.fromArray([\n  (\"foo\", JSON.Encode.string(\"bar\")),\n  (\"hello\", JSON.Encode.string(\"world\")),\n  (\"someNumber\", JSON.Encode.int(42)),\n])\n\nJSON.stringifyAnyWithIndent(dict, 2)\n// {\n//   \"foo\": \"bar\",\n//   \"hello\": \"world\",\n//   \"someNumber\": 42\n// }\n\nJSON.stringifyAny(() => \"hello world\")\n// None\n\nBigInt.fromInt(0)->JSON.stringifyAny\n// exception\n```\n\n## Exceptions \n\n- Raises a TypeError if the value contains circular references.\n- Raises a TypeError if the value contains `BigInt`s."]
    }, 
    {
      "id": "RescriptCore.JSON.stringifyAnyWithReplacer",
      "kind": "value",
      "name": "stringifyAnyWithReplacer",
      "signature": "let stringifyAnyWithReplacer: ('a, (string, t) => t) => option<string>",
      "docstrings": ["`stringifyAnyWithReplacer(json, replacer)` \n\nConverts any type to a JSON string.\nThe replacer describes how the value should be transformed. It is a function which receives a key and a value.\nStringifying a function or `undefined` will return `None`.\nIf the value contains circular references or `BigInt`s, the function will throw a JavaScript exception (TypeError).\nIf you want to stringify a JSON object, use `JSON.stringifyWithReplacer` instead.\n\n## Examples\n```rescript\nlet dict = Dict.fromArray([\n  (\"foo\", JSON.Encode.string(\"bar\")),\n  (\"hello\", JSON.Encode.string(\"world\")),\n  (\"someNumber\", JSON.Encode.int(42)),\n])\n\nlet replacer = (key, value) => {\n  let decodedValue = value->JSON.Decode.string\n\n  switch decodedValue {\n  | Some(string) => string->String.toUpperCase->JSON.Encode.string\n  | None => value\n  }\n}\n\nJSON.stringifyAnyWithReplacer(dict, replacer)\n// {\"foo\":\"BAR\",\"hello\":\"WORLD\",\"someNumber\":42}\n\nJSON.stringifyAny(() => \"hello world\")\n// None\n\nBigInt.fromInt(0)->JSON.stringifyAny\n// exception\n```\n\n## Exceptions \n\n- Raises a TypeError if the value contains circular references.\n- Raises a TypeError if the value contains `BigInt`s."]
    }, 
    {
      "id": "RescriptCore.JSON.stringifyAnyWithReplacerAndIndent",
      "kind": "value",
      "name": "stringifyAnyWithReplacerAndIndent",
      "signature": "let stringifyAnyWithReplacerAndIndent: ('a, (string, t) => t, int) => option<string>",
      "docstrings": ["`stringifyAnyWithReplacerAndIndent(json, replacer, indentation)` \n\nConverts any type to a JSON string. The output will be indented.\nThe replacer describes how the value should be transformed. It is a function which receives a key and a value.\nStringifying a function or `undefined` will return `None`.\nIf the value contains circular references or `BigInt`s, the function will throw a JavaScript exception (TypeError).\nIf you want to stringify a JSON object, use `JSON.stringifyWithReplacerAndIndent` instead.\n\n## Examples\n```rescript\nlet dict = Dict.fromArray([\n  (\"foo\", JSON.Encode.string(\"bar\")),\n  (\"hello\", JSON.Encode.string(\"world\")),\n  (\"someNumber\", JSON.Encode.int(42)),\n])\n\nlet replacer = (key, value) => {\n  let decodedValue = value->JSON.Decode.string\n\n  switch decodedValue {\n  | Some(string) => string->String.toUpperCase->JSON.Encode.string\n  | None => value\n  }\n}\n\nJSON.stringifyAnyWithReplacerAndIndent(dict, replacer, 2)\n// {\n//   \"foo\": \"BAR\",\n//   \"hello\": \"WORLD\",\n//   \"someNumber\": 42\n// }\n\nJSON.stringifyAny(() => \"hello world\")\n// None\n\nBigInt.fromInt(0)->JSON.stringifyAny\n// exception\n```\n\n## Exceptions \n\n- Raises a TypeError if the value contains circular references.\n- Raises a TypeError if the value contains `BigInt`s."]
    }, 
    {
      "id": "RescriptCore.JSON.stringifyAnyWithFilter",
      "kind": "value",
      "name": "stringifyAnyWithFilter",
      "signature": "let stringifyAnyWithFilter: ('a, array<string>) => string",
      "docstrings": ["`stringifyAnyWithFilter(json, filter)` \n\nConverts any type to a JSON string.\nThe filter is an array of keys, which should be included in the output.\nStringifying a function or `undefined` will return `None`.\nIf the value contains circular references or `BigInt`s, the function will throw a JavaScript exception (TypeError).\nIf you want to stringify a JSON object, use `JSON.stringifyWithFilter` instead.\n\n## Examples\n```rescript\nlet dict = Dict.fromArray([\n  (\"foo\", JSON.Encode.string(\"bar\")),\n  (\"hello\", JSON.Encode.string(\"world\")),\n  (\"someNumber\", JSON.Encode.int(42)),\n])\n\nJSON.stringifyAnyWithFilter(dict, [\"foo\", \"someNumber\"])\n// {\"foo\": \"bar\",\"someNumber\": 42}\n\nJSON.stringifyAny(() => \"hello world\")\n// None\n\nBigInt.fromInt(0)->JSON.stringifyAny\n// exception\n```\n\n## Exceptions \n\n- Raises a TypeError if the value contains circular references.\n- Raises a TypeError if the value contains `BigInt`s."]
    }, 
    {
      "id": "RescriptCore.JSON.stringifyAnyWithFilterAndIndent",
      "kind": "value",
      "name": "stringifyAnyWithFilterAndIndent",
      "signature": "let stringifyAnyWithFilterAndIndent: ('a, array<string>, int) => string",
      "docstrings": ["`stringifyAnyWithFilterAndIndent(json, filter, indentation)` \n\nConverts any type to a JSON string. The output will be indented.\nThe filter is an array of keys, which should be included in the output.\nStringifying a function or `undefined` will return `None`.\nIf the value contains circular references or `BigInt`s, the function will throw a JavaScript exception (TypeError).\nIf you want to stringify a JSON object, use `JSON.stringifyWithFilterAndIndent` instead.\n\n## Examples\n```rescript\nlet dict = Dict.fromArray([\n  (\"foo\", JSON.Encode.string(\"bar\")),\n  (\"hello\", JSON.Encode.string(\"world\")),\n  (\"someNumber\", JSON.Encode.int(42)),\n])\n\nJSON.stringifyAnyWithFilterAndIndent(dict, [\"foo\", \"someNumber\"], 2)\n// {\n//   \"foo\": \"bar\",\n//   \"someNumber\": 42\n// }\n\nJSON.stringifyAny(() => \"hello world\")\n// None\n\nBigInt.fromInt(0)->JSON.stringifyAny\n// exception\n```\n\n## Exceptions \n\n- Raises a TypeError if the value contains circular references.\n- Raises a TypeError if the value contains `BigInt`s."]
    }, 
    {
      "id": "RescriptCore.JSON.Classify",
      "name": "Classify",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.JSON.Classify.t",
        "kind": "type",
        "name": "t",
        "signature": "type t =\\n  | Bool(bool)\\n  | Null\\n  | String(string)\\n  | Number(float)\\n  | Object(Core__Dict.t<t>)\\n  | Array(array<t>)",
        "docstrings": ["A type representing a JavaScript type."],
        "detail": 
        {
          "kind": "variant",
          "items": [
          {
            "name": "Bool",
            "docstrings": [],
            "signature": "Bool(bool)"
          }, 
          {
            "name": "Null",
            "docstrings": [],
            "signature": "Null"
          }, 
          {
            "name": "String",
            "docstrings": [],
            "signature": "String(string)"
          }, 
          {
            "name": "Number",
            "docstrings": [],
            "signature": "Number(float)"
          }, 
          {
            "name": "Object",
            "docstrings": [],
            "signature": "Object(Core__Dict.t<t>)"
          }, 
          {
            "name": "Array",
            "docstrings": [],
            "signature": "Array(array<t>)"
          }]
        }
      }, 
      {
        "id": "RescriptCore.JSON.Classify.classify",
        "kind": "value",
        "name": "classify",
        "signature": "let classify: 'a => t",
        "docstrings": ["Returns the JSON type of any value.\n\n  ## Examples\n  ```rescript\n  JSON.Classify.classify(\"hello world\")\n  // String(\"hello world\")\n\n  JSON.Classify.classify(42)\n  // Number(42)\n  ```"]
      }]
    }, 
    {
      "id": "RescriptCore.JSON.Encode",
      "name": "Encode",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.JSON.Encode.bool",
        "kind": "value",
        "name": "bool",
        "signature": "let bool: bool => t",
        "docstrings": ["Returns a boolean as a JSON object.\n\n  ## Examples\n  ```rescript\n  JSON.Encode.bool(true)\n  ```"]
      }, 
      {
        "id": "RescriptCore.JSON.Encode.null",
        "kind": "value",
        "name": "null",
        "signature": "let null: t",
        "docstrings": ["Returns null as a JSON object.\n\n  ## Examples\n  ```rescript\n  JSON.Encode.null\n  ```"]
      }, 
      {
        "id": "RescriptCore.JSON.Encode.string",
        "kind": "value",
        "name": "string",
        "signature": "let string: string => t",
        "docstrings": ["Returns a string as a JSON object.\n\n  ## Examples\n  ```rescript\n  JSON.Encode.string(\"hello world\")\n  ```"]
      }, 
      {
        "id": "RescriptCore.JSON.Encode.int",
        "kind": "value",
        "name": "int",
        "signature": "let int: int => t",
        "docstrings": ["Returns an int as a JSON object.\n\n  ## Examples\n  ```rescript\n  JSON.Encode.int(42)\n  ```"]
      }, 
      {
        "id": "RescriptCore.JSON.Encode.float",
        "kind": "value",
        "name": "float",
        "signature": "let float: float => t",
        "docstrings": ["Returns a float as a JSON object.\n\n  ## Examples\n  ```rescript\n  JSON.Encode.float(42.0)\n  ```"]
      }, 
      {
        "id": "RescriptCore.JSON.Encode.object",
        "kind": "value",
        "name": "object",
        "signature": "let object: Core__Dict.t<t> => t",
        "docstrings": ["Returns a dict as a JSON object.\n\n  ## Examples\n  ```rescript\n  let dict = Dict.fromArray([\n    (\"foo\", JSON.Encode.string(\"bar\")),\n    (\"hello\", JSON.Encode.string(\"world\")),\n  ])\n\n  JSON.Encode.object(dict)\n  ```"]
      }, 
      {
        "id": "RescriptCore.JSON.Encode.array",
        "kind": "value",
        "name": "array",
        "signature": "let array: array<t> => t",
        "docstrings": ["Returns an array as a JSON object.\n\n  ## Examples\n  ```rescript\n  let array = [JSON.Encode.string(\"hello world\"), JSON.Encode.int(42)]\n\n  JSON.Encode.array(array)\n  ```"]
      }]
    }, 
    {
      "id": "RescriptCore.JSON.Decode",
      "name": "Decode",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.JSON.Decode.bool",
        "kind": "value",
        "name": "bool",
        "signature": "let bool: t => option<bool>",
        "docstrings": ["Decodes a single JSON value. If the value is a bool, it will return `Some(bool)` - otherwise it will return `None`.\n\n  ## Examples\n  ```rescript\n  JSON.parseExn(`true`)->JSON.Decode.bool\n  // Some(true)\n\n  JSON.parseExn(`\"hello world\"`)->JSON.Decode.bool\n  // None\n  ```"]
      }, 
      {
        "id": "RescriptCore.JSON.Decode.null",
        "kind": "value",
        "name": "null",
        "signature": "let null: t => option<Core__Null.t<'a>>",
        "docstrings": ["Decodes a single JSON value. If the value is null, it will return `Some(Null.t)` - otherwise it will return `None`.\n\n  ## Examples\n  ```rescript\n  JSON.parseExn(`null`)->JSON.Decode.null\n  // Some(null)\n\n  JSON.parseExn(`\"hello world\"`)->JSON.Decode.null\n  // None\n  ```"]
      }, 
      {
        "id": "RescriptCore.JSON.Decode.string",
        "kind": "value",
        "name": "string",
        "signature": "let string: t => option<string>",
        "docstrings": ["Decodes a single JSON value. If the value is a string, it will return `Some(string)` - otherwise it will return `None`.\n\n  ## Examples\n  ```rescript\n  JSON.parseExn(`\"hello world\"`)->JSON.Decode.string\n  // Some(\"hello world\")\n\n  JSON.parseExn(`42`)->JSON.Decode.string\n  // None \n  ```"]
      }, 
      {
        "id": "RescriptCore.JSON.Decode.float",
        "kind": "value",
        "name": "float",
        "signature": "let float: t => option<float>",
        "docstrings": ["Decodes a single JSON value. If the value is a float, it will return `Some(float)` - otherwise it will return `None`.\n\n  ## Examples\n  ```rescript\n  JSON.parseExn(`42.0`)->JSON.Decode.float\n  // Some(42.0)\n\n  JSON.parseExn(`\"hello world\"`)->JSON.Decode.float\n  // None\n  ```"]
      }, 
      {
        "id": "RescriptCore.JSON.Decode.object",
        "kind": "value",
        "name": "object",
        "signature": "let object: t => option<Core__Dict.t<t>>",
        "docstrings": ["Decodes a single JSON value. If the value is an object, it will return `Some(Dict.t)` - otherwise it will return `None`.\n\n  ## Examples\n  ```rescript\n  JSON.parseExn(`{\"foo\":\"bar\"}`)->JSON.Decode.object\n  // Some({ foo: 'bar' })\n\n  JSON.parseExn(`\"hello world\"`)->JSON.Decode.object\n  // None\n  ```"]
      }, 
      {
        "id": "RescriptCore.JSON.Decode.array",
        "kind": "value",
        "name": "array",
        "signature": "let array: t => option<array<t>>",
        "docstrings": ["Decodes a single JSON value. If the value is an array, it will return `Some(array)` - otherwise it will return `None`.\n\n  ## Examples\n  ```rescript\n  JSON.parseExn(`[\"foo\", \"bar\"]`)->JSON.Decode.array\n  // Some([ 'foo', 'bar' ])\n\n  JSON.parseExn(`\"hello world\"`)->JSON.Decode.array\n  // None\n  ```"]
      }]
    }]
  }, 
  {
    "id": "RescriptCore.Iterator",
    "kind": "moduleAlias",
    "name": "Iterator",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Iterator.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'a>",
      "docstrings": ["The type representing an iterator."]
    }, 
    {
      "id": "RescriptCore.Iterator.value",
      "kind": "type",
      "name": "value",
      "signature": "type value<'a> = {done: bool, value: option<'a>}",
      "docstrings": ["The current value of an iterator."],
      "detail": 
      {
        "kind": "record",
        "items": [{
          "name": "done",
          "optional": false,
          "docstrings": ["Whether there are more values to iterate on before the iterator is done."],
          "signature": "bool"
        }, {
          "name": "value",
          "optional": false,
          "docstrings": ["The value of this iteration, if any."],
          "signature": "option<'a>"
        }]
      }
    }, 
    {
      "id": "RescriptCore.Iterator.next",
      "kind": "value",
      "name": "next",
      "signature": "let next: t<'a> => value<'a>",
      "docstrings": ["Returns the next value of the iterator, if any.\n\nSee [iterator protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) on MDN.\n\n## Examples\n```rescript\n// Pulls out the next value of the iterator\nlet {done, value} = someIterator->Iterator.next\n```"]
    }, 
    {
      "id": "RescriptCore.Iterator.toArray",
      "kind": "value",
      "name": "toArray",
      "signature": "let toArray: t<'a> => array<'a>",
      "docstrings": ["Turns an iterator into an array of the remaining values.\nRemember that each invocation of `next` of an iterator consumes a value. `Iterator.toArray` will consume all remaining values of the iterator and return them in an array to you.\n\nSee [iterator protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) on MDN.\n\n## Examples\n```rescript\nlet map = Map.make()\nmap->Map.set(\"someKey\", \"someValue\")\nmap->Map.set(\"someKey2\", \"someValue2\")\n\n// `Map.keys` returns all keys of the map as an iterator.\nlet mapKeysAsArray = map->Map.keys->Iterator.toArray\n\nConsole.log(mapKeysAsArray) // Logs [\"someKey\", \"someKey2\"] to the console.\n```"]
    }, 
    {
      "id": "RescriptCore.Iterator.toArrayWithMapper",
      "kind": "value",
      "name": "toArrayWithMapper",
      "signature": "let toArrayWithMapper: (t<'a>, 'a => 'b) => array<'b>",
      "docstrings": ["`toArray(iterator)` turns `iterator` into an array of its remaining values, applying the provided mapper function on each item.\nRemember that each invocation of `next` of an iterator consumes a value. `Iterator.toArrayWithMapper` will consume all remaining values of the iterator and return them in an array to you.\n\nSee [iterator protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) on MDN.\n\n## Examples\n```rescript\nlet map = Map.make()\nmap->Map.set(\"someKey\", \"someValue\")\nmap->Map.set(\"someKey2\", \"someValue2\")\n\n// `Map.keys` returns all keys of the map as an iterator.\nlet mapKeysAsArray = map\n  ->Map.keys\n  ->Iterator.toArrayWithMapper(key => key->String.length)\n\nConsole.log(mapKeysAsArray) // Logs [7, 8] to the console.\n```"]
    }]
  }, 
  {
    "id": "RescriptCore.AsyncIterator",
    "kind": "moduleAlias",
    "name": "AsyncIterator",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.AsyncIterator.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'a>",
      "docstrings": ["The type representing an async iterator."]
    }, 
    {
      "id": "RescriptCore.AsyncIterator.value",
      "kind": "type",
      "name": "value",
      "signature": "type value<'a> = {done: bool, value: option<'a>}",
      "docstrings": [],
      "detail": 
      {
        "kind": "record",
        "items": [{
          "name": "done",
          "optional": false,
          "docstrings": ["Whether there are more values to iterate on before the iterator is done."],
          "signature": "bool"
        }, {
          "name": "value",
          "optional": false,
          "docstrings": ["The value of this iteration, if any."],
          "signature": "option<'a>"
        }]
      }
    }, 
    {
      "id": "RescriptCore.AsyncIterator.next",
      "kind": "value",
      "name": "next",
      "signature": "let next: t<'a> => promise<value<'a>>",
      "docstrings": ["`next(asyncIterator)`\n\nReturns the next value of the iterator, if any.\n\nSee [async iterator protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols) on MDN.\n\n## Examples\n- A simple example, getting the next value:\n```rescript\nlet {done, value} = await someAsyncIterator->AsyncIterator.next\n```\n\n- Complete example, including looping over all values:\n```rescript\n// Let's pretend we get an async iterator returning ints from somewhere.\n@val external asyncIterator: AsyncIterator.t<int> = \"someAsyncIterator\"\n\n\nlet processMyAsyncIterator = async () => {\n  // ReScript doesn't have `for ... of` loops, but it's easy to mimic using a while loop.\n  let break = ref(false)\n\n  while !break.contents {\n    // Await the next iterator value\n    let {value, done} = await asyncIterator->AsyncIterator.next\n\n    // Exit the while loop if the iterator says it's done\n    break := done\n\n    // This will log the (int) value of the current async iteration, if a value was returned.\n    Console.log(value)\n  }\n}\n```"]
    }]
  }, 
  {
    "id": "RescriptCore.Map",
    "kind": "moduleAlias",
    "name": "Map",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Map.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'k, 'v> = Js.Map.t<'k, 'v>",
      "docstrings": ["Type representing an instance of `Map`."]
    }, 
    {
      "id": "RescriptCore.Map.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: unit => t<'k, 'v>",
      "docstrings": ["Creates a new, mutable JavaScript `Map`. A `Map` can have any values as both keys and values.\n\nSee [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) on MDN.\n\n\n\n## Examples\n```rescript\n`make()`\n// You can annotate the type of your map if you want to\nlet myMap: Map.t<string, int> = Map.make()\n\n// Or you can let ReScript infer what's in your map\nlet map = Map.make()\nmap->Map.set(\"lang\", \"ReScript\") // Inferred as Map.t<string, string>\n```\n\n## Alternatives\nA JavaScript `Map` is mutable. If you're looking for an immutable alternative, check out`Belt.Map`."]
    }, 
    {
      "id": "RescriptCore.Map.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: array<('k, 'v)> => t<'k, 'v>",
      "docstrings": ["Turns an array of key/value pairs into a Map.\n\n## Examples\n```rescript\ntype languages = ReScript | JavaScript | TypeScript\nlet languageRank = [(ReScript, 1), (JavaScript, 2), (TypeScript, 3)]\n\nlet map = Map.fromArray(languageRank) // Map.t<languages, int>\n\nswitch map->Map.get(ReScript) {\n| Some(1) => Console.log(\"Yay, ReScript is #1!\")\n| _ => Console.log(\"Uh-oh, something is _terribly_ wrong with this program... abort.\")\n}\n```"]
    }, 
    {
      "id": "RescriptCore.Map.fromIterator",
      "kind": "value",
      "name": "fromIterator",
      "signature": "let fromIterator: Core__Iterator.t<('k, 'v)> => t<'k, 'v>",
      "docstrings": ["Turns an iterator in the shape of `('key, 'value)` into a `Map`.\n\n## Examples\n```rescript\n// Let's pretend we have an interator in the correct shape\n@val external someIterator: Iterator.t<(string, int)> = \"someIterator\"\n\nlet map = Map.fromIterator(someIterator) // Map.t<string, int>\n```"]
    }, 
    {
      "id": "RescriptCore.Map.size",
      "kind": "value",
      "name": "size",
      "signature": "let size: t<'k, 'v> => int",
      "docstrings": ["Returns the size, the number of key/value pairs, of the map.\n\n## Examples\n```rescript\nlet map = Map.make()\n\nmap->Map.set(\"someKey\", \"someValue\")\n\nlet size = map->Map.size // 1\n```"]
    }, 
    {
      "id": "RescriptCore.Map.clear",
      "kind": "value",
      "name": "clear",
      "signature": "let clear: t<'k, 'v> => unit",
      "docstrings": ["Clears all entries in the map.\n\n## Examples\n```rescript\nlet map = Map.make()\n\nmap->Map.set(\"someKey\", \"someValue\")\nlet size = map->Map.size // 1\n\nmap->Map.clear\nlet size = map->Map.size // 0\n```"]
    }, 
    {
      "id": "RescriptCore.Map.forEach",
      "kind": "value",
      "name": "forEach",
      "signature": "let forEach: (t<'k, 'v>, 'v => unit) => unit",
      "docstrings": ["Iterates through all values of the map.\n\n> Please note that this is *without the keys*, just the values. If you need the key as well, use `Map.forEachWithKey`.\n\n## Examples\n```rescript\nlet map = Map.make()\nmap->Map.set(\"someKey\", \"someValue\")\nmap->Map.set(\"someKey2\", \"someValue2\")\n\nmap->Map.forEach(value => {\n  Console.log(value)\n})\n```"]
    }, 
    {
      "id": "RescriptCore.Map.forEachWithKey",
      "kind": "value",
      "name": "forEachWithKey",
      "signature": "let forEachWithKey: (t<'k, 'v>, ('v, 'k) => unit) => unit",
      "docstrings": ["Iterates through all values of the map, including the key for each value.\n\n## Examples\n```rescript\nlet map = Map.make()\nmap->Map.set(\"someKey\", \"someValue\")\nmap->Map.set(\"someKey2\", \"someValue2\")\n\nmap->Map.forEachWithKey((value, key) => {\n  Console.log2(value, key)\n})\n```"]
    }, 
    {
      "id": "RescriptCore.Map.get",
      "kind": "value",
      "name": "get",
      "signature": "let get: (t<'k, 'v>, 'k) => option<'v>",
      "docstrings": ["Returns the value for a key, if a value exists at that key.\n\n## Examples\n```rescript\nlet map = Map.make()\nmap->Map.set(\"someKey\", \"someValue\")\n\nswitch map->Map.get(\"someKey\") {\n| None => Console.log(\"Nope, didn't have it.\")\n| Some(value) => Console.log2(\"Yay, had the value, and it's:\", value)\n}\n```"]
    }, 
    {
      "id": "RescriptCore.Map.has",
      "kind": "value",
      "name": "has",
      "signature": "let has: (t<'k, 'v>, 'k) => bool",
      "docstrings": ["Checks whether the map has a specific key.\n\n## Examples\n```rescript\nlet map = Map.make()\nmap->Map.set(\"someKey\", \"someValue\")\n\nswitch map->Map.has(\"someKey\") {\n| false => Console.log(\"Nope, didn't have it.\")\n| true => Console.log(\"Yay, we have the value!\")\n}\n```"]
    }, 
    {
      "id": "RescriptCore.Map.set",
      "kind": "value",
      "name": "set",
      "signature": "let set: (t<'k, 'v>, 'k, 'v) => unit",
      "docstrings": ["Sets the provided `value` to the provided `key`.\n\n## Examples\n```rescript\nlet map = Map.make()\nmap->Map.set(\"someKey\", \"someValue\")\n```"]
    }, 
    {
      "id": "RescriptCore.Map.delete",
      "kind": "value",
      "name": "delete",
      "signature": "let delete: (t<'k, 'v>, 'k) => bool",
      "docstrings": ["Deletes the provided `key` and its value from the map. Returns a `bool` for whether the key existed, and was deleted.\n\n## Examples\n```rescript\nlet map = Map.make()\nmap->Map.set(\"someKey\", \"someValue\")\nlet didDeleteKey = map->Map.delete(\"someKey\")\nConsole.log(didDeleteKey) // Logs `true` to the console, becuase the map had the key, so it was successfully deleted\n\nlet didDeleteKey = map->Map.delete(\"someNonExistantKey\")\nConsole.log(didDeleteKey) // Logs `false` to the console, becuase the key did not exist\n```"]
    }, 
    {
      "id": "RescriptCore.Map.keys",
      "kind": "value",
      "name": "keys",
      "signature": "let keys: t<'k, 'v> => Core__Iterator.t<'k>",
      "docstrings": ["Returns an iterator that holds all keys of the map.\n\n## Examples\n```rescript\nlet map = Map.make()\nmap->Map.set(\"someKey\", \"someValue\")\nmap->Map.set(\"anotherKey\", \"anotherValue\")\n\nlet keys = map->Map.keys\n\n// Logs the first key\nConsole.log(Iterator.next(keys).value)\n\n// You can also turn the iterator into an array.\n// Remember that an iterator consumes values. We'll need a fresh keys iterator to get an array of all keys, since we consumed a value via `next` above already.\nConsole.log(map->Map.keys->Iterator.toArray)\n```"]
    }, 
    {
      "id": "RescriptCore.Map.values",
      "kind": "value",
      "name": "values",
      "signature": "let values: t<'k, 'v> => Core__Iterator.t<'v>",
      "docstrings": ["Returns an iterator that holds all values of the map.\n\n## Examples\n```rescript\nlet map = Map.make()\nmap->Map.set(\"someKey\", \"someValue\")\nmap->Map.set(\"anotherKey\", \"anotherValue\")\n\nlet values = map->Map.values\n\n// Logs the first value\nConsole.log(Iterator.next(values).value)\n\n// You can also turn the iterator into an array.\n// Remember that an iterator consumes values. We'll need a fresh values iterator to get an array of all values, since we consumed a value via `next` above already.\nConsole.log(map->Map.values->Iterator.toArray)\n```"]
    }, 
    {
      "id": "RescriptCore.Map.entries",
      "kind": "value",
      "name": "entries",
      "signature": "let entries: t<'k, 'v> => Core__Iterator.t<('k, 'v)>",
      "docstrings": ["Returns an iterator that holds all entries of the map.\nAn entry is represented as a tuple of `('key, 'value)`,\n\n## Examples\n```rescript\nlet map = Map.make()\nmap->Map.set(\"someKey\", \"someValue\")\nmap->Map.set(\"anotherKey\", \"anotherValue\")\n\nlet entries = map->Map.entries\n\n// Logs the first value\nConsole.log(Iterator.next(entries).value)\n\n// You can also turn the iterator into an array.\n// Remember that an iterator consumes entries. We'll need a fresh entries iterator to get an array of all entries, since we consumed a value via `next` above already.\nConsole.log(map->Map.entries->Iterator.toArray)\n```"]
    }]
  }, 
  {
    "id": "RescriptCore.WeakMap",
    "kind": "moduleAlias",
    "name": "WeakMap",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.WeakMap.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'k, 'v> = Js.WeakMap.t<'k, 'v>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.WeakMap.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: unit => t<'k, 'v>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.WeakMap.get",
      "kind": "value",
      "name": "get",
      "signature": "let get: (t<'k, 'v>, 'k) => option<'v>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.WeakMap.has",
      "kind": "value",
      "name": "has",
      "signature": "let has: (t<'k, 'v>, 'k) => bool",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.WeakMap.set",
      "kind": "value",
      "name": "set",
      "signature": "let set: (t<'k, 'v>, 'k, 'v) => t<'k, 'v>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.WeakMap.delete",
      "kind": "value",
      "name": "delete",
      "signature": "let delete: (t<'k, 'v>, 'k) => bool",
      "docstrings": []
    }]
  }, 
  {
    "id": "RescriptCore.Set",
    "kind": "moduleAlias",
    "name": "Set",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Set.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'a> = Js.Set.t<'a>",
      "docstrings": ["Type representing an instance of `Set`."]
    }, 
    {
      "id": "RescriptCore.Set.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: unit => t<'a>",
      "docstrings": ["Creates a new, mutable JavaScript `Set`. A `Set` is a collection of unique values.\n\nSee [`Set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) on MDN.\n\n\n\n## Examples\n```rescript\n// You can annotate the type of your set if you want to\nlet mySet: Set.t<string> = Set.make()\n\n// Or you can let ReScript infer what's in your Set\nlet set = Set.make()\nset->Set.add(\"Fine name\") // Inferred as Set.t<string>\n```\n\n## Alternatives\nA JavaScript `Set` is mutable. If you're looking for an immutable alternative, check out `Belt.Set`."]
    }, 
    {
      "id": "RescriptCore.Set.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: array<'a> => t<'a>",
      "docstrings": ["Turns an array of values into a Set. Meaning only unique values are preserved.\n\n## Examples\n```rescript\ntype languages = ReScript | JavaScript | TypeScript\nlet languageRank = [ReScript, JavaScript, TypeScript]\n\nlet set = Set.fromArray(languageRank) // Set.t<languages>\n\nswitch set->Set.has(ReScript) {\n| true => Console.log(\"Yay, ReScript is in there!\")\n| false => Console.log(\"Uh-oh, something is _terribly_ wrong with this program... abort.\")\n}\n```"]
    }, 
    {
      "id": "RescriptCore.Set.fromIterator",
      "kind": "value",
      "name": "fromIterator",
      "signature": "let fromIterator: Core__Iterator.t<'a> => t<'a>",
      "docstrings": ["Turns an iterator into a `Set`.\n\n## Examples\n```rescript\n// Let's pretend we have an interator\n@val external someIterator: Iterator.t<int> = \"someIterator\"\n\nlet set = Set.fromIterator(someIterator) // Set.t<int>\n```"]
    }, 
    {
      "id": "RescriptCore.Set.size",
      "kind": "value",
      "name": "size",
      "signature": "let size: t<'a> => int",
      "docstrings": ["Returns the size, the number of unique values, of the set.\n\n## Examples\n```rescript\nlet set = Set.make()\n\nset->Set.add(\"someValue\")\nset->Set.add(\"someValue\")\nset->Set.add(\"someValue2\")\n\nlet size = set->Set.size // 2\n```"]
    }, 
    {
      "id": "RescriptCore.Set.clear",
      "kind": "value",
      "name": "clear",
      "signature": "let clear: t<'a> => unit",
      "docstrings": ["Clears all entries in the set.\n\n## Examples\n```rescript\nlet set = Set.make()\n\nset->Set.add(\"someKey\")\nlet size = set->Set.size // 1\n\nset->Set.clear\nlet size = set->Set.size // 0\n```"]
    }, 
    {
      "id": "RescriptCore.Set.add",
      "kind": "value",
      "name": "add",
      "signature": "let add: (t<'a>, 'a) => unit",
      "docstrings": ["Adds a new value to the set.\n\n## Examples\n```rescript\nlet set = Set.make()\nset->Set.add(\"someValue\")\n```"]
    }, 
    {
      "id": "RescriptCore.Set.delete",
      "kind": "value",
      "name": "delete",
      "signature": "let delete: (t<'a>, 'a) => bool",
      "docstrings": ["Deletes the provided `value` from the set. Returns a `bool` for whether the value existed, and was deleted.\n\n## Examples\n```rescript\nlet set = Set.make()\nset->Set.add(\"someValue\")\nlet didDeleteValue = set->Set.delete(\"someValue\")\nConsole.log(didDeleteValue) // Logs `true` to the console, becuase the set had the value, so it was successfully deleted\n\nlet didDeleteValue = set->Set.delete(\"someNonExistantKey\")\nConsole.log(didDeleteValue) // Logs `false` to the console, becuase the value did not exist in the set\n```"]
    }, 
    {
      "id": "RescriptCore.Set.has",
      "kind": "value",
      "name": "has",
      "signature": "let has: (t<'a>, 'a) => bool",
      "docstrings": ["Checks whether the set has a specific value.\n\n## Examples\n```rescript\nlet set = Set.make()\nset->Set.add(\"someValue\")\n\nswitch set->Set.has(\"someValue\") {\n| false => Console.log(\"Nope, didn't have it.\")\n| true => Console.log(\"Yay, we have the value!\")\n}\n```"]
    }, 
    {
      "id": "RescriptCore.Set.forEach",
      "kind": "value",
      "name": "forEach",
      "signature": "let forEach: (t<'a>, 'a => unit) => unit",
      "docstrings": ["Iterates through all values of the set.\n\n## Examples\n```rescript\nlet set = Set.make()\nset->Set.add(\"someValue\")\nset->Set.add(\"someValue2\")\n\nset->Set.forEach(value => {\n  Console.log(value)\n})\n```"]
    }, 
    {
      "id": "RescriptCore.Set.values",
      "kind": "value",
      "name": "values",
      "signature": "let values: t<'a> => Core__Iterator.t<'a>",
      "docstrings": ["Returns an iterator that holds all values of the set.\n\n## Examples\n```rescript\nlet set = Set.make()\nset->Set.add(\"someValue\")\nset->Set.add(\"anotherValue\")\n\nlet values = set->Set.values\n\n// Logs the first value\nConsole.log(Iterator.next(values).value)\n\n// You can also turn the iterator into an array.\n// Remember that an iterator consumes values. We'll need a fresh values iterator to get an array of all values, since we consumed a value via `next` above already.\nConsole.log(set->Set.values->Iterator.toArray)\n```"]
    }]
  }, 
  {
    "id": "RescriptCore.WeakSet",
    "kind": "moduleAlias",
    "name": "WeakSet",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.WeakSet.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'a> = Js.WeakSet.t<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.WeakSet.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: unit => t<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.WeakSet.add",
      "kind": "value",
      "name": "add",
      "signature": "let add: (t<'a>, 'a) => t<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.WeakSet.delete",
      "kind": "value",
      "name": "delete",
      "signature": "let delete: (t<'a>, 'a) => bool",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.WeakSet.has",
      "kind": "value",
      "name": "has",
      "signature": "let has: (t<'a>, 'a) => bool",
      "docstrings": []
    }]
  }, 
  {
    "id": "RescriptCore.ArrayBuffer",
    "kind": "moduleAlias",
    "name": "ArrayBuffer",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.ArrayBuffer.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = Js.TypedArray2.ArrayBuffer.t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.ArrayBuffer.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: int => t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.ArrayBuffer.byteLength",
      "kind": "value",
      "name": "byteLength",
      "signature": "let byteLength: t => int",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.ArrayBuffer.slice",
      "kind": "value",
      "name": "slice",
      "signature": "let slice: (t, ~start: int, ~end: int) => t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.ArrayBuffer.sliceToEnd",
      "kind": "value",
      "name": "sliceToEnd",
      "signature": "let sliceToEnd: (t, ~start: int) => t",
      "docstrings": []
    }]
  }, 
  {
    "id": "RescriptCore.TypedArray",
    "kind": "moduleAlias",
    "name": "TypedArray",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.TypedArray.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.get",
      "kind": "value",
      "name": "get",
      "signature": "let get: (t<'a>, int) => option<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.set",
      "kind": "value",
      "name": "set",
      "signature": "let set: (t<'a>, int, 'a) => unit",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.buffer",
      "kind": "value",
      "name": "buffer",
      "signature": "let buffer: t<'a> => Core__ArrayBuffer.t",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.byteLength",
      "kind": "value",
      "name": "byteLength",
      "signature": "let byteLength: t<'a> => int",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.byteOffset",
      "kind": "value",
      "name": "byteOffset",
      "signature": "let byteOffset: t<'a> => int",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.setArray",
      "kind": "value",
      "name": "setArray",
      "signature": "let setArray: (t<'a>, array<'a>) => unit",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.setArrayFrom",
      "kind": "value",
      "name": "setArrayFrom",
      "signature": "let setArrayFrom: (t<'a>, array<'a>, int) => unit",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.length",
      "kind": "value",
      "name": "length",
      "signature": "let length: t<'a> => int",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.copyAllWithin",
      "kind": "value",
      "name": "copyAllWithin",
      "signature": "let copyAllWithin: (t<'a>, ~target: int) => array<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.copyWithinToEnd",
      "kind": "value",
      "name": "copyWithinToEnd",
      "signature": "let copyWithinToEnd: (t<'a>, ~target: int, ~start: int) => array<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.copyWithin",
      "kind": "value",
      "name": "copyWithin",
      "signature": "let copyWithin: (t<'a>, ~target: int, ~start: int, ~end: int) => array<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.fillAll",
      "kind": "value",
      "name": "fillAll",
      "signature": "let fillAll: (t<'a>, 'a) => t<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.fillToEnd",
      "kind": "value",
      "name": "fillToEnd",
      "signature": "let fillToEnd: (t<'a>, 'a, ~start: int) => t<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.fill",
      "kind": "value",
      "name": "fill",
      "signature": "let fill: (t<'a>, 'a, ~start: int, ~end: int) => t<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.reverse",
      "kind": "value",
      "name": "reverse",
      "signature": "let reverse: t<'a> => unit",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.toReversed",
      "kind": "value",
      "name": "toReversed",
      "signature": "let toReversed: t<'a> => t<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.sort",
      "kind": "value",
      "name": "sort",
      "signature": "let sort: (t<'a>, ('a, 'a) => Core__Ordering.t) => unit",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.toSorted",
      "kind": "value",
      "name": "toSorted",
      "signature": "let toSorted: (t<'a>, ('a, 'a) => Core__Ordering.t) => t<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.with",
      "kind": "value",
      "name": "with",
      "signature": "let with: (t<'a>, int, 'a) => t<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.includes",
      "kind": "value",
      "name": "includes",
      "signature": "let includes: (t<'a>, 'a) => bool",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.indexOf",
      "kind": "value",
      "name": "indexOf",
      "signature": "let indexOf: (t<'a>, 'a) => int",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.indexOfFrom",
      "kind": "value",
      "name": "indexOfFrom",
      "signature": "let indexOfFrom: (t<'a>, 'a, int) => int",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.joinWith",
      "kind": "value",
      "name": "joinWith",
      "signature": "let joinWith: (t<'a>, string) => string",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.lastIndexOf",
      "kind": "value",
      "name": "lastIndexOf",
      "signature": "let lastIndexOf: (t<'a>, 'a) => int",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.lastIndexOfFrom",
      "kind": "value",
      "name": "lastIndexOfFrom",
      "signature": "let lastIndexOfFrom: (t<'a>, 'a, int) => int",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.slice",
      "kind": "value",
      "name": "slice",
      "signature": "let slice: (t<'a>, ~start: int, ~end: int) => t<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.sliceToEnd",
      "kind": "value",
      "name": "sliceToEnd",
      "signature": "let sliceToEnd: (t<'a>, ~start: int) => t<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.copy",
      "kind": "value",
      "name": "copy",
      "signature": "let copy: t<'a> => t<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.subarray",
      "kind": "value",
      "name": "subarray",
      "signature": "let subarray: (t<'a>, ~start: int, ~end: int) => t<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.subarrayToEnd",
      "kind": "value",
      "name": "subarrayToEnd",
      "signature": "let subarrayToEnd: (t<'a>, ~start: int) => t<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.toString",
      "kind": "value",
      "name": "toString",
      "signature": "let toString: t<'a> => string",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.toLocaleString",
      "kind": "value",
      "name": "toLocaleString",
      "signature": "let toLocaleString: t<'a> => string",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.every",
      "kind": "value",
      "name": "every",
      "signature": "let every: (t<'a>, 'a => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.everyWithIndex",
      "kind": "value",
      "name": "everyWithIndex",
      "signature": "let everyWithIndex: (t<'a>, ('a, int) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.filter",
      "kind": "value",
      "name": "filter",
      "signature": "let filter: (t<'a>, 'a => bool) => t<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.filterWithIndex",
      "kind": "value",
      "name": "filterWithIndex",
      "signature": "let filterWithIndex: (t<'a>, ('a, int) => bool) => t<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.find",
      "kind": "value",
      "name": "find",
      "signature": "let find: (t<'a>, 'a => bool) => option<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.findWithIndex",
      "kind": "value",
      "name": "findWithIndex",
      "signature": "let findWithIndex: (t<'a>, ('a, int) => bool) => option<'a>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.findIndex",
      "kind": "value",
      "name": "findIndex",
      "signature": "let findIndex: (t<'a>, 'a => bool) => int",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.findIndexWithIndex",
      "kind": "value",
      "name": "findIndexWithIndex",
      "signature": "let findIndexWithIndex: (t<'a>, ('a, int) => bool) => int",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.forEach",
      "kind": "value",
      "name": "forEach",
      "signature": "let forEach: (t<'a>, 'a => unit) => unit",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.forEachWithIndex",
      "kind": "value",
      "name": "forEachWithIndex",
      "signature": "let forEachWithIndex: (t<'a>, ('a, int) => unit) => unit",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.map",
      "kind": "value",
      "name": "map",
      "signature": "let map: (t<'a>, 'a => 'b) => t<'b>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.mapWithIndex",
      "kind": "value",
      "name": "mapWithIndex",
      "signature": "let mapWithIndex: (t<'a>, ('a, int) => 'b) => t<'b>",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.reduce",
      "kind": "value",
      "name": "reduce",
      "signature": "let reduce: (t<'a>, ('b, 'a) => 'b, 'b) => 'b",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.reduceWithIndex",
      "kind": "value",
      "name": "reduceWithIndex",
      "signature": "let reduceWithIndex: (t<'a>, ('b, 'a, int) => 'b, 'b) => 'b",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.reduceRight",
      "kind": "value",
      "name": "reduceRight",
      "signature": "let reduceRight: (t<'a>, ('b, 'a) => 'b, 'b) => 'b",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.reduceRightWithIndex",
      "kind": "value",
      "name": "reduceRightWithIndex",
      "signature": "let reduceRightWithIndex: (t<'a>, ('b, 'a, int) => 'b, 'b) => 'b",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.some",
      "kind": "value",
      "name": "some",
      "signature": "let some: (t<'a>, 'a => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.TypedArray.someWithIndex",
      "kind": "value",
      "name": "someWithIndex",
      "signature": "let someWithIndex: (t<'a>, ('a, int) => bool) => bool",
      "docstrings": []
    }]
  }, 
  {
    "id": "RescriptCore.Float32Array",
    "kind": "moduleAlias",
    "name": "Float32Array",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Float32Array.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = Core__TypedArray.t<float>",
      "docstrings": ["The `Float32Array` typed array represents an array of 32-bit floating point numbers in platform byte order. See [Float32Array on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array)"]
    }, 
    {
      "id": "RescriptCore.Float32Array.Constants",
      "name": "Constants",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.Float32Array.Constants.bytesPerElement",
        "kind": "value",
        "name": "bytesPerElement",
        "signature": "let bytesPerElement: int",
        "docstrings": ["`bytesPerElement` returns the element size. See [BYTES_PER_ELEMENT on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT)"]
      }]
    }, 
    {
      "id": "RescriptCore.Float32Array.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: array<float> => t",
      "docstrings": ["`fromArray` creates a `Float32Array` from an array of values. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array/Float32Array)"]
    }, 
    {
      "id": "RescriptCore.Float32Array.fromBuffer",
      "kind": "value",
      "name": "fromBuffer",
      "signature": "let fromBuffer: Core__ArrayBuffer.t => t",
      "docstrings": ["`fromBuffer` creates a `Float32Array` from an `ArrayBuffer.t`. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array/Float32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Float32Array.fromBufferToEnd",
      "kind": "value",
      "name": "fromBufferToEnd",
      "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t",
      "docstrings": ["`fromBufferToEnd` creates a `Float32Array` from an `ArrayBuffer.t`, starting at a particular offset and continuing through to the end. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array/Float32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Float32Array.fromBufferWithRange",
      "kind": "value",
      "name": "fromBufferWithRange",
      "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t",
      "docstrings": ["`fromBufferWithRange` creates a `Float32Array` from an `ArrayBuffer.t`, starting at a particular offset and consuming `length` **bytes**. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array/Float32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Float32Array.fromLength",
      "kind": "value",
      "name": "fromLength",
      "signature": "let fromLength: int => t",
      "docstrings": ["`fromLength` creates a zero-initialized `Float32Array` to hold the specified count of numbers; this is **not** a byte length. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array/Float32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Float32Array.fromArrayLikeOrIterable",
      "kind": "value",
      "name": "fromArrayLikeOrIterable",
      "signature": "let fromArrayLikeOrIterable: 'a => t",
      "docstrings": ["`fromArrayLikeOrIterable` creates a `Float32Array` from an array-like or iterable object. See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"]
    }, 
    {
      "id": "RescriptCore.Float32Array.fromArrayLikeOrIterableWithMap",
      "kind": "value",
      "name": "fromArrayLikeOrIterableWithMap",
      "signature": "let fromArrayLikeOrIterableWithMap: ('a, ('b, int) => float) => t",
      "docstrings": ["`fromArrayLikeOrIterableWithMap` creates a `Float32Array` from an array-like or iterable object and applies the mapping function to each item. The mapping function expects (value, index). See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"]
    }]
  }, 
  {
    "id": "RescriptCore.Float64Array",
    "kind": "moduleAlias",
    "name": "Float64Array",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Float64Array.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = Core__TypedArray.t<float>",
      "docstrings": ["The `Float64Array` typed array represents an array of 64-bit floating point numbers in platform byte order. See [Float64Array on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array)"]
    }, 
    {
      "id": "RescriptCore.Float64Array.Constants",
      "name": "Constants",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.Float64Array.Constants.bytesPerElement",
        "kind": "value",
        "name": "bytesPerElement",
        "signature": "let bytesPerElement: int",
        "docstrings": ["`bytesPerElement` returns the element size. See [BYTES_PER_ELEMENT on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT)"]
      }]
    }, 
    {
      "id": "RescriptCore.Float64Array.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: array<float> => t",
      "docstrings": ["`fromArray` creates a `Float64Array` from an array of values. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array/Float64Array)"]
    }, 
    {
      "id": "RescriptCore.Float64Array.fromBuffer",
      "kind": "value",
      "name": "fromBuffer",
      "signature": "let fromBuffer: Core__ArrayBuffer.t => t",
      "docstrings": ["`fromBuffer` creates a `Float64Array` from an `ArrayBuffer.t`. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array/Float64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Float64Array.fromBufferToEnd",
      "kind": "value",
      "name": "fromBufferToEnd",
      "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t",
      "docstrings": ["`fromBufferToEnd` creates a `Float64Array` from an `ArrayBuffer.t`, starting at a particular offset and continuing through to the end. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array/Float64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Float64Array.fromBufferWithRange",
      "kind": "value",
      "name": "fromBufferWithRange",
      "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t",
      "docstrings": ["`fromBufferWithRange` creates a `Float64Array` from an `ArrayBuffer.t`, starting at a particular offset and consuming `length` **bytes**. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array/Float64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Float64Array.fromLength",
      "kind": "value",
      "name": "fromLength",
      "signature": "let fromLength: int => t",
      "docstrings": ["`fromLength` creates a zero-initialized `Float64Array` to hold the specified count of numbers; this is **not** a byte length. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array/Float64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Float64Array.fromArrayLikeOrIterable",
      "kind": "value",
      "name": "fromArrayLikeOrIterable",
      "signature": "let fromArrayLikeOrIterable: 'a => t",
      "docstrings": ["`fromArrayLikeOrIterable` creates a `Float64Array` from an array-like or iterable object. See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"]
    }, 
    {
      "id": "RescriptCore.Float64Array.fromArrayLikeOrIterableWithMap",
      "kind": "value",
      "name": "fromArrayLikeOrIterableWithMap",
      "signature": "let fromArrayLikeOrIterableWithMap: ('a, ('b, int) => float) => t",
      "docstrings": ["`fromArrayLikeOrIterableWithMap` creates a `Float64Array` from an array-like or iterable object and applies the mapping function to each item. The mapping function expects (value, index). See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"]
    }]
  }, 
  {
    "id": "RescriptCore.Int8Array",
    "kind": "moduleAlias",
    "name": "Int8Array",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Int8Array.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = Core__TypedArray.t<int>",
      "docstrings": ["The `Int8Array` typed array represents an array of twos-complement 8-bit signed integers. See [Int8Array on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array)"]
    }, 
    {
      "id": "RescriptCore.Int8Array.Constants",
      "name": "Constants",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.Int8Array.Constants.bytesPerElement",
        "kind": "value",
        "name": "bytesPerElement",
        "signature": "let bytesPerElement: int",
        "docstrings": ["`bytesPerElement` returns the element size. See [BYTES_PER_ELEMENT on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT)"]
      }]
    }, 
    {
      "id": "RescriptCore.Int8Array.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: array<int> => t",
      "docstrings": ["`fromArray` creates a `Int8Array` from an array of values. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array/Int8Array)"]
    }, 
    {
      "id": "RescriptCore.Int8Array.fromBuffer",
      "kind": "value",
      "name": "fromBuffer",
      "signature": "let fromBuffer: Core__ArrayBuffer.t => t",
      "docstrings": ["`fromBuffer` creates a `Int8Array` from an `ArrayBuffer.t`. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array/Int8Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Int8Array.fromBufferToEnd",
      "kind": "value",
      "name": "fromBufferToEnd",
      "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t",
      "docstrings": ["`fromBufferToEnd` creates a `Int8Array` from an `ArrayBuffer.t`, starting at a particular offset and continuing through to the end. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array/Int8Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Int8Array.fromBufferWithRange",
      "kind": "value",
      "name": "fromBufferWithRange",
      "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t",
      "docstrings": ["`fromBufferWithRange` creates a `Int8Array` from an `ArrayBuffer.t`, starting at a particular offset and consuming `length` **bytes**. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array/Int8Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Int8Array.fromLength",
      "kind": "value",
      "name": "fromLength",
      "signature": "let fromLength: int => t",
      "docstrings": ["`fromLength` creates a zero-initialized `Int8Array` to hold the specified count of numbers; this is **not** a byte length. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array/Int8Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Int8Array.fromArrayLikeOrIterable",
      "kind": "value",
      "name": "fromArrayLikeOrIterable",
      "signature": "let fromArrayLikeOrIterable: 'a => t",
      "docstrings": ["`fromArrayLikeOrIterable` creates a `Int8Array` from an array-like or iterable object. See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"]
    }, 
    {
      "id": "RescriptCore.Int8Array.fromArrayLikeOrIterableWithMap",
      "kind": "value",
      "name": "fromArrayLikeOrIterableWithMap",
      "signature": "let fromArrayLikeOrIterableWithMap: ('a, ('b, int) => int) => t",
      "docstrings": ["`fromArrayLikeOrIterableWithMap` creates a `Int8Array` from an array-like or iterable object and applies the mapping function to each item. The mapping function expects (value, index). See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"]
    }]
  }, 
  {
    "id": "RescriptCore.Int16Array",
    "kind": "moduleAlias",
    "name": "Int16Array",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Int16Array.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = Core__TypedArray.t<int>",
      "docstrings": ["The `Int16Array` typed array represents an array of twos-complement 16-bit signed integers in platform byte order. See [Int16Array on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array)"]
    }, 
    {
      "id": "RescriptCore.Int16Array.Constants",
      "name": "Constants",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.Int16Array.Constants.bytesPerElement",
        "kind": "value",
        "name": "bytesPerElement",
        "signature": "let bytesPerElement: int",
        "docstrings": ["`bytesPerElement` returns the element size. See [BYTES_PER_ELEMENT on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT)"]
      }]
    }, 
    {
      "id": "RescriptCore.Int16Array.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: array<int> => t",
      "docstrings": ["`fromArray` creates a `Int16Array` from an array of values. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array/Int16Array)"]
    }, 
    {
      "id": "RescriptCore.Int16Array.fromBuffer",
      "kind": "value",
      "name": "fromBuffer",
      "signature": "let fromBuffer: Core__ArrayBuffer.t => t",
      "docstrings": ["`fromBuffer` creates a `Int16Array` from an `ArrayBuffer.t`. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array/Int16Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Int16Array.fromBufferToEnd",
      "kind": "value",
      "name": "fromBufferToEnd",
      "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t",
      "docstrings": ["`fromBufferToEnd` creates a `Int16Array` from an `ArrayBuffer.t`, starting at a particular offset and continuing through to the end. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array/Int16Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Int16Array.fromBufferWithRange",
      "kind": "value",
      "name": "fromBufferWithRange",
      "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t",
      "docstrings": ["`fromBufferWithRange` creates a `Int16Array` from an `ArrayBuffer.t`, starting at a particular offset and consuming `length` **bytes**. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array/Int16Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Int16Array.fromLength",
      "kind": "value",
      "name": "fromLength",
      "signature": "let fromLength: int => t",
      "docstrings": ["`fromLength` creates a zero-initialized `Int16Array` to hold the specified count of numbers; this is **not** a byte length. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array/Int16Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Int16Array.fromArrayLikeOrIterable",
      "kind": "value",
      "name": "fromArrayLikeOrIterable",
      "signature": "let fromArrayLikeOrIterable: 'a => t",
      "docstrings": ["`fromArrayLikeOrIterable` creates a `Int16Array` from an array-like or iterable object. See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"]
    }, 
    {
      "id": "RescriptCore.Int16Array.fromArrayLikeOrIterableWithMap",
      "kind": "value",
      "name": "fromArrayLikeOrIterableWithMap",
      "signature": "let fromArrayLikeOrIterableWithMap: ('a, ('b, int) => int) => t",
      "docstrings": ["`fromArrayLikeOrIterableWithMap` creates a `Int16Array` from an array-like or iterable object and applies the mapping function to each item. The mapping function expects (value, index). See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"]
    }]
  }, 
  {
    "id": "RescriptCore.Int32Array",
    "kind": "moduleAlias",
    "name": "Int32Array",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Int32Array.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = Core__TypedArray.t<int>",
      "docstrings": ["The `Int32Array` typed array represents an array of twos-complemenet 32-bit signed integers in platform byte order. See [Int32Array on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array)"]
    }, 
    {
      "id": "RescriptCore.Int32Array.Constants",
      "name": "Constants",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.Int32Array.Constants.bytesPerElement",
        "kind": "value",
        "name": "bytesPerElement",
        "signature": "let bytesPerElement: int",
        "docstrings": ["`bytesPerElement` returns the element size. See [BYTES_PER_ELEMENT on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT)"]
      }]
    }, 
    {
      "id": "RescriptCore.Int32Array.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: array<int> => t",
      "docstrings": ["`fromArray` creates a `Int32Array` from an array of values. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array/Int32Array)"]
    }, 
    {
      "id": "RescriptCore.Int32Array.fromBuffer",
      "kind": "value",
      "name": "fromBuffer",
      "signature": "let fromBuffer: Core__ArrayBuffer.t => t",
      "docstrings": ["`fromBuffer` creates a `Int32Array` from an `ArrayBuffer.t`. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array/Int32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Int32Array.fromBufferToEnd",
      "kind": "value",
      "name": "fromBufferToEnd",
      "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t",
      "docstrings": ["`fromBufferToEnd` creates a `Int32Array` from an `ArrayBuffer.t`, starting at a particular offset and continuing through to the end. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array/Int32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Int32Array.fromBufferWithRange",
      "kind": "value",
      "name": "fromBufferWithRange",
      "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t",
      "docstrings": ["`fromBufferWithRange` creates a `Int32Array` from an `ArrayBuffer.t`, starting at a particular offset and consuming `length` **bytes**. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array/Int32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Int32Array.fromLength",
      "kind": "value",
      "name": "fromLength",
      "signature": "let fromLength: int => t",
      "docstrings": ["`fromLength` creates a zero-initialized `Int32Array` to hold the specified count of numbers; this is **not** a byte length. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array/Int32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Int32Array.fromArrayLikeOrIterable",
      "kind": "value",
      "name": "fromArrayLikeOrIterable",
      "signature": "let fromArrayLikeOrIterable: 'a => t",
      "docstrings": ["`fromArrayLikeOrIterable` creates a `Int32Array` from an array-like or iterable object. See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"]
    }, 
    {
      "id": "RescriptCore.Int32Array.fromArrayLikeOrIterableWithMap",
      "kind": "value",
      "name": "fromArrayLikeOrIterableWithMap",
      "signature": "let fromArrayLikeOrIterableWithMap: ('a, ('b, int) => int) => t",
      "docstrings": ["`fromArrayLikeOrIterableWithMap` creates a `Int32Array` from an array-like or iterable object and applies the mapping function to each item. The mapping function expects (value, index). See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"]
    }]
  }, 
  {
    "id": "RescriptCore.Uint8Array",
    "kind": "moduleAlias",
    "name": "Uint8Array",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Uint8Array.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = Core__TypedArray.t<int>",
      "docstrings": ["The `Uint8Array` typed array represents an array of 8-bit unsigned integers. See [Uint8Array on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)"]
    }, 
    {
      "id": "RescriptCore.Uint8Array.Constants",
      "name": "Constants",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.Uint8Array.Constants.bytesPerElement",
        "kind": "value",
        "name": "bytesPerElement",
        "signature": "let bytesPerElement: int",
        "docstrings": ["`bytesPerElement` returns the element size. See [BYTES_PER_ELEMENT on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT)"]
      }]
    }, 
    {
      "id": "RescriptCore.Uint8Array.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: array<int> => t",
      "docstrings": ["`fromArray` creates a `Uint8Array` from an array of values. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array/Uint8Array)"]
    }, 
    {
      "id": "RescriptCore.Uint8Array.fromBuffer",
      "kind": "value",
      "name": "fromBuffer",
      "signature": "let fromBuffer: Core__ArrayBuffer.t => t",
      "docstrings": ["`fromBuffer` creates a `Uint8Array` from an `ArrayBuffer.t`. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array/Uint8Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Uint8Array.fromBufferToEnd",
      "kind": "value",
      "name": "fromBufferToEnd",
      "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t",
      "docstrings": ["`fromBufferToEnd` creates a `Uint8Array` from an `ArrayBuffer.t`, starting at a particular offset and continuing through to the end. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array/Uint8Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Uint8Array.fromBufferWithRange",
      "kind": "value",
      "name": "fromBufferWithRange",
      "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t",
      "docstrings": ["`fromBufferWithRange` creates a `Uint8Array` from an `ArrayBuffer.t`, starting at a particular offset and consuming `length` **bytes**. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array/Uint8Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Uint8Array.fromLength",
      "kind": "value",
      "name": "fromLength",
      "signature": "let fromLength: int => t",
      "docstrings": ["`fromLength` creates a zero-initialized `Uint8Array` to hold the specified count of numbers; this is **not** a byte length. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array/Uint8Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Uint8Array.fromArrayLikeOrIterable",
      "kind": "value",
      "name": "fromArrayLikeOrIterable",
      "signature": "let fromArrayLikeOrIterable: 'a => t",
      "docstrings": ["`fromArrayLikeOrIterable` creates a `Uint8Array` from an array-like or iterable object. See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"]
    }, 
    {
      "id": "RescriptCore.Uint8Array.fromArrayLikeOrIterableWithMap",
      "kind": "value",
      "name": "fromArrayLikeOrIterableWithMap",
      "signature": "let fromArrayLikeOrIterableWithMap: ('a, ('b, int) => int) => t",
      "docstrings": ["`fromArrayLikeOrIterableWithMap` creates a `Uint8Array` from an array-like or iterable object and applies the mapping function to each item. The mapping function expects (value, index). See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"]
    }]
  }, 
  {
    "id": "RescriptCore.Uint16Array",
    "kind": "moduleAlias",
    "name": "Uint16Array",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Uint16Array.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = Core__TypedArray.t<int>",
      "docstrings": ["The `Uint16Array` typed array represents an array of 16-bit unsigned integers in platform byte order. See [Uint16Array on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array)"]
    }, 
    {
      "id": "RescriptCore.Uint16Array.Constants",
      "name": "Constants",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.Uint16Array.Constants.bytesPerElement",
        "kind": "value",
        "name": "bytesPerElement",
        "signature": "let bytesPerElement: int",
        "docstrings": ["`bytesPerElement` returns the element size. See [BYTES_PER_ELEMENT on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT)"]
      }]
    }, 
    {
      "id": "RescriptCore.Uint16Array.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: array<int> => t",
      "docstrings": ["`fromArray` creates a `Uint16Array` from an array of values. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array/Uint16Array)"]
    }, 
    {
      "id": "RescriptCore.Uint16Array.fromBuffer",
      "kind": "value",
      "name": "fromBuffer",
      "signature": "let fromBuffer: Core__ArrayBuffer.t => t",
      "docstrings": ["`fromBuffer` creates a `Uint16Array` from an `ArrayBuffer.t`. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array/Uint16Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Uint16Array.fromBufferToEnd",
      "kind": "value",
      "name": "fromBufferToEnd",
      "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t",
      "docstrings": ["`fromBufferToEnd` creates a `Uint16Array` from an `ArrayBuffer.t`, starting at a particular offset and continuing through to the end. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array/Uint16Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Uint16Array.fromBufferWithRange",
      "kind": "value",
      "name": "fromBufferWithRange",
      "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t",
      "docstrings": ["`fromBufferWithRange` creates a `Uint16Array` from an `ArrayBuffer.t`, starting at a particular offset and consuming `length` **bytes**. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array/Uint16Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Uint16Array.fromLength",
      "kind": "value",
      "name": "fromLength",
      "signature": "let fromLength: int => t",
      "docstrings": ["`fromLength` creates a zero-initialized `Uint16Array` to hold the specified count of numbers; this is **not** a byte length. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array/Uint16Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Uint16Array.fromArrayLikeOrIterable",
      "kind": "value",
      "name": "fromArrayLikeOrIterable",
      "signature": "let fromArrayLikeOrIterable: 'a => t",
      "docstrings": ["`fromArrayLikeOrIterable` creates a `Uint16Array` from an array-like or iterable object. See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"]
    }, 
    {
      "id": "RescriptCore.Uint16Array.fromArrayLikeOrIterableWithMap",
      "kind": "value",
      "name": "fromArrayLikeOrIterableWithMap",
      "signature": "let fromArrayLikeOrIterableWithMap: ('a, ('b, int) => int) => t",
      "docstrings": ["`fromArrayLikeOrIterableWithMap` creates a `Uint16Array` from an array-like or iterable object and applies the mapping function to each item. The mapping function expects (value, index). See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"]
    }]
  }, 
  {
    "id": "RescriptCore.Uint32Array",
    "kind": "moduleAlias",
    "name": "Uint32Array",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Uint32Array.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = Core__TypedArray.t<int>",
      "docstrings": ["The `Uint32Array` typed array represents an array of 32-bit unsigned integers in platform byte order. See [Uint32Array on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array)"]
    }, 
    {
      "id": "RescriptCore.Uint32Array.Constants",
      "name": "Constants",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.Uint32Array.Constants.bytesPerElement",
        "kind": "value",
        "name": "bytesPerElement",
        "signature": "let bytesPerElement: int",
        "docstrings": ["`bytesPerElement` returns the element size. See [BYTES_PER_ELEMENT on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT)"]
      }]
    }, 
    {
      "id": "RescriptCore.Uint32Array.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: array<int> => t",
      "docstrings": ["`fromArray` creates a `Uint32Array` from an array of values. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array/Uint32Array)"]
    }, 
    {
      "id": "RescriptCore.Uint32Array.fromBuffer",
      "kind": "value",
      "name": "fromBuffer",
      "signature": "let fromBuffer: Core__ArrayBuffer.t => t",
      "docstrings": ["`fromBuffer` creates a `Uint32Array` from an `ArrayBuffer.t`. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array/Uint32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Uint32Array.fromBufferToEnd",
      "kind": "value",
      "name": "fromBufferToEnd",
      "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t",
      "docstrings": ["`fromBufferToEnd` creates a `Uint32Array` from an `ArrayBuffer.t`, starting at a particular offset and continuing through to the end. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array/Uint32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Uint32Array.fromBufferWithRange",
      "kind": "value",
      "name": "fromBufferWithRange",
      "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t",
      "docstrings": ["`fromBufferWithRange` creates a `Uint32Array` from an `ArrayBuffer.t`, starting at a particular offset and consuming `length` **bytes**. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array/Uint32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Uint32Array.fromLength",
      "kind": "value",
      "name": "fromLength",
      "signature": "let fromLength: int => t",
      "docstrings": ["`fromLength` creates a zero-initialized `Uint32Array` to hold the specified count of numbers; this is **not** a byte length. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array/Uint32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Uint32Array.fromArrayLikeOrIterable",
      "kind": "value",
      "name": "fromArrayLikeOrIterable",
      "signature": "let fromArrayLikeOrIterable: 'a => t",
      "docstrings": ["`fromArrayLikeOrIterable` creates a `Uint32Array` from an array-like or iterable object. See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"]
    }, 
    {
      "id": "RescriptCore.Uint32Array.fromArrayLikeOrIterableWithMap",
      "kind": "value",
      "name": "fromArrayLikeOrIterableWithMap",
      "signature": "let fromArrayLikeOrIterableWithMap: ('a, ('b, int) => int) => t",
      "docstrings": ["`fromArrayLikeOrIterableWithMap` creates a `Uint32Array` from an array-like or iterable object and applies the mapping function to each item. The mapping function expects (value, index). See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"]
    }]
  }, 
  {
    "id": "RescriptCore.Uint8ClampedArray",
    "kind": "moduleAlias",
    "name": "Uint8ClampedArray",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Uint8ClampedArray.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = Core__TypedArray.t<int>",
      "docstrings": ["The `Uint8ClampedArray` typed array represents an array of 8-bit unsigned integers clamped to 0-255. See [Uint8ClampedArray on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray)"]
    }, 
    {
      "id": "RescriptCore.Uint8ClampedArray.Constants",
      "name": "Constants",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.Uint8ClampedArray.Constants.bytesPerElement",
        "kind": "value",
        "name": "bytesPerElement",
        "signature": "let bytesPerElement: int",
        "docstrings": ["`bytesPerElement` returns the element size. See [BYTES_PER_ELEMENT on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT)"]
      }]
    }, 
    {
      "id": "RescriptCore.Uint8ClampedArray.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: array<int> => t",
      "docstrings": ["`fromArray` creates a `Uint8ClampedArray` from an array of values. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray/Uint8ClampedArray)"]
    }, 
    {
      "id": "RescriptCore.Uint8ClampedArray.fromBuffer",
      "kind": "value",
      "name": "fromBuffer",
      "signature": "let fromBuffer: Core__ArrayBuffer.t => t",
      "docstrings": ["`fromBuffer` creates a `Uint8ClampedArray` from an `ArrayBuffer.t`. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray/Uint8ClampedArray)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Uint8ClampedArray.fromBufferToEnd",
      "kind": "value",
      "name": "fromBufferToEnd",
      "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t",
      "docstrings": ["`fromBufferToEnd` creates a `Uint8ClampedArray` from an `ArrayBuffer.t`, starting at a particular offset and continuing through to the end. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray/Uint8ClampedArray)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Uint8ClampedArray.fromBufferWithRange",
      "kind": "value",
      "name": "fromBufferWithRange",
      "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t",
      "docstrings": ["`fromBufferWithRange` creates a `Uint8ClampedArray` from an `ArrayBuffer.t`, starting at a particular offset and consuming `length` **bytes**. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray/Uint8ClampedArray)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Uint8ClampedArray.fromLength",
      "kind": "value",
      "name": "fromLength",
      "signature": "let fromLength: int => t",
      "docstrings": ["`fromLength` creates a zero-initialized `Uint8ClampedArray` to hold the specified count of numbers; this is **not** a byte length. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray/Uint8ClampedArray)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.Uint8ClampedArray.fromArrayLikeOrIterable",
      "kind": "value",
      "name": "fromArrayLikeOrIterable",
      "signature": "let fromArrayLikeOrIterable: 'a => t",
      "docstrings": ["`fromArrayLikeOrIterable` creates a `Uint8ClampedArray` from an array-like or iterable object. See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"]
    }, 
    {
      "id": "RescriptCore.Uint8ClampedArray.fromArrayLikeOrIterableWithMap",
      "kind": "value",
      "name": "fromArrayLikeOrIterableWithMap",
      "signature": "let fromArrayLikeOrIterableWithMap: ('a, ('b, int) => int) => t",
      "docstrings": ["`fromArrayLikeOrIterableWithMap` creates a `Uint8ClampedArray` from an array-like or iterable object and applies the mapping function to each item. The mapping function expects (value, index). See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"]
    }]
  }, 
  {
    "id": "RescriptCore.BigInt64Array",
    "kind": "moduleAlias",
    "name": "BigInt64Array",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.BigInt64Array.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = Core__TypedArray.t<Core__BigInt.t>",
      "docstrings": ["The `BigInt64Array` typed array represents an array of 64-bit signed integers in platform byte order. See [BigInt64Array on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt64Array)"]
    }, 
    {
      "id": "RescriptCore.BigInt64Array.Constants",
      "name": "Constants",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.BigInt64Array.Constants.bytesPerElement",
        "kind": "value",
        "name": "bytesPerElement",
        "signature": "let bytesPerElement: int",
        "docstrings": ["`bytesPerElement` returns the element size. See [BYTES_PER_ELEMENT on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT)"]
      }]
    }, 
    {
      "id": "RescriptCore.BigInt64Array.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: array<Core__BigInt.t> => t",
      "docstrings": ["`fromArray` creates a `BigInt64Array` from an array of values. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt64Array/BigInt64Array)"]
    }, 
    {
      "id": "RescriptCore.BigInt64Array.fromBuffer",
      "kind": "value",
      "name": "fromBuffer",
      "signature": "let fromBuffer: Core__ArrayBuffer.t => t",
      "docstrings": ["`fromBuffer` creates a `BigInt64Array` from an `ArrayBuffer.t`. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt64Array/BigInt64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.BigInt64Array.fromBufferToEnd",
      "kind": "value",
      "name": "fromBufferToEnd",
      "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t",
      "docstrings": ["`fromBufferToEnd` creates a `BigInt64Array` from an `ArrayBuffer.t`, starting at a particular offset and continuing through to the end. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt64Array/BigInt64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.BigInt64Array.fromBufferWithRange",
      "kind": "value",
      "name": "fromBufferWithRange",
      "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t",
      "docstrings": ["`fromBufferWithRange` creates a `BigInt64Array` from an `ArrayBuffer.t`, starting at a particular offset and consuming `length` **bytes**. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt64Array/BigInt64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.BigInt64Array.fromLength",
      "kind": "value",
      "name": "fromLength",
      "signature": "let fromLength: int => t",
      "docstrings": ["`fromLength` creates a zero-initialized `BigInt64Array` to hold the specified count of numbers; this is **not** a byte length. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt64Array/BigInt64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.BigInt64Array.fromArrayLikeOrIterable",
      "kind": "value",
      "name": "fromArrayLikeOrIterable",
      "signature": "let fromArrayLikeOrIterable: 'a => t",
      "docstrings": ["`fromArrayLikeOrIterable` creates a `BigInt64Array` from an array-like or iterable object. See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"]
    }, 
    {
      "id": "RescriptCore.BigInt64Array.fromArrayLikeOrIterableWithMap",
      "kind": "value",
      "name": "fromArrayLikeOrIterableWithMap",
      "signature": "let fromArrayLikeOrIterableWithMap: ('a, ('b, int) => Core__BigInt.t) => t",
      "docstrings": ["`fromArrayLikeOrIterableWithMap` creates a `BigInt64Array` from an array-like or iterable object and applies the mapping function to each item. The mapping function expects (value, index). See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"]
    }]
  }, 
  {
    "id": "RescriptCore.BigUint64Array",
    "kind": "moduleAlias",
    "name": "BigUint64Array",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.BigUint64Array.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = Core__TypedArray.t<Core__BigInt.t>",
      "docstrings": ["The `BigUint64Array` typed array represents an array of 64-bit unsigned integers in platform byte order. See [BigUint64Array on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigUint64Array)"]
    }, 
    {
      "id": "RescriptCore.BigUint64Array.Constants",
      "name": "Constants",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.BigUint64Array.Constants.bytesPerElement",
        "kind": "value",
        "name": "bytesPerElement",
        "signature": "let bytesPerElement: int",
        "docstrings": ["`bytesPerElement` returns the element size. See [BYTES_PER_ELEMENT on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT)"]
      }]
    }, 
    {
      "id": "RescriptCore.BigUint64Array.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: array<Core__BigInt.t> => t",
      "docstrings": ["`fromArray` creates a `BigUint64Array` from an array of values. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigUint64Array/BigUint64Array)"]
    }, 
    {
      "id": "RescriptCore.BigUint64Array.fromBuffer",
      "kind": "value",
      "name": "fromBuffer",
      "signature": "let fromBuffer: Core__ArrayBuffer.t => t",
      "docstrings": ["`fromBuffer` creates a `BigUint64Array` from an `ArrayBuffer.t`. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigUint64Array/BigUint64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.BigUint64Array.fromBufferToEnd",
      "kind": "value",
      "name": "fromBufferToEnd",
      "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t",
      "docstrings": ["`fromBufferToEnd` creates a `BigUint64Array` from an `ArrayBuffer.t`, starting at a particular offset and continuing through to the end. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigUint64Array/BigUint64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.BigUint64Array.fromBufferWithRange",
      "kind": "value",
      "name": "fromBufferWithRange",
      "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t",
      "docstrings": ["`fromBufferWithRange` creates a `BigUint64Array` from an `ArrayBuffer.t`, starting at a particular offset and consuming `length` **bytes**. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigUint64Array/BigUint64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.BigUint64Array.fromLength",
      "kind": "value",
      "name": "fromLength",
      "signature": "let fromLength: int => t",
      "docstrings": ["`fromLength` creates a zero-initialized `BigUint64Array` to hold the specified count of numbers; this is **not** a byte length. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigUint64Array/BigUint64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."]
    }, 
    {
      "id": "RescriptCore.BigUint64Array.fromArrayLikeOrIterable",
      "kind": "value",
      "name": "fromArrayLikeOrIterable",
      "signature": "let fromArrayLikeOrIterable: 'a => t",
      "docstrings": ["`fromArrayLikeOrIterable` creates a `BigUint64Array` from an array-like or iterable object. See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"]
    }, 
    {
      "id": "RescriptCore.BigUint64Array.fromArrayLikeOrIterableWithMap",
      "kind": "value",
      "name": "fromArrayLikeOrIterableWithMap",
      "signature": "let fromArrayLikeOrIterableWithMap: ('a, ('b, int) => Core__BigInt.t) => t",
      "docstrings": ["`fromArrayLikeOrIterableWithMap` creates a `BigUint64Array` from an array-like or iterable object and applies the mapping function to each item. The mapping function expects (value, index). See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"]
    }]
  }, 
  {
    "id": "RescriptCore.Intl",
    "kind": "moduleAlias",
    "name": "Intl",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Intl.Collator",
      "kind": "moduleAlias",
      "name": "Collator",
      "docstrings": [],
      "items": [
      {
        "id": "RescriptCore.Intl.Collator.t",
        "kind": "type",
        "name": "t",
        "signature": "type t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Collator.make",
        "kind": "value",
        "name": "make",
        "signature": "let make: unit => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Collator.makeWithLocale",
        "kind": "value",
        "name": "makeWithLocale",
        "signature": "let makeWithLocale: string => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Collator.makeWithLocales",
        "kind": "value",
        "name": "makeWithLocales",
        "signature": "let makeWithLocales: array<string> => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Collator.makeWithLocaleAndOptions",
        "kind": "value",
        "name": "makeWithLocaleAndOptions",
        "signature": "let makeWithLocaleAndOptions: (string, {..}) => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Collator.makeWithLocalesAndOptions",
        "kind": "value",
        "name": "makeWithLocalesAndOptions",
        "signature": "let makeWithLocalesAndOptions: (array<string>, {..}) => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Collator.makeWithOptions",
        "kind": "value",
        "name": "makeWithOptions",
        "signature": "let makeWithOptions: {..} => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Collator.supportedLocalesOf",
        "kind": "value",
        "name": "supportedLocalesOf",
        "signature": "let supportedLocalesOf: array<string> => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Collator.supportedLocalesOfWithOptions",
        "kind": "value",
        "name": "supportedLocalesOfWithOptions",
        "signature": "let supportedLocalesOfWithOptions: (array<string>, {..}) => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Collator.resolvedOptions",
        "kind": "value",
        "name": "resolvedOptions",
        "signature": "let resolvedOptions: t => {..}",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Collator.compare",
        "kind": "value",
        "name": "compare",
        "signature": "let compare: (t, string, string) => int",
        "docstrings": []
      }]
    }, 
    {
      "id": "RescriptCore.Intl.DateTimeFormat",
      "kind": "moduleAlias",
      "name": "DateTimeFormat",
      "docstrings": [],
      "items": [
      {
        "id": "RescriptCore.Intl.DateTimeFormat.t",
        "kind": "type",
        "name": "t",
        "signature": "type t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.DateTimeFormat.make",
        "kind": "value",
        "name": "make",
        "signature": "let make: unit => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.DateTimeFormat.makeWithLocale",
        "kind": "value",
        "name": "makeWithLocale",
        "signature": "let makeWithLocale: string => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.DateTimeFormat.makeWithLocales",
        "kind": "value",
        "name": "makeWithLocales",
        "signature": "let makeWithLocales: array<string> => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.DateTimeFormat.makeWithLocaleAndOptions",
        "kind": "value",
        "name": "makeWithLocaleAndOptions",
        "signature": "let makeWithLocaleAndOptions: (string, {..}) => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.DateTimeFormat.makeWithLocalesAndOptions",
        "kind": "value",
        "name": "makeWithLocalesAndOptions",
        "signature": "let makeWithLocalesAndOptions: (array<string>, {..}) => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.DateTimeFormat.makeWithOptions",
        "kind": "value",
        "name": "makeWithOptions",
        "signature": "let makeWithOptions: {..} => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.DateTimeFormat.supportedLocalesOf",
        "kind": "value",
        "name": "supportedLocalesOf",
        "signature": "let supportedLocalesOf: array<string> => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.DateTimeFormat.supportedLocalesOfWithOptions",
        "kind": "value",
        "name": "supportedLocalesOfWithOptions",
        "signature": "let supportedLocalesOfWithOptions: (array<string>, {..}) => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.DateTimeFormat.resolvedOptions",
        "kind": "value",
        "name": "resolvedOptions",
        "signature": "let resolvedOptions: t => {..}",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.DateTimeFormat.format",
        "kind": "value",
        "name": "format",
        "signature": "let format: (t, Core__Date.t) => string",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.DateTimeFormat.formatToParts",
        "kind": "value",
        "name": "formatToParts",
        "signature": "let formatToParts: (t, Core__Date.t) => array<{\\\"type\\\": string, \\\"value\\\": string}>",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.DateTimeFormat.formatRange",
        "kind": "value",
        "name": "formatRange",
        "signature": "let formatRange: (t, ~startDate: Core__Date.t, ~endDate: Core__Date.t) => string",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.DateTimeFormat.formatRangeToParts",
        "kind": "value",
        "name": "formatRangeToParts",
        "signature": "let formatRangeToParts: (\\n  t,\\n  ~startDate: Core__Date.t,\\n  ~endDate: Core__Date.t,\\n) => array<{\\n  \\\"source\\\": string,\\n  \\\"type\\\": string,\\n  \\\"value\\\": string,\\n}>",
        "docstrings": []
      }]
    }, 
    {
      "id": "RescriptCore.Intl.Locale",
      "kind": "moduleAlias",
      "name": "Locale",
      "docstrings": [],
      "items": [
      {
        "id": "RescriptCore.Intl.Locale.t",
        "kind": "type",
        "name": "t",
        "signature": "type t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Locale.make",
        "kind": "value",
        "name": "make",
        "signature": "let make: string => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Locale.makeWithOptions",
        "kind": "value",
        "name": "makeWithOptions",
        "signature": "let makeWithOptions: (string, {..}) => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Locale.baseName",
        "kind": "value",
        "name": "baseName",
        "signature": "let baseName: t => string",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Locale.calendar",
        "kind": "value",
        "name": "calendar",
        "signature": "let calendar: t => option<string>",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Locale.caseFirst",
        "kind": "value",
        "name": "caseFirst",
        "signature": "let caseFirst: t => option<string>",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Locale.collation",
        "kind": "value",
        "name": "collation",
        "signature": "let collation: t => option<string>",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Locale.hourCycle",
        "kind": "value",
        "name": "hourCycle",
        "signature": "let hourCycle: t => option<string>",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Locale.language",
        "kind": "value",
        "name": "language",
        "signature": "let language: t => string",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Locale.numberingSystem",
        "kind": "value",
        "name": "numberingSystem",
        "signature": "let numberingSystem: t => option<string>",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Locale.numeric",
        "kind": "value",
        "name": "numeric",
        "signature": "let numeric: t => bool",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Locale.region",
        "kind": "value",
        "name": "region",
        "signature": "let region: t => option<string>",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Locale.script",
        "kind": "value",
        "name": "script",
        "signature": "let script: t => option<string>",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Locale.maximize",
        "kind": "value",
        "name": "maximize",
        "signature": "let maximize: t => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.Locale.minimize",
        "kind": "value",
        "name": "minimize",
        "signature": "let minimize: t => t",
        "docstrings": []
      }]
    }, 
    {
      "id": "RescriptCore.Intl.NumberFormat",
      "kind": "moduleAlias",
      "name": "NumberFormat",
      "docstrings": [],
      "items": [
      {
        "id": "RescriptCore.Intl.NumberFormat.t",
        "kind": "type",
        "name": "t",
        "signature": "type t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.NumberFormat.make",
        "kind": "value",
        "name": "make",
        "signature": "let make: unit => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.NumberFormat.makeWithLocale",
        "kind": "value",
        "name": "makeWithLocale",
        "signature": "let makeWithLocale: string => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.NumberFormat.makeWithLocales",
        "kind": "value",
        "name": "makeWithLocales",
        "signature": "let makeWithLocales: array<string> => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.NumberFormat.makeWithLocaleAndOptions",
        "kind": "value",
        "name": "makeWithLocaleAndOptions",
        "signature": "let makeWithLocaleAndOptions: (string, {..}) => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.NumberFormat.makeWithLocalesAndOptions",
        "kind": "value",
        "name": "makeWithLocalesAndOptions",
        "signature": "let makeWithLocalesAndOptions: (array<string>, {..}) => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.NumberFormat.makeWithOptions",
        "kind": "value",
        "name": "makeWithOptions",
        "signature": "let makeWithOptions: {..} => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.NumberFormat.supportedLocalesOf",
        "kind": "value",
        "name": "supportedLocalesOf",
        "signature": "let supportedLocalesOf: array<string> => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.NumberFormat.supportedLocalesOfWithOptions",
        "kind": "value",
        "name": "supportedLocalesOfWithOptions",
        "signature": "let supportedLocalesOfWithOptions: (array<string>, {..}) => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.NumberFormat.resolvedOptions",
        "kind": "value",
        "name": "resolvedOptions",
        "signature": "let resolvedOptions: t => {..}",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.NumberFormat.format",
        "kind": "value",
        "name": "format",
        "signature": "let format: (t, float) => string",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.NumberFormat.formatToParts",
        "kind": "value",
        "name": "formatToParts",
        "signature": "let formatToParts: (t, float) => array<{\\\"type\\\": string, \\\"value\\\": string}>",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.NumberFormat.formatInt",
        "kind": "value",
        "name": "formatInt",
        "signature": "let formatInt: (t, int) => string",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.NumberFormat.formatIntToParts",
        "kind": "value",
        "name": "formatIntToParts",
        "signature": "let formatIntToParts: (t, int) => array<{\\\"type\\\": string, \\\"value\\\": string}>",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.NumberFormat.formatBigInt",
        "kind": "value",
        "name": "formatBigInt",
        "signature": "let formatBigInt: (t, Core__BigInt.t) => string",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.NumberFormat.formatBigIntToParts",
        "kind": "value",
        "name": "formatBigIntToParts",
        "signature": "let formatBigIntToParts: (t, Core__BigInt.t) => array<{\\\"type\\\": string, \\\"value\\\": string}>",
        "docstrings": []
      }]
    }, 
    {
      "id": "RescriptCore.Intl.PluralRules",
      "kind": "moduleAlias",
      "name": "PluralRules",
      "docstrings": [],
      "items": [
      {
        "id": "RescriptCore.Intl.PluralRules.t",
        "kind": "type",
        "name": "t",
        "signature": "type t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.PluralRules.make",
        "kind": "value",
        "name": "make",
        "signature": "let make: unit => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.PluralRules.makeWithLocale",
        "kind": "value",
        "name": "makeWithLocale",
        "signature": "let makeWithLocale: string => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.PluralRules.makeWithLocales",
        "kind": "value",
        "name": "makeWithLocales",
        "signature": "let makeWithLocales: array<string> => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.PluralRules.makeWithLocaleAndOptions",
        "kind": "value",
        "name": "makeWithLocaleAndOptions",
        "signature": "let makeWithLocaleAndOptions: (string, {..}) => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.PluralRules.makeWithLocalesAndOptions",
        "kind": "value",
        "name": "makeWithLocalesAndOptions",
        "signature": "let makeWithLocalesAndOptions: (array<string>, {..}) => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.PluralRules.makeWithOptions",
        "kind": "value",
        "name": "makeWithOptions",
        "signature": "let makeWithOptions: {..} => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.PluralRules.supportedLocalesOf",
        "kind": "value",
        "name": "supportedLocalesOf",
        "signature": "let supportedLocalesOf: array<string> => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.PluralRules.supportedLocalesOfWithOptions",
        "kind": "value",
        "name": "supportedLocalesOfWithOptions",
        "signature": "let supportedLocalesOfWithOptions: (array<string>, {..}) => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.PluralRules.resolvedOptions",
        "kind": "value",
        "name": "resolvedOptions",
        "signature": "let resolvedOptions: t => {..}",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.PluralRules.rule",
        "kind": "type",
        "name": "rule",
        "signature": "type rule = [#few | #many | #one | #other | #two | #zero]",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.PluralRules.select",
        "kind": "value",
        "name": "select",
        "signature": "let select: (t, float) => rule",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.PluralRules.selectInt",
        "kind": "value",
        "name": "selectInt",
        "signature": "let selectInt: (t, int) => rule",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.PluralRules.selectBigInt",
        "kind": "value",
        "name": "selectBigInt",
        "signature": "let selectBigInt: (t, Core__BigInt.t) => rule",
        "docstrings": []
      }]
    }, 
    {
      "id": "RescriptCore.Intl.RelativeTimeFormat",
      "kind": "moduleAlias",
      "name": "RelativeTimeFormat",
      "docstrings": [],
      "items": [
      {
        "id": "RescriptCore.Intl.RelativeTimeFormat.t",
        "kind": "type",
        "name": "t",
        "signature": "type t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.RelativeTimeFormat.make",
        "kind": "value",
        "name": "make",
        "signature": "let make: unit => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.RelativeTimeFormat.makeWithLocale",
        "kind": "value",
        "name": "makeWithLocale",
        "signature": "let makeWithLocale: string => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.RelativeTimeFormat.makeWithLocales",
        "kind": "value",
        "name": "makeWithLocales",
        "signature": "let makeWithLocales: array<string> => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.RelativeTimeFormat.makeWithLocaleAndOptions",
        "kind": "value",
        "name": "makeWithLocaleAndOptions",
        "signature": "let makeWithLocaleAndOptions: (string, {..}) => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.RelativeTimeFormat.makeWithLocalesAndOptions",
        "kind": "value",
        "name": "makeWithLocalesAndOptions",
        "signature": "let makeWithLocalesAndOptions: (array<string>, {..}) => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.RelativeTimeFormat.makeWithOptions",
        "kind": "value",
        "name": "makeWithOptions",
        "signature": "let makeWithOptions: {..} => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.RelativeTimeFormat.supportedLocalesOf",
        "kind": "value",
        "name": "supportedLocalesOf",
        "signature": "let supportedLocalesOf: array<string> => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.RelativeTimeFormat.supportedLocalesOfWithOptions",
        "kind": "value",
        "name": "supportedLocalesOfWithOptions",
        "signature": "let supportedLocalesOfWithOptions: (array<string>, {..}) => t",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.RelativeTimeFormat.resolvedOptions",
        "kind": "value",
        "name": "resolvedOptions",
        "signature": "let resolvedOptions: t => {..}",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.RelativeTimeFormat.timeUnit",
        "kind": "type",
        "name": "timeUnit",
        "signature": "type timeUnit = [\\n  | #day\\n  | #hour\\n  | #minute\\n  | #month\\n  | #quarter\\n  | #second\\n  | #week\\n  | #year\\n]",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.RelativeTimeFormat.format",
        "kind": "value",
        "name": "format",
        "signature": "let format: (t, int, timeUnit) => string",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Intl.RelativeTimeFormat.formatToParts",
        "kind": "value",
        "name": "formatToParts",
        "signature": "let formatToParts: (\\n  t,\\n  int,\\n  timeUnit,\\n) => array<{\\n  \\\"type\\\": string,\\n  \\\"unit\\\": option<string>,\\n  \\\"value\\\": string,\\n}>",
        "docstrings": []
      }]
    }]
  }, 
  {
    "id": "RescriptCore.window",
    "kind": "value",
    "name": "window",
    "signature": "let window: Dom.window",
    "docstrings": []
  }, 
  {
    "id": "RescriptCore.document",
    "kind": "value",
    "name": "document",
    "signature": "let document: Dom.document",
    "docstrings": []
  }, 
  {
    "id": "RescriptCore.globalThis",
    "kind": "value",
    "name": "globalThis",
    "signature": "let globalThis: {..}",
    "docstrings": []
  }, 
  {
    "id": "RescriptCore.null",
    "kind": "value",
    "name": "null",
    "signature": "let null: Core__Nullable.t<'a>",
    "docstrings": []
  }, 
  {
    "id": "RescriptCore.undefined",
    "kind": "value",
    "name": "undefined",
    "signature": "let undefined: Core__Nullable.t<'a>",
    "docstrings": []
  }, 
  {
    "id": "RescriptCore.typeof",
    "kind": "value",
    "name": "typeof",
    "signature": "let typeof: 'a => Core__Type.t",
    "docstrings": []
  }, 
  {
    "id": "RescriptCore.t",
    "kind": "type",
    "name": "t",
    "signature": "type t<'a> = Js.t<'a> constraint 'a = {..}",
    "docstrings": []
  }, 
  {
    "id": "RescriptCore.MapperRt",
    "kind": "moduleAlias",
    "name": "MapperRt",
    "docstrings": [],
    "items": []
  }, 
  {
    "id": "RescriptCore.Internal",
    "kind": "moduleAlias",
    "name": "Internal",
    "docstrings": [],
    "items": []
  }, 
  {
    "id": "RescriptCore.Re",
    "kind": "moduleAlias",
    "name": "Re",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Re.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = Js.Re.t",
      "docstrings": ["Type representing an instantiated `RegExp`."]
    }, 
    {
      "id": "RescriptCore.Re.Result",
      "name": "Result",
      "kind": "module",
      "items": [
      {
        "id": "RescriptCore.Re.Result.t",
        "kind": "type",
        "name": "t",
        "signature": "type t = array<string>",
        "docstrings": ["Type representing the result of a `RegExp` execution."]
      }, 
      {
        "id": "RescriptCore.Re.Result.fullMatch",
        "kind": "value",
        "name": "fullMatch",
        "signature": "let fullMatch: t => string",
        "docstrings": ["`fullMatch(regExpResult)` returns the full string that matched in this result.\n\n  ## Examples\n  ```rescript\n  // Match the first two words separated by a space\n  let regexp = RegExp.fromString(\"(\\\\w+) (\\\\w+)\")\n\n  switch regexp->RegExp.exec(\"ReScript is pretty cool, right?\") {\n  | None => Console.log(\"Nope, no match...\")\n  | Some(result) => Console.log(result->RegExp.Result.fullMatch) // Prints the full string that matched, \"ReScript is\"\n  }\n  ```"]
      }, 
      {
        "id": "RescriptCore.Re.Result.matches",
        "kind": "value",
        "name": "matches",
        "signature": "let matches: t => array<string>",
        "docstrings": ["`matches(regExpResult)` returns all matches for `regExpResult`.\n\n  ## Examples\n  ```rescript\n  // Match the first two words separated by a space\n  let regexp = RegExp.fromString(\"(\\\\w+) (\\\\w+)\")\n\n  // This below will log \"ReScript\" and \"is\" to the console.\n  switch regexp->RegExp.exec(\"ReScript is pretty cool, right?\") {\n  | None => Console.log(\"Nope, no match...\")\n  | Some(result) => switch result->RegExp.Result.matches {\n    | [firstWord, secondWord] => Console.log2(firstWord, secondWord)\n    | _ => Console.log(\"Didn't find exactly two words...\")\n    }\n  }\n  ```"]
      }, 
      {
        "id": "RescriptCore.Re.Result.index",
        "kind": "value",
        "name": "index",
        "signature": "let index: t => int",
        "docstrings": []
      }, 
      {
        "id": "RescriptCore.Re.Result.input",
        "kind": "value",
        "name": "input",
        "signature": "let input: t => string",
        "docstrings": ["`input(regExpResult)` returns the full input string that was passed to what produced the `RegExp.Result.t`.\n\n  ## Examples\n  ```rescript\n  // Match the first two words separated by a space\n  let regexp = RegExp.fromString(\"(\\\\w+) (\\\\w+)\")\n\n  // This below will log the full input string \"ReScript is pretty cool, right?\" to the console.\n  switch regexp->RegExp.exec(\"ReScript is pretty cool, right?\") {\n  | None => Console.log(\"Nope, no match...\")\n  | Some(result) => Console.log(result->RegExp.Result.input)\n  }\n  ```"]
      }]
    }, 
    {
      "id": "RescriptCore.Re.fromString",
      "kind": "value",
      "name": "fromString",
      "signature": "let fromString: string => t",
      "docstrings": ["`fromString(string)` creates a `RegExp.t` from the provided string. This can then be used to match on strings using `RegExp.exec`.\n\nSee [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/RegExp) on MDN.\n\n## Examples\n```rescript\n// Match the first word in a sentence\nlet regexp = RegExp.fromString(\"\\\\w+\")\n\nswitch regexp->RegExp.exec(\"ReScript is pretty cool, right?\") {\n| None => Console.log(\"Nope, no match...\")\n| Some(result) => Console.log(result->RegExp.Result.fullMatch) // Prints \"ReScript\"\n}\n```"]
    }, 
    {
      "id": "RescriptCore.Re.fromStringWithFlags",
      "kind": "value",
      "name": "fromStringWithFlags",
      "signature": "let fromStringWithFlags: (string, ~flags: string) => t",
      "docstrings": ["`fromStringWithFlags(string)` creates a `RegExp.t` from the provided string, using the provided `flags`. This can then be used to match on strings using `RegExp.exec`.\n\nSee [`RegExp parameters`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/RegExp#parameters) on MDN.\n\n## Examples\n```rescript\n// Match the first word in a sentence\nlet regexp = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"g\")\n\nswitch regexp->RegExp.exec(\"ReScript is pretty cool, right?\") {\n| None => Console.log(\"Nope, no match...\")\n| Some(result) => Console.log(result->RegExp.Result.fullMatch) // Prints \"ReScript\"\n}\n```"]
    }, 
    {
      "id": "RescriptCore.Re.test",
      "kind": "value",
      "name": "test",
      "signature": "let test: (t, string) => bool",
      "docstrings": ["`test(regexp, string)` tests whether the provided `regexp` matches on the provided string.\n\nSee [`RegExp.test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test) on MDN.\n\n## Examples\n```rescript\n// Match the first word in a sentence\nlet regexp = RegExp.fromString(\"\\\\w+\")\n\nif regexp->RegExp.test(\"ReScript is cool!\") {\n  Console.log(\"Yay, there's a word in there.\")\n}\n```"]
    }, 
    {
      "id": "RescriptCore.Re.exec",
      "kind": "value",
      "name": "exec",
      "signature": "let exec: (t, string) => option<Result.t>",
      "docstrings": ["`exec(regexp, string)` executes the provided regexp on the provided string, optionally returning a `RegExp.Result.t` if the regexp matches on the string.\n\nSee [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec) on MDN.\n\n## Examples\n```rescript\n// Match the first word in a sentence\nlet regexp = RegExp.fromString(\"\\\\w+\")\n\nswitch regexp->RegExp.exec(\"ReScript is pretty cool, right?\") {\n| None => Console.log(\"Nope, no match...\")\n| Some(result) => Console.log(result->RegExp.Result.fullMatch) // Prints \"ReScript\"\n}\n```"]
    }, 
    {
      "id": "RescriptCore.Re.lastIndex",
      "kind": "value",
      "name": "lastIndex",
      "signature": "let lastIndex: t => int",
      "docstrings": ["`lastIndex(regexp)` returns the index the next match will start from.\n\nSee [`RegExp.lastIndex`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex) on MDN.\n\n## Examples\n```rescript\n// Match the first word in a sentence\nlet regexp = RegExp.fromString(\"\\\\w+\")\nlet someStr = \"Many words here.\"\n\nConsole.log(regexp->RegExp.lastIndex) // Logs `0` to the console\n\nregexp->RegExp.exec(someStr)->ignore\n\nConsole.log(regexp->RegExp.lastIndex) // Logs `4` to the console\n```"]
    }, 
    {
      "id": "RescriptCore.Re.ignoreCase",
      "kind": "value",
      "name": "ignoreCase",
      "signature": "let ignoreCase: t => bool",
      "docstrings": ["`ignoreCase(regexp)` returns whether the ignore case (`i`) flag is set on this `RegExp`.\n\nSee [`RegExp.ignoreCase`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/ignoreCase) on MDN.\n\n## Examples\n```rescript\nlet regexp1 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"g\")\nConsole.log(regexp1->RegExp.ignoreCase) // Logs `false`, since `i` is not set\n\nlet regexp2 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"i\")\nConsole.log(regexp2->RegExp.ignoreCase) // Logs `true`, since `i` is set\n```"]
    }, 
    {
      "id": "RescriptCore.Re.global",
      "kind": "value",
      "name": "global",
      "signature": "let global: t => bool",
      "docstrings": ["`global(regexp)` returns whether the global (`g`) flag is set on this `RegExp`.\n\nSee [`RegExp.global`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/global) on MDN.\n\n## Examples\n```rescript\nlet regexp1 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"g\")\nConsole.log(regexp1->RegExp.global) // Logs `true`, since `g` is set\n\nlet regexp2 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"i\")\nConsole.log(regexp2->RegExp.global) // Logs `false`, since `g` is not set\n```"]
    }, 
    {
      "id": "RescriptCore.Re.multiline",
      "kind": "value",
      "name": "multiline",
      "signature": "let multiline: t => bool",
      "docstrings": ["`multiline(regexp)` returns whether the multiline (`m`) flag is set on this `RegExp`.\n\nSee [`RegExp.multiline`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/multiline) on MDN.\n\n## Examples\n```rescript\nlet regexp1 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"g\")\nConsole.log(regexp1->RegExp.multiline) // Logs `false`, since `m` is not set\n\nlet regexp2 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"mi\")\nConsole.log(regexp2->RegExp.multiline) // Logs `true`, since `m` is set\n```"]
    }, 
    {
      "id": "RescriptCore.Re.source",
      "kind": "value",
      "name": "source",
      "signature": "let source: t => string",
      "docstrings": ["`source(regexp)` returns the source text for this `RegExp`, without the two forward slashes (if present), and without any set flags.\n\nSee [`RegExp.source`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/source) on MDN.\n\n## Examples\n```rescript\nlet regexp = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"g\")\nConsole.log(regexp->RegExp.source) // Logs `\\w+`, the source text of the `RegExp`\n```"]
    }, 
    {
      "id": "RescriptCore.Re.sticky",
      "kind": "value",
      "name": "sticky",
      "signature": "let sticky: t => bool",
      "docstrings": ["`sticky(regexp)` returns whether the sticky (`y`) flag is set on this `RegExp`.\n\nSee [`RegExp.sticky`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky) on MDN.\n\n## Examples\n```rescript\nlet regexp1 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"g\")\nConsole.log(regexp1->RegExp.unicode) // Logs `false`, since `y` is not set\n\nlet regexp2 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"my\")\nConsole.log(regexp2->RegExp.unicode) // Logs `true`, since `y` is set\n```"]
    }, 
    {
      "id": "RescriptCore.Re.unicode",
      "kind": "value",
      "name": "unicode",
      "signature": "let unicode: t => bool",
      "docstrings": ["`unicode(regexp)` returns whether the unicode (`y`) flag is set on this `RegExp`.\n\nSee [`RegExp.unicode`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/unicode) on MDN.\n\n## Examples\n```rescript\nlet regexp1 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"g\")\nConsole.log(regexp1->RegExp.unicode) // Logs `false`, since `u` is not set\n\nlet regexp2 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"mu\")\nConsole.log(regexp2->RegExp.unicode) // Logs `true`, since `u` is set\n```"]
    }]
  }, 
  {
    "id": "RescriptCore.Exn",
    "kind": "moduleAlias",
    "name": "Exn",
    "docstrings": [],
    "items": []
  }, 
  {
    "id": "RescriptCore.Option",
    "kind": "moduleAlias",
    "name": "Option",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Option.filter",
      "kind": "value",
      "name": "filter",
      "signature": "let filter: (option<'a>, 'a => bool) => option<'a>",
      "docstrings": ["`filter(opt, f)` applies `f` to `opt`, if `f` returns `true`, then it returns `Some(value)`, otherwise returns `None`.\n\n## Examples\n\n```rescript\nOption.filter(Some(10), x => x > 5) // Some(10)\nOption.filter(Some(4), x => x > 5) // None\nOption.filter(None, x => x > 5) // None\n```"]
    }, 
    {
      "id": "RescriptCore.Option.forEach",
      "kind": "value",
      "name": "forEach",
      "signature": "let forEach: (option<'a>, 'a => unit) => unit",
      "docstrings": ["`forEach(opt, f)` call `f` on `opt`. if `opt` is `Some(value)`, then if calls\n`f`, otherwise returns `unit`.\n\n## Examples\n\n```rescript\nOption.forEach(Some(\"thing\"), x => Console.log(x)) // logs \"thing\"\nOption.forEach(None, x => Console.log(x)) // returns ()\n```"]
    }, 
    {
      "id": "RescriptCore.Option.getExn",
      "kind": "value",
      "name": "getExn",
      "signature": "let getExn: option<'a> => 'a",
      "docstrings": ["`getExn(opt)` returns `value` if `opt` is `Some(value)`, otherwise raises an exception.\n\n```rescript\nOption.getExn(Some(3)) // 3\nOption.getExn(None) /* Raises an Error */\n```\n\n## Exceptions\n\n- Raises an error if `opt` is `None`"]
    }, 
    {
      "id": "RescriptCore.Option.getUnsafe",
      "kind": "value",
      "name": "getUnsafe",
      "signature": "let getUnsafe: option<'a> => 'a",
      "docstrings": ["`getUnsafe(opt)` returns `value` if `opt` is `Some(value)`, otherwise `undefined`.\n\n## Examples\n\n```rescript\nOption.getUnsafe(Some(3)) == 3\nOption.getUnsafe(None: option<int>) // Returns `undefined`, which is not a valid `int`\n```\n\n## Notes\n\n- This is an unsafe operation. It assumes `value` is not `None`, and may cause undefined behaviour if it is."]
    }, 
    {
      "id": "RescriptCore.Option.mapOr",
      "kind": "value",
      "name": "mapOr",
      "signature": "let mapOr: (option<'a>, 'b, 'a => 'b) => 'b",
      "docstrings": ["`mapOr(opt, default, f)` returns `f(value)` if `opt` is `Some(value)`, otherwise `default`.\n\n## Examples\n\n```rescript\nlet someValue = Some(3)\nsomeValue->Option.mapOr(0, x => x + 5) // 8\n\nlet noneValue = None\nnoneValue->Option.mapOr(0, x => x + 5) // 0\n```"]
    }, 
    {
      "id": "RescriptCore.Option.mapWithDefault",
      "kind": "value",
      "name": "mapWithDefault",
      "deprecated": "Use mapOr instead",
      "signature": "let mapWithDefault: (option<'a>, 'b, 'a => 'b) => 'b",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Option.map",
      "kind": "value",
      "name": "map",
      "signature": "let map: (option<'a>, 'a => 'b) => option<'b>",
      "docstrings": ["`map(opt, f)` returns `Some(f(value))` if `opt` is `Some(value)`, otherwise `None`.\n\n## Examples\n\n```rescript\nOption.map(Some(3), x => x * x) // Some(9)\nOption.map(None, x => x * x) // None\n```"]
    }, 
    {
      "id": "RescriptCore.Option.flatMap",
      "kind": "value",
      "name": "flatMap",
      "signature": "let flatMap: (option<'a>, 'a => option<'b>) => option<'b>",
      "docstrings": ["`flatMap(opt, f)` returns `f(value)` if `opt` is `Some(value)`, otherwise `None`.\n\n## Examples\n\n```rescript\nlet addIfAboveOne = value =>\n  if (value > 1) {\n    Some(value + 1)\n  } else {\n    None\n  }\n\nOption.flatMap(Some(2), addIfAboveOne) // Some(3)\nOption.flatMap(Some(-4), addIfAboveOne) // None\nOption.flatMap(None, addIfAboveOne) // None\n```"]
    }, 
    {
      "id": "RescriptCore.Option.getOr",
      "kind": "value",
      "name": "getOr",
      "signature": "let getOr: (option<'a>, 'a) => 'a",
      "docstrings": ["`getOr(opt, default)` returns `value` if `opt` is `Some(value)`, otherwise `default`.\n\n## Examples\n\n```rescript\nOption.getOr(None, \"Banana\") // Banana\nOption.getOr(Some(\"Apple\"), \"Banana\") // Apple\n\nlet greet = (firstName: option<string>) =>\n  \"Greetings \" ++ firstName->Option.getOr(\"Anonymous\")\n\nSome(\"Jane\")->greet // \"Greetings Jane\"\nNone->greet // \"Greetings Anonymous\"\n```"]
    }, 
    {
      "id": "RescriptCore.Option.getWithDefault",
      "kind": "value",
      "name": "getWithDefault",
      "deprecated": "Use getOr instead",
      "signature": "let getWithDefault: (option<'a>, 'a) => 'a",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Option.orElse",
      "kind": "value",
      "name": "orElse",
      "signature": "let orElse: (option<'a>, option<'a>) => option<'a>",
      "docstrings": ["`orElse(opt1, opt2)` returns `opt2` if `opt1` is `None`, otherwise `opt1`.\n\n## Examples\n\n```rescript\nOption.orElse(Some(1812), Some(1066)) == Some(1812)\nOption.orElse(None, Some(1066) == Some(1066)\nOption.orElse(None, None) == None\n```"]
    }, 
    {
      "id": "RescriptCore.Option.isSome",
      "kind": "value",
      "name": "isSome",
      "signature": "let isSome: option<'a> => bool",
      "docstrings": ["`isSome(opt)` returns `true` if `opt` is `Some(value)`, otherwise returns `false`.\n\n## Examples\n\n```rescript\nOption.isSome(None) // false\nOption.isSome(Some(1)) // true\n```"]
    }, 
    {
      "id": "RescriptCore.Option.isNone",
      "kind": "value",
      "name": "isNone",
      "signature": "let isNone: option<'a> => bool",
      "docstrings": ["`isNone(opt)` returns `true` if `opt` is `None`, false otherwise.\n\n## Examples\n\n```rescript\nOption.isNone(None) // true\nOption.isNone(Some(1)) // false\n```"]
    }, 
    {
      "id": "RescriptCore.Option.equal",
      "kind": "value",
      "name": "equal",
      "signature": "let equal: (option<'a>, option<'b>, ('a, 'b) => bool) => bool",
      "docstrings": ["`equal(opt1, opt2, f)` evaluates two optional values for equality with respect to a predicate function `f`. If both `opt1` and `opt2` are `None`, returns `true`.\nIf one of the arguments is `Some(value)` and the other is `None`, returns\n`false`.\nIf arguments are `Some(value1)` and `Some(value2)`, returns the result of\n`f(value1, value2)`, the predicate function `f` must return a bool.\n\n## Examples\n\n```rescript\nlet clockEqual = (a, b) => mod(a, 12) == mod(b, 12)\n\nopen Option\n\nequal(Some(3), Some(15), clockEqual) // true\nequal(Some(3), None, clockEqual) // false\nequal(None, Some(3), clockEqual) // false\nequal(None, None, clockEqual) // true\n```"]
    }, 
    {
      "id": "RescriptCore.Option.compare",
      "kind": "value",
      "name": "compare",
      "signature": "let compare: (option<'a>, option<'b>, ('a, 'b) => Core__Ordering.t) => Core__Ordering.t",
      "docstrings": ["`compare(opt1, opt2, f)` compares two optional values with respect to given `f`.\n\nIf both `opt1` and `opt2` are `None`, it returns `0.`. If the first argument is `Some(value1)` and the second is `None`, returns `1.` (something is greater than nothing).\n\nIf the first argument is `None` and the second is `Some(value2)`, returns `-1.`\n(nothing is less than something).\n\nIf the arguments are `Some(value1)` and `Some(value2)`, returns the result of\n`f(value1, value2)`, `f` takes two arguments and returns `-1.` if the first\nargument is less than the second, `0.` if the arguments are equal, and `1.` if\nthe first argument is greater than the second.\n\n## Examples\n\n```rescript\nlet clockCompare = (a, b) => compare(mod(a, 12), mod(b, 12))\n\nopen Option\n\ncompare(Some(3), Some(15), clockCompare) // 0.\ncompare(Some(3), Some(14), clockCompare) // 1.\ncompare(Some(2), Some(15), clockCompare) // (-1.)\ncompare(None, Some(15), clockCompare) // (-1.)\ncompare(Some(14), None, clockCompare) // 1.\ncompare(None, None, clockCompare) // 0.\n```"]
    }]
  }, 
  {
    "id": "RescriptCore.List",
    "kind": "moduleAlias",
    "name": "List",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.List.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'a> = list<'a>",
      "docstrings": ["Collection functions for manipulating the `list` data structures, a singly-linked list.\n\n**Prefer Array** if you need any of the following:\n\n- Random access of element\n- Better interop with JavaScript\n- Better memory usage & performance."]
    }, 
    {
      "id": "RescriptCore.List.length",
      "kind": "value",
      "name": "length",
      "signature": "let length: t<'a> => int",
      "docstrings": ["`length(list)` returns the length of `list`.\n\n## Examples\n\n```rescript\nList.length(list{1, 2, 3}) // 3\n```"]
    }, 
    {
      "id": "RescriptCore.List.size",
      "kind": "value",
      "name": "size",
      "signature": "let size: t<'a> => int",
      "docstrings": ["`size(list)`. See [`length`](#length)\n\n## Examples\n\n```rescript\nList.size(list{1, 2, 3}) // 3\n```"]
    }, 
    {
      "id": "RescriptCore.List.head",
      "kind": "value",
      "name": "head",
      "signature": "let head: t<'a> => option<'a>",
      "docstrings": ["`head(list)` returns `Some(value)` where `value` is the first element in the\nlist, or `None` if `list` is an empty list.\n\n## Examples\n\n```rescript\nList.head(list{}) // None\nList.head(list{1, 2, 3}) // Some(1)\n```"]
    }, 
    {
      "id": "RescriptCore.List.headExn",
      "kind": "value",
      "name": "headExn",
      "signature": "let headExn: t<'a> => 'a",
      "docstrings": ["`headExn(list)` same as [`head`](#head).\n\n## Examples\n\n```rescript\nList.headExn(list{1, 2, 3}) // 1\n\nList.headExn(list{}) // Raises an Error\n```\n\n## Exceptions\n\n- Raises an Error if list is empty."]
    }, 
    {
      "id": "RescriptCore.List.tail",
      "kind": "value",
      "name": "tail",
      "signature": "let tail: t<'a> => option<t<'a>>",
      "docstrings": ["`tail(list)` returns `None` if `list` is empty, otherwise it returns `Some(tail)`\nwhere `tail` is everything except the first element of `list`.\n\n## Examples\n\n```rescript\nList.tail(list{1, 2, 3}) // Some(list{2, 3})\n\nList.tail(list{}) // None\n```"]
    }, 
    {
      "id": "RescriptCore.List.tailExn",
      "kind": "value",
      "name": "tailExn",
      "signature": "let tailExn: t<'a> => t<'a>",
      "docstrings": ["`tailExn(list)` same as [`tail`](#tail).\n\n## Examples\n\n```rescript\nList.tailExn(list{1, 2, 3}) // list{2, 3}\n\nList.tailExn(list{}) // Raises an Error\n```\n\n## Exceptions\n\n- Raises an Error if list is empty."]
    }, 
    {
      "id": "RescriptCore.List.add",
      "kind": "value",
      "name": "add",
      "signature": "let add: (t<'a>, 'a) => t<'a>",
      "docstrings": ["`add(list, value)` adds a `value` to the beginning of list `list`.\n\n## Examples\n\n```rescript\nList.add(list{2, 3}, 1) // list{1, 2, 3}\n\nList.add(list{\"World\", \"!\"}, \"Hello\") // list{\"Hello\", \"World\", \"!\"}\n```"]
    }, 
    {
      "id": "RescriptCore.List.get",
      "kind": "value",
      "name": "get",
      "signature": "let get: (t<'a>, int) => option<'a>",
      "docstrings": ["`get(list, index)` return the `index` element in `list`, or `None` if `index`\nis larger than the length of list `list`.\n\n## Examples\n\n```rescript\nlet abc = list{\"A\", \"B\", \"C\"}\n\nabc->List.get(1) // Some(\"B\")\n\nabc->List.get(4) // None\n```"]
    }, 
    {
      "id": "RescriptCore.List.getExn",
      "kind": "value",
      "name": "getExn",
      "signature": "let getExn: (t<'a>, int) => 'a",
      "docstrings": ["`getExn(list, index)` same as [`get`](#get).\n\n## Examples\n\n```rescript\nlet abc = list{\"A\", \"B\", \"C\"}\n\nabc->List.getExn(1) // \"B\"\n\nabc->List.getExn(4) // Raises an Error\n```\n\n## Exceptions\n\n- Raises an Error if `index` is larger than the length of list."]
    }, 
    {
      "id": "RescriptCore.List.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: (int, 'a) => t<'a>",
      "docstrings": ["`make(length, value)` returns a list of length `length` with each element filled\nwith `value`. Returns an empty list if `value` is negative.\n\n## Examples\n\n```rescript\nList.make(3, 1) // list{1, 1, 1}\n```"]
    }, 
    {
      "id": "RescriptCore.List.makeBy",
      "kind": "value",
      "name": "makeBy",
      "signature": "let makeBy: (int, int => 'a) => t<'a>",
      "docstrings": ["`makeBy(length, f)` return a list of length `length` with element initialized\nwith `f`. Returns an empty list if `length` is negative.\n\n## Examples\n\n```rescript\nList.makeBy(5, i => i) // list{0, 1, 2, 3, 4}\n\nList.makeBy(5, i => i * i) // list{0, 1, 4, 9, 16}\n```"]
    }, 
    {
      "id": "RescriptCore.List.toShuffled",
      "kind": "value",
      "name": "toShuffled",
      "signature": "let toShuffled: t<'a> => t<'a>",
      "docstrings": ["`toShuffled(list)` returns a new list in random order.\n\n## Examples\n\n```rescript\nList.toShuffled(list{1, 2, 3}) // list{2, 1, 3}\n```"]
    }, 
    {
      "id": "RescriptCore.List.drop",
      "kind": "value",
      "name": "drop",
      "signature": "let drop: (t<'a>, int) => option<t<'a>>",
      "docstrings": ["`drop(list, value)` return a new list, dropping the first `value` element.\nReturns `None` if `list` has fewer than `value` elements.\n\n## Examples\n\n```rescript\nlist{1, 2, 3}->List.drop(2) // Some(list{3})\n\nlist{1, 2, 3}->List.drop(3) // Some(list{})\n\nlist{1, 2, 3}->List.drop(4) // None\n```"]
    }, 
    {
      "id": "RescriptCore.List.take",
      "kind": "value",
      "name": "take",
      "signature": "let take: (t<'a>, int) => option<t<'a>>",
      "docstrings": ["`take(list, value)` returns a list with the first `value` elements from `list`,\nor `None` if `list` has fewer than `value` elements.\n\n## Examples\n\n```rescript\nlist{1, 2, 3}->List.take(1) // Some(list{1})\n\nlist{1, 2, 3}->List.take(2) // Some(list{1, 2})\n\nlist{1, 2, 3}->List.take(4) // None\n```"]
    }, 
    {
      "id": "RescriptCore.List.splitAt",
      "kind": "value",
      "name": "splitAt",
      "signature": "let splitAt: (t<'a>, int) => option<(list<'a>, list<'a>)>",
      "docstrings": ["`splitAt(list, n)` split the list `list` at `n`. Returns `None` when the length\nof `list` is less than `n`.\n\n## Examples\n\n```rescript\nlist{\"Hello\", \"World\"}->List.splitAt(1) // Some((list{\"Hello\"}, list{\"World\"}))\n\nlist{0, 1, 2, 3, 4}->List.splitAt(2) // Some((list{0, 1}, list{2, 3, 4}))\n```"]
    }, 
    {
      "id": "RescriptCore.List.concat",
      "kind": "value",
      "name": "concat",
      "signature": "let concat: (t<'a>, t<'a>) => t<'a>",
      "docstrings": ["`concat(list1, list2)` returns the list obtained by adding `list1` after `list2`.\n\n## Examples\n\n```rescript\nList.concat(list{1, 2, 3}, list{4, 5}) // list{1, 2, 3, 4, 5}\n```"]
    }, 
    {
      "id": "RescriptCore.List.concatMany",
      "kind": "value",
      "name": "concatMany",
      "signature": "let concatMany: array<t<'a>> => t<'a>",
      "docstrings": ["`concatMany(arr)` returns the list obtained by concatenating all the lists in\narray `arr`, in order.\n\n## Examples\n\n```rescript\nList.concatMany([list{1, 2, 3}, list{}, list{3}]) // list{1, 2, 3, 3}\n```"]
    }, 
    {
      "id": "RescriptCore.List.reverseConcat",
      "kind": "value",
      "name": "reverseConcat",
      "signature": "let reverseConcat: (t<'a>, t<'a>) => t<'a>",
      "docstrings": ["`reverseConcat(list1, list2)` is equivalent to writing: `concat(reverse(list1, list2)`\n\n## Examples\n\n```rescript\nList.reverseConcat(list{1, 2}, list{3, 4}) // list{2, 1, 3, 4}\n```"]
    }, 
    {
      "id": "RescriptCore.List.flatten",
      "kind": "value",
      "name": "flatten",
      "signature": "let flatten: t<t<'a>> => t<'a>",
      "docstrings": ["`flatten(list)` return the list obtained by concatenating all the lists in\n`list`, in order.\n\n## Examples\n\n```rescript\nList.flatten(list{list{1, 2, 3}, list{}, list{3}}) // list{1, 2, 3, 3}\n```"]
    }, 
    {
      "id": "RescriptCore.List.map",
      "kind": "value",
      "name": "map",
      "signature": "let map: (t<'a>, 'a => 'b) => t<'b>",
      "docstrings": ["`map(list, f)` returns a new list with `f` applied to each element of `list`.\n\n## Examples\n\n```rescript\nlist{1, 2}->List.map(x => x + 1) // list{3, 4}\n```"]
    }, 
    {
      "id": "RescriptCore.List.zip",
      "kind": "value",
      "name": "zip",
      "signature": "let zip: (t<'a>, t<'b>) => t<('a, 'b)>",
      "docstrings": ["`zip(list1, list2)` returns a list of pairs from the two lists with the length\nof the shorter list.\n\n## Examples\n\n```rescript\nList.zip(list{1, 2}, list{3, 4, 5}) // list{(1, 3), (2, 4)}\n```"]
    }, 
    {
      "id": "RescriptCore.List.zipBy",
      "kind": "value",
      "name": "zipBy",
      "signature": "let zipBy: (t<'a>, t<'b>, ('a, 'b) => 'c) => t<'c>",
      "docstrings": ["`zipBy(list1, list2, f)`. See [`zip`](#zip)\n\n## Examples\n\n```rescript\nList.zipBy(list{1, 2, 3}, list{4, 5}, (a, b) => 2 * a + b) // list{6, 9}\n```"]
    }, 
    {
      "id": "RescriptCore.List.mapWithIndex",
      "kind": "value",
      "name": "mapWithIndex",
      "signature": "let mapWithIndex: (t<'a>, (int, 'a) => 'b) => t<'b>",
      "docstrings": ["`mapWithIndex(list, f)` applies `f` to each element of `list`. Function `f`\ntakes two arguments: the index starting from 0 and the element from `list`, in\nthat order.\n\n## Examples\n\n```rescript\nlist{1, 2, 3}->List.mapWithIndex((index, x) => index + x) // list{1, 3, 5}\n```"]
    }, 
    {
      "id": "RescriptCore.List.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: array<'a> => t<'a>",
      "docstrings": ["`fromArray(arr)` converts the given array `arr` to a list.\n\n## Examples\n\n```rescript\nList.fromArray([1, 2, 3]) // list{1, 2, 3}\n```"]
    }, 
    {
      "id": "RescriptCore.List.toArray",
      "kind": "value",
      "name": "toArray",
      "signature": "let toArray: t<'a> => array<'a>",
      "docstrings": ["`toArray(list)` converts the given list `list` to an array.\n\n## Examples\n\n```rescript\nList.toArray(list{1, 2, 3}) // [1, 2, 3]\n```"]
    }, 
    {
      "id": "RescriptCore.List.reverse",
      "kind": "value",
      "name": "reverse",
      "signature": "let reverse: t<'a> => t<'a>",
      "docstrings": ["`reverse(list)` returns a new list whose elements are those of `list` in\nreversed order.\n\n## Examples\n\n```rescript\nList.reverse(list{1, 2, 3}) // list{3, 2, 1}\n```"]
    }, 
    {
      "id": "RescriptCore.List.mapReverse",
      "kind": "value",
      "name": "mapReverse",
      "signature": "let mapReverse: (t<'a>, 'a => 'b) => t<'b>",
      "docstrings": ["`mapReverse(list, f)` is equivalent to `map` function.\n\n## Examples\n\n```rescript\nlet f = x => x * x\nlet l = list{3, 4, 5}\n\nlet withMap = List.map(l, f)->List.reverse\nlet withMapReverse = l->List.mapReverse(f)\n\nConsole.log(withMap == withMapReverse) // true\n```"]
    }, 
    {
      "id": "RescriptCore.List.forEach",
      "kind": "value",
      "name": "forEach",
      "signature": "let forEach: (t<'a>, 'a => 'b) => unit",
      "docstrings": ["`forEach(list, f)` call `f` on each element of `list` from the beginning to end.\n`f` returns `unit`, so no new array is created. Use `forEach` when you are primarily\nconcerned with repetitively creating side effects.\n\n## Examples\n\n```rescript\nList.forEach(list{\"a\", \"b\", \"c\"}, x => Console.log(\"Item: \" ++ x))\n/*\n  prints:\n  Item: a\n  Item: b\n  Item: c\n*/\n```"]
    }, 
    {
      "id": "RescriptCore.List.forEachWithIndex",
      "kind": "value",
      "name": "forEachWithIndex",
      "signature": "let forEachWithIndex: (t<'a>, (int, 'a) => 'b) => unit",
      "docstrings": ["`forEachWithIndex(list, f, index)` call `f` on each element of `list` from beginning\nto end. Function `f` takes two arguments: the `index` starting from 0 and the\nelement from `list`. `f` returns `unit`.\n\n## Examples\n\n```rescript\nList.forEachWithIndex(list{\"a\", \"b\", \"c\"}, (index, x) => {\n  Console.log(\"Item \" ++ Int.toString(index) ++ \" is \" ++ x)\n})\n/*\n  prints:\n  Item 0 is a\n  Item 1 is b\n  Item 2 is cc\n*/\n```"]
    }, 
    {
      "id": "RescriptCore.List.reduce",
      "kind": "value",
      "name": "reduce",
      "signature": "let reduce: (t<'a>, 'b, ('b, 'a) => 'b) => 'b",
      "docstrings": ["`reduce(list, initialValue, f)` applies `f` to each element of `list` from\nbeginning to end. Function `f` has two parameters: the item from the list and\nan \"accumulator\", which starts with a value of `initialValue`. `reduce` returns\nthe final value of the accumulator.\n\n## Examples\n\n```rescript\nlist{1, 2, 3, 4}->List.reduce(0, (a, b) => a + b) // 10\n\n// same as\n\nlist{1, 2, 3, 4}->List.reduce(0, (acc, item) => acc + item) // 10\n```"]
    }, 
    {
      "id": "RescriptCore.List.reduceWithIndex",
      "kind": "value",
      "name": "reduceWithIndex",
      "signature": "let reduceWithIndex: (t<'a>, 'b, ('b, 'a, int) => 'b) => 'b",
      "docstrings": ["`reduceWithIndex(list, initialValue, f)` applies `f` to each element of `list`\nfrom beginning to end. Function `f` has three parameters: the item from the list\nand an \"accumulator\", which starts with a value of `initialValue` and the index\nof each element. `reduceWithIndex` returns the final value of the accumulator.\n\n## Examples\n\n```rescript\nlist{1, 2, 3, 4}->List.reduceWithIndex(0, (acc, item, index) => acc + item + index) // 16\n```"]
    }, 
    {
      "id": "RescriptCore.List.reduceReverse",
      "kind": "value",
      "name": "reduceReverse",
      "signature": "let reduceReverse: (t<'a>, 'b, ('b, 'a) => 'b) => 'b",
      "docstrings": ["`reduceReverse(list, initialValue, f)` works like `reduce`, except that\nfunction `f` is applied to each item of `list` from the last back to the first.\n\n## Examples\n\n```rescript\nlist{1, 2, 3, 4}->List.reduceReverse(0, (a, b) => a + b) // 10\n\nlist{1, 2, 3, 4}->List.reduceReverse(10, (a, b) => a - b) // 0\n\nlist{1, 2, 3, 4}->List.reduceReverse(list{}, List.add) // list{1, 2, 3, 4}\n```"]
    }, 
    {
      "id": "RescriptCore.List.mapReverse2",
      "kind": "value",
      "name": "mapReverse2",
      "signature": "let mapReverse2: (t<'a>, t<'b>, ('a, 'b) => 'c) => t<'c>",
      "docstrings": ["`mapReverse2(list1, list2, f)` is equivalent to `List.zipBy(list1, list2, f)->List.reverse`.\n\n## Examples\n\n```rescript\nList.mapReverse2(list{1, 2, 3}, list{1, 2}, (a, b) => a + b) // list{4, 2}\n```"]
    }, 
    {
      "id": "RescriptCore.List.forEach2",
      "kind": "value",
      "name": "forEach2",
      "signature": "let forEach2: (t<'a>, t<'b>, ('a, 'b) => 'c) => unit",
      "docstrings": ["`forEach2(list1, list2, f)` is similar to `forEach`, but accepts two lists and\nstops at the length of the shorter list.\n\n## Examples\n\n```rescript\nList.forEach2(list{\"Z\", \"Y\"}, list{\"A\", \"B\", \"C\"}, (x, y) => Console.log2(x, y))\n\n/*\n  prints:\n  \"Z\" \"A\"\n  \"Y\" \"B\"\n*/\n```"]
    }, 
    {
      "id": "RescriptCore.List.reduce2",
      "kind": "value",
      "name": "reduce2",
      "signature": "let reduce2: (t<'b>, t<'c>, 'a, ('a, 'b, 'c) => 'a) => 'a",
      "docstrings": ["`reduce2(list1, list2, initialValue, f)` applies `f` to each element of `list1`\nand `list2` from beginning to end. Stops with the shorter list. Function `f` has\nthree parameters: an accumulator which starts with a value of `initialValue`, an\nitem from `l1`, and an item from `l2`. `reduce2` returns the final value of the\naccumulator.\n\n## Examples\n\n```rescript\nList.reduce2(list{1, 2, 3}, list{4, 5}, 0, (acc, x, y) => acc + x * x + y) // 0 + (1 * 1 + 4) + (2 * 2 + 5)\n```"]
    }, 
    {
      "id": "RescriptCore.List.reduceReverse2",
      "kind": "value",
      "name": "reduceReverse2",
      "signature": "let reduceReverse2: (t<'a>, t<'b>, 'c, ('c, 'a, 'b) => 'c) => 'c",
      "docstrings": ["`reduceReverse2(list1, list2, initialValue, f)` applies `f` to each element of\n`list1` and `list2`from end to beginning. Stops with the shorter list. Function\n`f` has three parameters: an accumulator which starts with a value of\n`initialValue`, an item from `l1`, and an item from `l2`. `reduce2` returns the\nfinal value of the accumulator.\n\n## Examples\n\n```rescript\nList.reduceReverse2(list{1, 2, 3}, list{4, 5}, 0, (acc, x, y) => acc + x * x + y) //  + (1 * 1 + 4) + (2 * 2 + 5)\n```"]
    }, 
    {
      "id": "RescriptCore.List.every",
      "kind": "value",
      "name": "every",
      "signature": "let every: (t<'a>, 'a => bool) => bool",
      "docstrings": ["`every(list, f)` returns `true` if all elements in `list` satisfy `f`, where `f`\nis a predicate: a function taking an element and returning a bool.\n\n## Examples\n\n```rescript\nlet isBelow10 = value => value < 10\n\nlist{1, 9, 8, 2}->List.every(isBelow10) // true\n\nlist{1, 99, 8, 2}->List.every(isBelow10) // false\n```"]
    }, 
    {
      "id": "RescriptCore.List.some",
      "kind": "value",
      "name": "some",
      "signature": "let some: (t<'a>, 'a => bool) => bool",
      "docstrings": ["`some(list, f)` returns `true` if at least _one_ of the elements in `list`\nsatisfies `f`, where `f` is a predicate: a function taking an element and\nreturning a bool.\n\n## Examples\n\n```rescript\nlet isAbove100 = value => value > 100\n\nlist{101, 1, 2, 3}->List.some(isAbove100) // true\n\nlist{1, 2, 3, 4}->List.some(isAbove100) // false\n```"]
    }, 
    {
      "id": "RescriptCore.List.every2",
      "kind": "value",
      "name": "every2",
      "signature": "let every2: (t<'a>, t<'b>, ('a, 'b) => bool) => bool",
      "docstrings": ["`every2(list1, list2, f)` returns `true` if predicate `f` is `true` for all\npairs of elements up to the shorter length (i.e. `min(length(list1), length(list2))`)\n\n## Examples\n\n```rescript\nList.every2(list{1, 2, 3}, list{0, 1}, (a, b) => a > b) // true\n\nList.every2(list{}, list{1}, (a, b) => a > b) // true\n\nList.every2(list{2, 3}, list{1}, (a, b) => a > b) // true\n\nList.every2(list{0, 1}, list{5, 0}, (a, b) => a > b) // false\n```"]
    }, 
    {
      "id": "RescriptCore.List.some2",
      "kind": "value",
      "name": "some2",
      "signature": "let some2: (t<'a>, t<'b>, ('a, 'b) => bool) => bool",
      "docstrings": ["`some2(list1, list2, f)` returns `true` if predicate `f` is `true` for any pair\nof elements up to the shorter length (i.e. `min(length(list1), length(list2))`)\n\n## Examples\n\n```rescript\nList.some2(list{1, 2, 3}, list{0, 1}, (a, b) => a > b) // true\n\nList.some2(list{}, list{1}, (a, b) => a > b) // false\n\nList.some2(list{2, 3}, list{1}, (a, b) => a > b) // true\n\nList.some2(list{0, 1}, list{5, 0}, (a, b) => a > b) // true\n```"]
    }, 
    {
      "id": "RescriptCore.List.compareLength",
      "kind": "value",
      "name": "compareLength",
      "signature": "let compareLength: (t<'a>, t<'a>) => Core__Ordering.t",
      "docstrings": ["`compareLength(list1, list2)` compare two lists solely by length. Returns `-1.` if\n`length(list1)` is less than `length(list2)`, `0.` if `length(list1)` equals\n`length(list2)`, and `1.` if `length(list1)` is greater than `length(list2)`.\n\n## Examples\n\n```rescript\nList.compareLength(list{1, 2}, list{3, 4, 5, 6}) // -1.\n\nList.compareLength(list{1, 2, 3}, list{4, 5, 6}) // 0.\n\nList.compareLength(list{1, 2, 3, 4}, list{5, 6}) // 1.\n```"]
    }, 
    {
      "id": "RescriptCore.List.compare",
      "kind": "value",
      "name": "compare",
      "signature": "let compare: (t<'a>, t<'a>, ('a, 'a) => Core__Ordering.t) => Core__Ordering.t",
      "docstrings": ["`compare(list1, list2, f)` compare elements one by one `f`. `f` returns a negative\nnumber if `list1` is \"less than\" `list2`, zero if `list1` is \"equal to\" `list2`,\na positive number if `list1` is \"greater than\" `list2`.\n\nThe comparison returns the first non-zero result of `f`, or zero if `f` returns\nzero for all `list1` and `list2`.\n\n- If all items have compared equal, but `list1` is exhausted first, return `-1.`. (`list1` is shorter).\n- If all items have compared equal, but `list2` is exhausted first, return `1.` (`list1` is longer).\n\n## Examples\n\n```rescript\nList.compare(list{3}, list{3, 7}, (a, b) => compare(a, b)) /* (-1.) */\n\nList.compare(list{5, 3}, list{5}, (a, b) => compare(a, b)) /* 1. */\n\nList.compare(list{1, 3, 5}, list{1, 4, 2}, (a, b) => compare(a, b)) /* (-1.) */\n\nList.compare(list{1, 3, 5}, list{1, 2, 3}, (a, b) => compare(a, b)) /* 1. */\n\nList.compare(list{1, 3, 5}, list{1, 3, 5}, (a, b) => compare(a, b)) /* 0. */\n```\n\n**Please note:** The total ordering of List is different from Array,\nfor Array, we compare the length first and, only if the lengths are equal, elements one by one.\nFor lists, we just compare elements one by one."]
    }, 
    {
      "id": "RescriptCore.List.equal",
      "kind": "value",
      "name": "equal",
      "signature": "let equal: (t<'a>, t<'a>, ('a, 'a) => bool) => bool",
      "docstrings": ["`equal(list1, list2, f)` check equality of `list2` and `list2` using `f` for\nequality on elements, where `f` is a function that returns `true` if items `x` and\n`y` meet some criterion for equality, `false` otherwise. equal `false` if length\nof `list1` and `list2` are not the same.\n\n## Examples\n\n```rescript\nList.equal(list{1, 2, 3}, list{1, 2}, (a, b) => a == b) // false\n\nList.equal(list{1, 2}, list{1, 2}, (a, b) => a == b) // true\n\nList.equal(list{1, 2, 3}, list{(-1), (-2), (-3)}, (a, b) => abs(a) == abs(b)) // true\n```"]
    }, 
    {
      "id": "RescriptCore.List.has",
      "kind": "value",
      "name": "has",
      "signature": "let has: (t<'a>, 'b, ('a, 'b) => bool) => bool",
      "docstrings": ["`has(list, element, f)` returns `true` if the list contains at least one\n`element` for which `f` returns `true'.\n\n## Examples\n\n```rescript\nlist{1, 2, 3}->List.has(2, (a, b) => a == b) // true\n\nlist{1, 2, 3}->List.has(4, (a, b) => a == b) // false\n\nlist{(-1), (-2), (-3)}->List.has(2, (a, b) => abs(a) == abs(b)) // true\n```"]
    }, 
    {
      "id": "RescriptCore.List.getBy",
      "kind": "value",
      "name": "getBy",
      "signature": "let getBy: (t<'a>, 'a => bool) => option<'a>",
      "docstrings": ["`getBy(list, f)` returns `Some(value)` for the first value in `list` that\nsatisfies the predicate function `f`. Returns `None` if no element satisfies\nthe function.\n\n## Examples\n\n```rescript\nList.getBy(list{1, 4, 3, 2}, x => x > 3) // Some(4)\n\nList.getBy(list{1, 4, 3, 2}, x => x > 4) // None\n```"]
    }, 
    {
      "id": "RescriptCore.List.filter",
      "kind": "value",
      "name": "filter",
      "signature": "let filter: (t<'a>, 'a => bool) => t<'a>",
      "docstrings": ["`filter(list, f)` returns a list of all elements in `list` which satisfy the\npredicate function `f`.\n\n## Examples\n\n```rescript\nlet isEven = x => mod(x, 2) == 0\n\nList.filter(list{1, 2, 3, 4}, isEven) // list{2, 4}\n\nList.filter(list{None, Some(2), Some(3), None}, Option.isSome) // list{Some(2), Some(3)}\n```"]
    }, 
    {
      "id": "RescriptCore.List.filterWithIndex",
      "kind": "value",
      "name": "filterWithIndex",
      "signature": "let filterWithIndex: (t<'a>, ('a, int) => bool) => t<'a>",
      "docstrings": ["`filterWithIndex(list, f)` returns a list of all elements in `list` which\nsatisfy the predicate function `f`.\n\n## Examples\n\n```rescript\nlet isEven = x => mod(x, 2) == 0\n\nList.filterWithIndex(list{1, 2, 3, 4}, (_x, index) => isEven(index)) // list{1, 3}\n```"]
    }, 
    {
      "id": "RescriptCore.List.filterMap",
      "kind": "value",
      "name": "filterMap",
      "signature": "let filterMap: (t<'a>, 'a => option<'b>) => t<'b>",
      "docstrings": ["`filterMap(list, f)` applies `f` to each element of `list`. If `f` returns\n`Some(value)`, then `value` is _kept_ in the resulting list. If `f` returns\n`None`, the element is _not_ retained in the result.\n\n## Examples\n\n```rescript\nlet isEven = x => mod(x, 2) == 0\n\nlist{1, 2, 3, 4}\n->List.filterMap(x =>\n    if (isEven(x)) {\n      Some(x)\n    } else {\n      None\n    }\n  ) // list{2, 4}\n\nlist{Some(1), Some(2), None}->List.filterMap(x => x) // list{1, 2}\n```"]
    }, 
    {
      "id": "RescriptCore.List.partition",
      "kind": "value",
      "name": "partition",
      "signature": "let partition: (t<'a>, 'a => bool) => (t<'a>, t<'a>)",
      "docstrings": ["`partition(list, f)` creates a pair of lists; the first list consists of all\nelements of `list` that satisfy the predicate function `f`, the second list\nconsists of all elements of `list` that _do not_ satisfy `f`.\n\n## Examples\n\n```rescript\n// (elementsThatSatisfies, elementsThatDoesNotSatisfy)\n\nList.partition(list{1, 2, 3, 4}, x => x > 2) // (list{3, 4}, list{1, 2})\n```"]
    }, 
    {
      "id": "RescriptCore.List.unzip",
      "kind": "value",
      "name": "unzip",
      "signature": "let unzip: t<('a, 'b)> => (t<'a>, t<'b>)",
      "docstrings": ["`unzip(list)` takes a list of pairs and creates a pair of lists. The first list\ncontains all the first items of the pairs, the second list contains all the\nsecond items.\n\n## Examples\n\n```rescript\nList.unzip(list{(1, 2), (3, 4)}) // (list{1, 3}, list{2, 4})\n\nList.unzip(list{(\"H\", \"W\"), (\"e\", \"o\"), (\"l\", \"r\"), (\"l\", \"l\"), (\"o\", \"d\"), (\" \", \"!\")})\n// (list{\"H\", \"e\", \"l\", \"l\", \"o\", \" \"}, list{\"W\", \"o\", \"r\", \"l\", \"d\", \"!\"})\n```"]
    }, 
    {
      "id": "RescriptCore.List.getAssoc",
      "kind": "value",
      "name": "getAssoc",
      "signature": "let getAssoc: (t<('a, 'c)>, 'b, ('a, 'b) => bool) => option<'c>",
      "docstrings": ["`getAssoc(list, k, f)` return the second element of a pair in `list` where\nthe first element equals `k` as per the predicate function `f`, or `None` if\nnot found.\n\n## Examples\n\n```rescript\nlist{(1, \"a\"), (2, \"b\"), (3, \"c\")}->List.getAssoc(3, (a, b) => a == b) // Some(\"c\")\n\nlist{(9, \"morning\"), (15, \"afternoon\"), (22, \"night\")}\n->List.getAssoc(15, (k, item) => k /* 15 */ == item /* 9, 5, 22 */)\n// Some(\"afternoon\")\n```"]
    }, 
    {
      "id": "RescriptCore.List.hasAssoc",
      "kind": "value",
      "name": "hasAssoc",
      "signature": "let hasAssoc: (t<('a, 'c)>, 'b, ('a, 'b) => bool) => bool",
      "docstrings": ["`hasAssoc(list, k, f)` returns `true` if there is a pair in `list` where the\nfirst element equals `k` as per the predicate function `f`.\n\n## Examples\n\n```rescript\nlist{(1, \"a\"), (2, \"b\"), (3, \"c\")}->List.hasAssoc(1, (a, b) => a == b) // true\n\nlist{(9, \"morning\"), (15, \"afternoon\"), (22, \"night\")}\n->List.hasAssoc(25, (k, item) => k /* 25 */ == item /* 9, 5, 22 */) // false\n```"]
    }, 
    {
      "id": "RescriptCore.List.removeAssoc",
      "kind": "value",
      "name": "removeAssoc",
      "signature": "let removeAssoc: (t<('a, 'c)>, 'b, ('a, 'b) => bool) => t<('a, 'c)>",
      "docstrings": ["`removeAssoc(list, k, f)` return a list after removing the first pair whose\nfirst value is `k` per the equality predicate `f`, if not found, return a new\nlist identical to `list`.\n\n## Examples\n\n```rescript\nlist{(1, \"a\"), (2, \"b\"), (3, \"c\")}->List.removeAssoc(1, (a, b) => a == b) // list{(2, \"b\"), (3, \"c\")}\n\nlist{(9, \"morning\"), (15, \"afternoon\"), (22, \"night\")}\n->List.removeAssoc(9, (k, item) => k /* 9 */ == item /* 9, 5, 22 */)\n// list{(15, \"afternoon\"), (22, \"night\")}\n```"]
    }, 
    {
      "id": "RescriptCore.List.setAssoc",
      "kind": "value",
      "name": "setAssoc",
      "signature": "let setAssoc: (t<('a, 'c)>, 'a, 'c, ('a, 'a) => bool) => t<('a, 'c)>",
      "docstrings": ["`setAssoc(list, k, v, f)`. If `k` exists in `list` by satisfying the `f`\npredicate, return a new list with the key and value replaced by the new `k` and\n`v`, otherwise, return a new list with the pair `k`, `v` added to the head of\n`list`.\n\n## Examples\n\n```rescript\nlist{(1, \"a\"), (2, \"b\"), (3, \"c\")}->List.setAssoc(2, \"x\", (a, b) => a == b) // list{(1, \"a\"), (2, \"x\"), (3, \"c\")}\n\nlist{(1, \"a\"), (3, \"c\")}->List.setAssoc(2, \"b\", (a, b) => a == b) // list{(2, \"b\"), (1, \"a\"), (3, \"c\")}\n\nlist{(9, \"morning\"), (3, \"morning?!\"), (22, \"night\")}\n->List.setAssoc(15, \"afternoon\", (a, b) => mod(a, 12) == mod(b, 12))\n// list{(9, \"morning\"), (15, \"afternoon\"), (22, \"night\")}\n```\n\n**Please note**: In the last example, since: `15 mod 12` equals `3 mod 12`. Both\nthe key _and_ the value are replaced in the list."]
    }, 
    {
      "id": "RescriptCore.List.sort",
      "kind": "value",
      "name": "sort",
      "signature": "let sort: (t<'a>, ('a, 'a) => Core__Ordering.t) => t<'a>",
      "docstrings": ["`sort(list, f)` returns a sorted list.\n\n## Examples\n\n```rescript\nList.sort(list{5, 4, 9, 3, 7}, Int.compare) // list{3, 4, 5, 7, 9}\n```"]
    }]
  }, 
  {
    "id": "RescriptCore.Result",
    "kind": "moduleAlias",
    "name": "Result",
    "docstrings": [],
    "items": [
    {
      "id": "RescriptCore.Result.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'a, 'b> = result<'a, 'b> = Ok('a) | Error('b)",
      "docstrings": ["Result types are really useful to describe the result of a certain operation\n  without relying on exceptions or `option` types.\n\n  This module gives you useful utilities to create and combine `Result` data."],
      "detail": 
      {
        "kind": "variant",
        "items": [
        {
          "name": "Ok",
          "docstrings": [],
          "signature": "Ok('a)"
        }, 
        {
          "name": "Error",
          "docstrings": [],
          "signature": "Error('b)"
        }]
      }
    }, 
    {
      "id": "RescriptCore.Result.getExn",
      "kind": "value",
      "name": "getExn",
      "signature": "let getExn: t<'a, 'b> => 'a",
      "docstrings": ["`getExn(res)`: when `res` is `Ok(n)`, returns `n` when `res` is `Error(m)`, raise an exception\n\n  ```res example\n  Result.getExn(Result.Ok(42)) == 42\n\n  Result.getExn(Result.Error(\"Invalid data\")) /* raises exception */\n  ```"]
    }, 
    {
      "id": "RescriptCore.Result.mapOr",
      "kind": "value",
      "name": "mapOr",
      "signature": "let mapOr: (t<'a, 'c>, 'b, 'a => 'b) => 'b",
      "docstrings": ["`mapOr(res, default, f)`: When res is `Ok(n)`, returns `f(n)`,\n  otherwise `default`.\n\n  ```res example\n  let ok = Result.Ok(42)\n  Result.mapOr(ok, 0, (x) => x / 2) == 21\n\n  let error = Result.Error(\"Invalid data\")\n  Result.mapOr(error, 0, (x) => x / 2) == 0\n  ```"]
    }, 
    {
      "id": "RescriptCore.Result.mapWithDefault",
      "kind": "value",
      "name": "mapWithDefault",
      "deprecated": "Use mapOr instead",
      "signature": "let mapWithDefault: (t<'a, 'c>, 'b, 'a => 'b) => 'b",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Result.map",
      "kind": "value",
      "name": "map",
      "signature": "let map: (t<'a, 'c>, 'a => 'b) => t<'b, 'c>",
      "docstrings": ["`map(res, f)`: When res is `Ok(n)`, returns `Ok(f(n))`. Otherwise returns res\n  unchanged. Function `f` takes a value of the same type as `n` and returns an\n  ordinary value.\n\n  ```res example\n  let f = (x) => sqrt(Int.toFloat(x))\n\n  Result.map(Ok(64), f) == Ok(8.0)\n\n  Result.map(Error(\"Invalid data\"), f) == Error(\"Invalid data\")\n  ```"]
    }, 
    {
      "id": "RescriptCore.Result.flatMap",
      "kind": "value",
      "name": "flatMap",
      "signature": "let flatMap: (t<'a, 'c>, 'a => t<'b, 'c>) => t<'b, 'c>",
      "docstrings": ["`flatMap(res, f)`: When res is `Ok(n)`, returns `f(n)`. Otherwise, returns res\n  unchanged. Function `f` takes a value of the same type as `n` and returns a\n  `Result`.\n\n  ```res example\n  let recip = (x) =>\n    if (x !== 0.0) {\n      Result.Ok(1.0 /. x)\n    } else {\n      Result.Error(\"Divide by zero\")\n    }\n\n  Result.flatMap(Ok(2.0), recip) == Ok(0.5)\n\n  Result.flatMap(Ok(0.0), recip) == Error(\"Divide by zero\")\n\n  Result.flatMap(Error(\"Already bad\"), recip) == Error(\"Already bad\")\n  ```"]
    }, 
    {
      "id": "RescriptCore.Result.getOr",
      "kind": "value",
      "name": "getOr",
      "signature": "let getOr: (t<'a, 'b>, 'a) => 'a",
      "docstrings": ["`getOr(res, defaultValue)`: If `res` is `Ok(n)`, returns `n`,\n  otherwise `default`\n\n  ```res example\n  Result.getOr(Ok(42), 0) == 42\n\n  Result.getOr(Error(\"Invalid Data\"), 0) == 0\n  ```"]
    }, 
    {
      "id": "RescriptCore.Result.getWithDefault",
      "kind": "value",
      "name": "getWithDefault",
      "deprecated": "Use getOr instead",
      "signature": "let getWithDefault: (t<'a, 'b>, 'a) => 'a",
      "docstrings": []
    }, 
    {
      "id": "RescriptCore.Result.isOk",
      "kind": "value",
      "name": "isOk",
      "signature": "let isOk: t<'a, 'b> => bool",
      "docstrings": ["`isOk(res)`: Returns `true` if `res` is of the form `Ok(n)`, `false` if it is\n  the `Error(e)` variant."]
    }, 
    {
      "id": "RescriptCore.Result.isError",
      "kind": "value",
      "name": "isError",
      "signature": "let isError: t<'a, 'b> => bool",
      "docstrings": ["`isError(res)`: Returns `true` if `res` is of the form `Error(e)`, `false` if\n  it is the `Ok(n)` variant."]
    }, 
    {
      "id": "RescriptCore.Result.equal",
      "kind": "value",
      "name": "equal",
      "signature": "let equal: (t<'a, 'c>, t<'b, 'd>, ('a, 'b) => bool) => bool",
      "docstrings": ["`equal(res1, res2, f)`: Determine if two `Result` variables are equal with\n  respect to an equality function. If `res1` and `res2` are of the form `Ok(n)`\n  and `Ok(m)`, return the result of `f(n, m)`. If one of `res1` and `res2` are of\n  the form `Error(e)`, return false If both `res1` and `res2` are of the form\n  `Error(e)`, return true\n\n  ```res example\n  let good1 = Result.Ok(42)\n\n  let good2 = Result.Ok(32)\n\n  let bad1 = Result.Error(\"invalid\")\n\n  let bad2 = Result.Error(\"really invalid\")\n\n  let mod10equal = (a, b) => mod(a, 10) === mod(b, 10)\n\n  Result.equal(good1, good2, mod10equal) == true\n\n  Result.equal(good1, bad1, mod10equal) == false\n\n  Result.equal(bad2, good2, mod10equal) == false\n\n  Result.equal(bad1, bad2, mod10equal) == true\n  ```"]
    }, 
    {
      "id": "RescriptCore.Result.compare",
      "kind": "value",
      "name": "compare",
      "signature": "let compare: (t<'a, 'c>, t<'b, 'd>, ('a, 'b) => Core__Ordering.t) => Core__Ordering.t",
      "docstrings": ["`compare(res1, res2, f)`: Compare two `Result` variables with respect to a\n  comparison function. The comparison function returns -1. if the first variable\n  is \"less than\" the second, 0. if the two variables are equal, and 1. if the first\n  is \"greater than\" the second.\n\n  If `res1` and `res2` are of the form `Ok(n)` and `Ok(m)`, return the result of\n  `f(n, m)`. If `res1` is of the form `Error(e)` and `res2` of the form `Ok(n)`,\n  return -1. (nothing is less than something) If `res1` is of the form `Ok(n)` and\n  `res2` of the form `Error(e)`, return 1. (something is greater than nothing) If\n  both `res1` and `res2` are of the form `Error(e)`, return 0. (equal)\n\n  ```res example\n  let good1 = Result.Ok(59)\n\n  let good2 = Result.Ok(37)\n\n  let bad1 = Result.Error(\"invalid\")\n\n  let bad2 = Result.Error(\"really invalid\")\n\n  let mod10cmp = (a, b) => Pervasives.compare(mod(a, 10), mod(b, 10))\n\n  Result.compare(Ok(39), Ok(57), mod10cmp) == 1.\n\n  Result.compare(Ok(57), Ok(39), mod10cmp) == (-1.)\n\n  Result.compare(Ok(39), Error(\"y\"), mod10cmp) == 1.\n\n  Result.compare(Error(\"x\"), Ok(57), mod10cmp) == (-1.)\n\n  Result.compare(Error(\"x\"), Error(\"y\"), mod10cmp) == 0.\n  ```"]
    }, 
    {
      "id": "RescriptCore.Result.forEach",
      "kind": "value",
      "name": "forEach",
      "signature": "let forEach: (t<'a, 'b>, 'a => unit) => unit",
      "docstrings": ["`forEach(res, f)` runs the provided function `f` on the `Ok` value. If `res` is `Error`, nothing happens.\n\n## Examples\n\n```rescript\nResult.forEach(Ok(3), Console.log) // Logs \"3\", returns ()\nResult.forEach(Error(\"x\"), Console.log) // Does nothing, returns ()\n```"]
    }, 
    {
      "id": "RescriptCore.Result.mapError",
      "kind": "value",
      "name": "mapError",
      "signature": "let mapError: (result<'a, 'b>, 'b => 'c) => result<'a, 'c>",
      "docstrings": ["`mapError(r, f)` generates a new `result` by applying the function `f` to the `Error` value. If the source is `Ok`, return it as-is.\n\n## Examples\n\n```rescript\nlet format = n => `Error code: ${n->Int.toString}`\nmapError(Error(14), format) // Error(\"Error code: 14\")\nmapError(Ok(\"abc\"), format) // Ok(\"abc\")\n```"]
    }]
  }, 
  {
    "id": "RescriptCore.null",
    "kind": "type",
    "name": "null",
    "signature": "type null<'a> = Js.null<'a>",
    "docstrings": []
  }, 
  {
    "id": "RescriptCore.undefined",
    "kind": "type",
    "name": "undefined",
    "signature": "type undefined<'a> = Js.undefined<'a>",
    "docstrings": []
  }, 
  {
    "id": "RescriptCore.nullable",
    "kind": "type",
    "name": "nullable",
    "signature": "type nullable<'a> = Js.nullable<'a>",
    "docstrings": []
  }, 
  {
    "id": "RescriptCore.panic",
    "kind": "value",
    "name": "panic",
    "signature": "let panic: string => 'a",
    "docstrings": []
  }]
}

